[
    {
        "text": "Navigation",
        "type": "Title"
    },
    {
        "text": "index",
        "type": "ListItem"
    },
    {
        "text": "modules |",
        "type": "ListItem"
    },
    {
        "text": "next |",
        "type": "ListItem"
    },
    {
        "text": "previous |",
        "type": "ListItem"
    },
    {
        "text": "music21 \u00bb",
        "type": "ListItem"
    },
    {
        "text": "Module Reference \u00bb",
        "type": "ListItem"
    },
    {
        "text": "music21.musicxml.m21ToXml",
        "type": "ListItem"
    },
    {
        "text": "Previous topic",
        "type": "Title"
    },
    {
        "text": "music21.musicxml.lilypondTestSuite",
        "type": "Title"
    },
    {
        "text": "Next topic",
        "type": "Title"
    },
    {
        "text": "music21.musicxml.partStaffExporter",
        "type": "Title"
    },
    {
        "text": "Table of Contents",
        "type": "Title"
    },
    {
        "text": "music21.musicxml.m21ToXml\nGeneralObjectExporter\nGeneralObjectExporter\nGeneralObjectExporter.fromDiatonicScale()\nGeneralObjectExporter.fromDuration()\nGeneralObjectExporter.fromDynamic()\nGeneralObjectExporter.fromGeneralNote()\nGeneralObjectExporter.fromGeneralObject()\nGeneralObjectExporter.fromMeasure()\nGeneralObjectExporter.fromMusic21Object()\nGeneralObjectExporter.fromPart()\nGeneralObjectExporter.fromPitch()\nGeneralObjectExporter.fromScale()\nGeneralObjectExporter.fromScore()\nGeneralObjectExporter.fromStream()\nGeneralObjectExporter.fromVoice()\nGeneralObjectExporter.parse()\nGeneralObjectExporter.parseWellformedObject()\n\n\n\n\nMeasureExporter\nMeasureExporter\nMeasureExporter.appendArpeggioMarkSpannersToNotations()\nMeasureExporter.arpeggioMarkToMxExpression()\nMeasureExporter.articulationToXmlArticulation()\nMeasureExporter.articulationToXmlTechnical()\nMeasureExporter.barlineToXml()\nMeasureExporter.beamToXml()\nMeasureExporter.beamsToXml()\nMeasureExporter.chordSymbolToXml()\nMeasureExporter.chordToXml()\nMeasureExporter.chordWithFretBoardToXml()\nMeasureExporter.clefToXml()\nMeasureExporter.codaToXml()\nMeasureExporter.dealWithNotehead()\nMeasureExporter.durationXml()\nMeasureExporter.dynamicToXml()\nMeasureExporter.expressionToXml()\nMeasureExporter.fretBoardToXml()\nMeasureExporter.fretNoteToXml()\nMeasureExporter.getArpeggioNumber()\nMeasureExporter.intervalToXmlTranspose()\nMeasureExporter.keySignatureToXml()\nMeasureExporter.lyricToXml()\nMeasureExporter.mainElementsParse()\nMeasureExporter.measureStyle()\nMeasureExporter.moveBackward()\nMeasureExporter.moveForward()\nMeasureExporter.noChordToXml()\nMeasureExporter.noteToNotations()\nMeasureExporter.noteToXml()\nMeasureExporter.noteheadToXml()\nMeasureExporter.objectAttachedSpannersToNotations()\nMeasureExporter.objectAttachedSpannersToTechnicals()\nMeasureExporter.ornamentToMxAccidentalMarks()\nMeasureExporter.parse()\nMeasureExporter.parseFlatElements()\nMeasureExporter.parseOneElement()\nMeasureExporter.pitchToXml()\nMeasureExporter.placeInDirection()\nMeasureExporter.rehearsalMarkToXml()\nMeasureExporter.relatedSpanners()\nMeasureExporter.repeatToXml()\nMeasureExporter.restToXml()\nMeasureExporter.romanNumeralToXml()\nMeasureExporter.segnoToXml()\nMeasureExporter.setBarline()\nMeasureExporter.setHarmonic()\nMeasureExporter.setLeftBarline()\nMeasureExporter.setLineStyle()\nMeasureExporter.setMxAttributes()\nMeasureExporter.setMxAttributesObjectForStartOfMeasure()\nMeasureExporter.setMxPrint()\nMeasureExporter.setNoteInstrument()\nMeasureExporter.setOffsetOptional()\nMeasureExporter.setRbSpanners()\nMeasureExporter.setRightBarline()\nMeasureExporter.setTranspose()\nMeasureExporter.staffLayoutToXmlPrint()\nMeasureExporter.staffLayoutToXmlStaffDetails()\nMeasureExporter.tempoIndicationToXml()\nMeasureExporter.textExpressionToXml()\nMeasureExporter.tieToXmlTie()\nMeasureExporter.tieToXmlTied()\nMeasureExporter.timeSignatureToXml()\nMeasureExporter.tupletToTimeModification()\nMeasureExporter.tupletToXmlTuplet()\nMeasureExporter.unpitchedToXml()\nMeasureExporter.wrapObjectInAttributes()\n\n\n\n\nPartExporter\nPartExporter\nPartExporter.fixupNotationFlat()\nPartExporter.fixupNotationMeasured()\nPartExporter.getXmlScorePart()\nPartExporter.instrumentSetup()\nPartExporter.instrumentToXmlMidiInstrument()\nPartExporter.instrumentToXmlScoreInstrument()\nPartExporter.mergeInstrumentStreamPartStaffAware()\nPartExporter.parse()\nPartExporter.previousPartStaffInGroup\n\n\n\n\nScoreExporter\nScoreExporter\nScoreExporter.addStyleToXmlDefaults()\nScoreExporter.contributorToXmlCreator()\nScoreExporter.emptyObject()\nScoreExporter.getSupports()\nScoreExporter.metadataToMiscellaneous()\nScoreExporter.parse()\nScoreExporter.parseFlatScore()\nScoreExporter.parsePartlikeScore()\nScoreExporter.postPartProcess()\nScoreExporter.renumberVoicesWithinStaffGroups()\nScoreExporter.scorePreliminaries()\nScoreExporter.setDefaults()\nScoreExporter.setEncoding()\nScoreExporter.setIdentification()\nScoreExporter.setMeterStream()\nScoreExporter.setPartExporterStaffGroups()\nScoreExporter.setPartList()\nScoreExporter.setPartsAndRefStream()\nScoreExporter.setScoreHeader()\nScoreExporter.setScoreLayouts()\nScoreExporter.setTitles()\nScoreExporter.staffGroupToXmlPartGroup()\nScoreExporter.styleToXmlAppearance()\nScoreExporter.textBoxToXmlCredit()\n\n\n\n\nXMLExporterBase\nXMLExporterBase\nXMLExporterBase.accidentalToMx()\nXMLExporterBase.accidentalToMxAccidentalMark()\nXMLExporterBase.addDividerComment()\nXMLExporterBase.asBytes()\nXMLExporterBase.dump()\nXMLExporterBase.pageLayoutToXmlPageLayout()\nXMLExporterBase.pageLayoutToXmlPrint()\nXMLExporterBase.setColor()\nXMLExporterBase.setEditorial()\nXMLExporterBase.setFont()\nXMLExporterBase.setPosition()\nXMLExporterBase.setPrintObject()\nXMLExporterBase.setPrintStyle()\nXMLExporterBase.setPrintStyleAlign()\nXMLExporterBase.setStyleAttributes()\nXMLExporterBase.setTextFormatting()\nXMLExporterBase.staffLayoutToXmlStaffLayout()\nXMLExporterBase.systemLayoutToXmlPrint()\nXMLExporterBase.systemLayoutToXmlSystemLayout()\nXMLExporterBase.xmlHeader()\n\n\n\n\nFunctions\ngetMetadataFromContext()\nnormalizeColor()\ntypeToMusicXMLType()",
        "type": "ListItem"
    },
    {
        "text": "Table of Contents",
        "type": "Title"
    },
    {
        "text": "About music21",
        "type": "ListItem"
    },
    {
        "text": "User's Guide",
        "type": "ListItem"
    },
    {
        "text": "Module Reference",
        "type": "ListItem"
    },
    {
        "text": "Installation",
        "type": "ListItem"
    },
    {
        "text": "Developer Reference",
        "type": "ListItem"
    },
    {
        "text": "Documentation and tests in progress",
        "type": "ListItem"
    },
    {
        "text": "Quick search",
        "type": "Title"
    },
    {
        "text": "This Page",
        "type": "Title"
    },
    {
        "text": "Show Source",
        "type": "ListItem"
    },
    {
        "text": "music21.musicxml.m21ToXml\u00c2\u00b6",
        "type": "Title"
    },
    {
        "text": "Converters for music21 objects to musicxml using ElementTree",
        "type": "NarrativeText"
    },
    {
        "text": "GeneralObjectExporter\u00c2\u00b6",
        "type": "Title"
    },
    {
        "text": "class",
        "type": "Title"
    },
    {
        "text": "music21.musicxml.m21ToXml.",
        "type": "Title"
    },
    {
        "text": "GeneralObjectExporter",
        "type": "Title"
    },
    {
        "text": "obj",
        "type": "Title"
    },
    {
        "text": "ProtoM21Object | None",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Packs any Music21Object into a well-formed score and exports\na bytes object MusicXML representation.",
        "type": "ListItem"
    },
    {
        "text": "GeneralObjectExporter methods",
        "type": "Title"
    },
    {
        "text": "GeneralObjectExporter.",
        "type": "Title"
    },
    {
        "text": "fromDiatonicScale",
        "type": "Title"
    },
    {
        "text": "diatonicScaleObject",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Return a complete musicxml of the DiatonicScale\nOverrides the general scale behavior to highlight\nthe tonic and dominant.\n>>> cMaj = scale.MajorScale('C')\n>>> GEX = musicxml.m21ToXml.GeneralObjectExporter()\n>>> m = GEX.fromDiatonicScale(cMaj)\n>>> m\n<music21.stream.Score 0x11d4f17b8>\n\n\n>>> m.show('text')\n{0.0} <music21.stream.Part 0x116a04b38>\n    {0.0} <music21.stream.Measure 1 offset=0.0>\n        {0.0} <music21.clef.TrebleClef>\n        {0.0} <music21.meter.TimeSignature 11/4>\n        {0.0} <music21.note.Note C>\n        {4.0} <music21.note.Note D>\n        {5.0} <music21.note.Note E>\n        {6.0} <music21.note.Note F>\n        {7.0} <music21.note.Note G>\n        {9.0} <music21.note.Note A>\n        {10.0} <music21.note.Note B>",
        "type": "ListItem"
    },
    {
        "text": "GeneralObjectExporter.",
        "type": "Title"
    },
    {
        "text": "fromDuration",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Translate a music21 Duration into\na complete MusicXML representation.\nRarely, rarely used.  Only if you call .show() on a duration object",
        "type": "ListItem"
    },
    {
        "text": "GeneralObjectExporter.",
        "type": "Title"
    },
    {
        "text": "fromDynamic",
        "type": "Title"
    },
    {
        "text": "dynamicObject",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Provide a complete MusicXML string from a single dynamic by\nputting it into a Stream first.",
        "type": "ListItem"
    },
    {
        "text": "GeneralObjectExporter.",
        "type": "Title"
    },
    {
        "text": "fromGeneralNote",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Translate a music21 Note into an object\nready to be parsed.\nAn attempt is made to find the best TimeSignature for quarterLengths\n<= 6:\n>>> n = note.Note('c3')\n>>> n.quarterLength = 3\n>>> GEX = musicxml.m21ToXml.GeneralObjectExporter()\n>>> sc = GEX.fromGeneralNote(n)\n>>> sc.show('t')\n{0.0} <music21.stream.Part 0x1046afa90>\n    {0.0} <music21.stream.Measure 1 offset=0.0>\n        {0.0} <music21.clef.BassClef>\n        {0.0} <music21.meter.TimeSignature 6/8>\n        {0.0} <music21.note.Note C>\n        {3.0} <music21.bar.Barline type=final>\n\n\nBut longer notes will be broken into tied components placed in\n4/4 measures:\n>>> long_note = note.Note('e5', quarterLength=40)\n>>> GEX = musicxml.m21ToXml.GeneralObjectExporter()\n>>> sc = GEX.fromGeneralNote(long_note)\n>>> sc[meter.TimeSignature].first()\n<music21.meter.TimeSignature 4/4>\n>>> len(sc[stream.Measure])\n10",
        "type": "ListItem"
    },
    {
        "text": "GeneralObjectExporter.",
        "type": "Title"
    },
    {
        "text": "fromGeneralObject",
        "type": "Title"
    },
    {
        "text": "obj",
        "type": "Title"
    },
    {
        "text": "ProtoM21Object",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Converts any Music21Object (or a duration or a pitch) to something that\ncan be passed to ScoreExporter.\n>>> GEX = musicxml.m21ToXml.GeneralObjectExporter()\n>>> s = GEX.fromGeneralObject(duration.Duration(3.0))\n>>> s\n<music21.stream.Score 0x...>\n>>> s.show('t')\n{0.0} <music21.stream.Part 0x...>\n    {0.0} <music21.stream.Measure 1 offset=0.0>\n        {0.0} <music21.clef.TrebleClef>\n        {0.0} <music21.meter.TimeSignature 6/8>\n        {0.0} <music21.note.Note C>\n        {3.0} <music21.bar.Barline type=final>\n>>> s[note.NotRest].first().duration\n<music21.duration.Duration 3.0>\n\n\n\nChanged in v8: fills gaps with rests before calling makeNotation\nto avoid duplicating effort with PartExporter.fixupNotationMeasured().\n\n>>> v = stream.Voice(note.Note())\n>>> m = stream.Measure([meter.TimeSignature(), v])\n>>> GEX = musicxml.m21ToXml.GeneralObjectExporter(m)\n>>> out = GEX.parse()  # out is bytes\n>>> outStr = out.decode('utf-8')  # now is string\n>>> '<note print-object=\"no\" print-spacing=\"yes\">' in outStr\nTrue\n>>> len(v[note.Rest])  # original stream unchanged\n0",
        "type": "ListItem"
    },
    {
        "text": "GeneralObjectExporter.",
        "type": "Title"
    },
    {
        "text": "fromMeasure",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Translate a music21 Measure into a\ncomplete MusicXML string representation.\nNote: this method is called for complete MusicXML\nrepresentation of a Measure, not for partial\nsolutions in Part or Stream production.",
        "type": "ListItem"
    },
    {
        "text": "GeneralObjectExporter.",
        "type": "Title"
    },
    {
        "text": "fromMusic21Object",
        "type": "Title"
    },
    {
        "text": "obj",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "return a single TimeSignature as a musicxml document",
        "type": "ListItem"
    },
    {
        "text": "GeneralObjectExporter.",
        "type": "Title"
    },
    {
        "text": "fromPart",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "From a part, put it in a new score.",
        "type": "ListItem"
    },
    {
        "text": "GeneralObjectExporter.",
        "type": "Title"
    },
    {
        "text": "fromPitch",
        "type": "Title"
    },
    {
        "text": "Pitch",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Translate a music21 Pitch into an object\nready to be parsed.\n>>> p = pitch.Pitch('c#3')\n>>> GEX = musicxml.m21ToXml.GeneralObjectExporter()\n>>> sc = GEX.fromPitch(p)\n>>> sc.show('t')\n{0.0} <music21.stream.Part 0x1046afa90>\n    {0.0} <music21.stream.Measure 1 offset=0.0>\n        {0.0} <music21.clef.BassClef>\n        {0.0} <music21.meter.TimeSignature 1/4>\n        {0.0} <music21.note.Note C#>",
        "type": "ListItem"
    },
    {
        "text": "GeneralObjectExporter.",
        "type": "Title"
    },
    {
        "text": "fromScale",
        "type": "Title"
    },
    {
        "text": "scaleObject",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Generate the pitches from this scale\nand put it into a stream.Measure, then call\nfromMeasure on it.\n>>> cMaj = scale.MajorScale('C')\n>>> GEX = musicxml.m21ToXml.GeneralObjectExporter()\n>>> m = GEX.fromScale(cMaj)\n>>> m\n<music21.stream.Score 0x11d4f17b8>\n\n\n>>> m.show('text')\n{0.0} <music21.stream.Part 0x116a04b38>\n    {0.0} <music21.stream.Measure 1 offset=0.0>\n        {0.0} <music21.clef.TrebleClef>\n        {0.0} <music21.meter.TimeSignature 10/4>\n        {0.0} <music21.note.Note C>\n        {4.0} <music21.note.Note D>\n        {5.0} <music21.note.Note E>\n        {6.0} <music21.note.Note F>\n        {7.0} <music21.note.Note G>\n        {8.0} <music21.note.Note A>\n        {9.0} <music21.note.Note B>",
        "type": "ListItem"
    },
    {
        "text": "GeneralObjectExporter.",
        "type": "Title"
    },
    {
        "text": "fromScore",
        "type": "Title"
    },
    {
        "text": "sc",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Runs makeNotation() on the copy.",
        "type": "ListItem"
    },
    {
        "text": "GeneralObjectExporter.",
        "type": "Title"
    },
    {
        "text": "fromStream",
        "type": "Title"
    },
    {
        "text": "st",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "",
        "type": "ListItem"
    },
    {
        "text": "GeneralObjectExporter.",
        "type": "Title"
    },
    {
        "text": "fromVoice",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "",
        "type": "ListItem"
    },
    {
        "text": "GeneralObjectExporter.",
        "type": "Title"
    },
    {
        "text": "parse",
        "type": "Title"
    },
    {
        "text": "obj",
        "type": "Title"
    },
    {
        "text": "ProtoM21Object | None",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u2192 bytes",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Return a bytes object representation of anything from a\nScore to a single pitch.\nWhen makeNotation is True (default), wraps obj in a well-formed\nScore, makes a copy, and runs makeNotation()\non each of the parts. To skip copying and making notation, set .makeNotation\non this instance to False.\n>>> p = pitch.Pitch('D#4')\n>>> GEX = musicxml.m21ToXml.GeneralObjectExporter(p)\n>>> out = GEX.parse()  # out is bytes\n>>> outStr = out.decode('utf-8')  # now is string\n>>> print(outStr.strip())\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!DOCTYPE score-partwise\n  PUBLIC \"-//Recordare//DTD MusicXML ... Partwise//EN\"\n  \"http://www.musicxml.org/dtds/partwise.dtd\">\n<score-partwise version=\"...\">\n  <movement-title>Music21 Fragment</movement-title>\n  <identification>\n    <creator type=\"composer\">Music21</creator>\n    <encoding>\n      <encoding-date>...</encoding-date>\n      <software>music21 v...</software>\n    </encoding>\n  </identification>\n  <defaults>\n    <scaling>\n      <millimeters>7</millimeters>\n      <tenths>40</tenths>\n    </scaling>\n  </defaults>\n  <part-list>\n    <score-part id=\"...\">\n      <part-name />\n    </score-part>\n  </part-list>\n  <!--=========================== Part 1 ===========================-->\n  <part id=\"...\">\n    <!--========================= Measure 1 ==========================-->\n    <measure implicit=\"no\" number=\"1\">\n      <attributes>\n        <divisions>10080</divisions>\n        <time>\n          <beats>1</beats>\n          <beat-type>4</beat-type>\n        </time>\n        <clef>\n          <sign>G</sign>\n          <line>2</line>\n        </clef>\n      </attributes>\n      <note>\n        <pitch>\n          <step>D</step>\n          <alter>1</alter>\n          <octave>4</octave>\n        </pitch>\n        <duration>10080</duration>\n        <type>quarter</type>\n        <accidental>sharp</accidental>\n      </note>\n    </measure>\n  </part>\n</score-partwise>",
        "type": "ListItem"
    },
    {
        "text": "GeneralObjectExporter.",
        "type": "Title"
    },
    {
        "text": "parseWellformedObject",
        "type": "Title"
    },
    {
        "text": "sc",
        "type": "Title"
    },
    {
        "text": "Score",
        "type": "Title"
    },
    {
        "text": "\u2192 bytes",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Parse an object that has already gone through the\n.fromGeneralObject conversion, which has produced a copy with\nmakeNotation() run on it\n(unless makeNotation is False).\nReturns bytes.",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter\u00c2\u00b6",
        "type": "Title"
    },
    {
        "text": "class",
        "type": "Title"
    },
    {
        "text": "music21.musicxml.m21ToXml.",
        "type": "Title"
    },
    {
        "text": "MeasureExporter",
        "type": "Title"
    },
    {
        "text": "measureObj",
        "type": "Title"
    },
    {
        "text": "Measure | None",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "parent",
        "type": "Title"
    },
    {
        "text": "PartExporter | None",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter bases",
        "type": "Title"
    },
    {
        "text": "XMLExporterBase",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter methods",
        "type": "Title"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "appendArpeggioMarkSpannersToNotations",
        "type": "Title"
    },
    {
        "text": "obj",
        "type": "Title"
    },
    {
        "text": "Music21Object",
        "type": "Title"
    },
    {
        "text": "noteIndexInChord",
        "type": "Title"
    },
    {
        "text": "int",
        "type": "Title"
    },
    {
        "text": "notations",
        "type": "Title"
    },
    {
        "text": "list[xml.etree.ElementTree.Element]",
        "type": "Title"
    },
    {
        "text": "sb",
        "type": "Title"
    },
    {
        "text": "SpannerBundle",
        "type": "Title"
    },
    {
        "text": "\u2192 None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "arpeggioMarkToMxExpression",
        "type": "Title"
    },
    {
        "text": "arpeggioMark",
        "type": "Title"
    },
    {
        "text": "chordOrNote",
        "type": "Title"
    },
    {
        "text": "noteIndexInChord",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "articulationToXmlArticulation",
        "type": "Title"
    },
    {
        "text": "articulationMark",
        "type": "Title"
    },
    {
        "text": "Articulation",
        "type": "Title"
    },
    {
        "text": "\u2192 Element",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Returns a class (mxArticulationMark) that represents the\nMusicXML structure of an articulation mark.\n>>> a = articulations.Accent()\n>>> a.placement = 'below'\n\n\n>>> MEX = musicxml.m21ToXml.MeasureExporter()\n>>> mxArticulationMark = MEX.articulationToXmlArticulation(a)\n>>> MEX.dump(mxArticulationMark)\n<accent placement=\"below\" />\n\n\n>>> a = articulations.Staccatissimo()\n>>> a.placement = 'below'\n\n\n>>> mxArticulationMark = MEX.articulationToXmlArticulation(a)\n>>> MEX.dump(mxArticulationMark)\n<staccatissimo placement=\"below\" />\n\n\nArticulations can have style attached to them:\n>>> a = articulations.Doit()\n>>> a.style.lineShape = 'curved'\n>>> a.style.lineType = 'dashed'\n>>> a.style.dashLength = 2\n>>> a.style.spaceLength = 1\n>>> a.style.absoluteX = 5\n>>> a.style.absoluteY = 2\n\n\n>>> mxArticulationMark = MEX.articulationToXmlArticulation(a)\n>>> MEX.dump(mxArticulationMark)\n<doit dash-length=\"2\" default-x=\"5\" default-y=\"2\"\n    line-shape=\"curved\" line-type=\"dashed\" space-length=\"1\" />",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "articulationToXmlTechnical",
        "type": "Title"
    },
    {
        "text": "articulationMark",
        "type": "Title"
    },
    {
        "text": "Articulation",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Returns a tag that represents the\nMusicXML structure of an articulation mark that is primarily a TechnicalIndication.\n>>> MEX = musicxml.m21ToXml.MeasureExporter()\n\n\n>>> a = articulations.UpBow()\n>>> a.placement = 'below'\n\n\n>>> mxTechnicalMark = MEX.articulationToXmlTechnical(a)\n>>> MEX.dump(mxTechnicalMark)\n<up-bow placement=\"below\" />\n\n\n>>> f = articulations.Fingering(4)\n>>> f.substitution = True\n>>> mxFingering = MEX.articulationToXmlTechnical(f)\n>>> MEX.dump(mxFingering)\n<fingering alternate=\"no\" substitution=\"yes\">4</fingering>\n\n\nTechnical marks too specific to express in musicxml just get other-technical.\n>>> g = articulations.OrganIndication()\n>>> g.displayText = 'unda maris'\n>>> mxOther = MEX.articulationToXmlTechnical(g)\n>>> MEX.dump(mxOther)\n<other-technical>unda maris</other-technical>",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "barlineToXml",
        "type": "Title"
    },
    {
        "text": "barObject",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Translate a music21 bar.Bar object to an mxBar\nwhile making two substitutions: double -> light-light\nand final -> light-heavy as shown below.\n>>> b = bar.Barline('final')\n>>> MEX = musicxml.m21ToXml.MeasureExporter()\n>>> mxBarline = MEX.barlineToXml(b)\n>>> MEX.dump(mxBarline)\n<barline>\n  <bar-style>light-heavy</bar-style>\n</barline>\n\n\n>>> b.location = 'right'\n>>> mxBarline = MEX.barlineToXml(b)\n>>> MEX.dump(mxBarline)\n<barline location=\"right\">\n  <bar-style>light-heavy</bar-style>\n</barline>",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "beamToXml",
        "type": "Title"
    },
    {
        "text": "beamObject",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Returns an ElementTree Element from a Beam object\n>>> a = beam.Beam()\n>>> a.type = 'start'\n>>> a.number = 1\n\n\n>>> MEX = musicxml.m21ToXml.MeasureExporter()\n>>> b = MEX.beamToXml(a)\n>>> b\n<Element 'beam' at 0x104f3a728>\n>>> MEX.dump(b)\n<beam number=\"1\">begin</beam>\n\n\n>>> a.type = 'continue'\n>>> b = MEX.beamToXml(a)\n>>> MEX.dump(b)\n<beam number=\"1\">continue</beam>\n\n\n>>> a.type = 'stop'\n>>> b = MEX.beamToXml(a)\n>>> MEX.dump(b)\n<beam number=\"1\">end</beam>\n\n\n>>> a.type = 'partial'\n>>> a.direction = 'left'\n>>> b = MEX.beamToXml(a)\n>>> MEX.dump(b)\n<beam number=\"1\">backward hook</beam>\n\n\n>>> a.direction = 'right'\n>>> a.id = 'beam1'\n>>> b = MEX.beamToXml(a)\n>>> MEX.dump(b)\n<beam id=\"beam1\" number=\"1\">forward hook</beam>\n\n\n>>> a.direction = None\n>>> b = MEX.beamToXml(a)\nTraceback (most recent call last):\nmusic21.musicxml.xmlObjects.MusicXMLExportException: partial beam defined\n    without a proper direction set (set to None)\n\n\n>>> a.type = 'crazy'\n>>> b = MEX.beamToXml(a)\nTraceback (most recent call last):\nmusic21.musicxml.xmlObjects.MusicXMLExportException: unexpected beam type\n    encountered (crazy)",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "beamsToXml",
        "type": "Title"
    },
    {
        "text": "beams",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Returns a list of <beam> tags\nfrom a Beams object\n>>> a = beam.Beams()\n>>> a.fill(2, type='start')\n\n\n>>> MEX = musicxml.m21ToXml.MeasureExporter()\n>>> mxBeamList = MEX.beamsToXml(a)\n>>> len(mxBeamList)\n2\n>>> for b in mxBeamList:\n...     MEX.dump(b)\n<beam number=\"1\">begin</beam>\n<beam number=\"2\">begin</beam>",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "chordSymbolToXml",
        "type": "Title"
    },
    {
        "text": "cs",
        "type": "Title"
    },
    {
        "text": "ChordSymbol",
        "type": "Title"
    },
    {
        "text": "append",
        "type": "Title"
    },
    {
        "text": "bool",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "\u2192 Element | list[xml.etree.ElementTree.Element]",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Convert a ChordSymbol object to either a chord (if .writeAsChord is True)\nor a Harmony XML Element.\n>>> cs = harmony.ChordSymbol()\n>>> cs.root('E-')\n>>> cs.bass('B-', allow_add=True)\n>>> cs.inversion(2, transposeOnSet=False)\n>>> cs.chordKind = 'major'\n>>> cs.chordKindStr = 'M'\n>>> cs\n<music21.harmony.ChordSymbol E-/B->\n\n\n>>> MEX = musicxml.m21ToXml.MeasureExporter()\n>>> MEX.currentDivisions = 10\n\n\n>>> mxHarmony = MEX.chordSymbolToXml(cs)\n>>> MEX.dump(mxHarmony)\n<harmony>\n  <root>\n    <root-step>E</root-step>\n    <root-alter>-1</root-alter>\n  </root>\n  <kind text=\"M\">major</kind>\n  <inversion>2</inversion>\n  <bass>\n    <bass-step>B</bass-step>\n    <bass-alter>-1</bass-alter>\n  </bass>\n</harmony>\n\n\nNow give function\u2026\n>>> cs.romanNumeral = 'I64'\n>>> mxHarmony = MEX.chordSymbolToXml(cs)\n>>> MEX.dump(mxHarmony)\n<harmony>\n  <function>I64</function>\n  <kind text=\"M\">major</kind>\n  <inversion>2</inversion>\n  <bass>\n    <bass-step>B</bass-step>\n    <bass-alter>-1</bass-alter>\n  </bass>\n</harmony>\n\n\n>>> hd = harmony.ChordStepModification()\n>>> hd.modType = 'alter'\n>>> hd.interval = -1\n>>> hd.degree = 3\n>>> cs.addChordStepModification(hd)\n\n\n>>> mxHarmony = MEX.chordSymbolToXml(cs)\n>>> MEX.dump(mxHarmony)\n<harmony>\n  <function>I64</function>\n  <kind text=\"M\">major</kind>\n  <inversion>2</inversion>\n  <bass>\n    <bass-step>B</bass-step>\n    <bass-alter>-1</bass-alter>\n  </bass>\n  <degree>\n    <degree-value>3</degree-value>\n    <degree-alter>-1</degree-alter>\n    <degree-type>alter</degree-type>\n  </degree>\n</harmony>\n\n\nTest altered chords:\n>>> f = harmony.ChordSymbol('F sus add 9')\n>>> f\n<music21.harmony.ChordSymbol F sus add 9>\n>>> mxHarmony = MEX.chordSymbolToXml(f)\n>>> MEX.dump(mxHarmony)\n<harmony>\n  <root>\n    <root-step>F</root-step>\n  </root>\n  <kind>suspended-fourth</kind>\n  <degree>\n    <degree-value>9</degree-value>\n    <degree-alter>0</degree-alter>\n    <degree-type>add</degree-type>\n  </degree>\n</harmony>\n\n\nMusicXML uses \u009cdominant\u009d for \u009cdominant-seventh\u009d so check aliases back\u2026\n>>> dom7 = harmony.ChordSymbol('C7')\n>>> dom7.chordKind\n'dominant-seventh'\n>>> mxHarmony = MEX.chordSymbolToXml(dom7)\n>>> MEX.dump(mxHarmony)\n<harmony>\n  <root>\n    <root-step>C</root-step>\n  </root>\n  <kind>dominant</kind>\n</harmony>\n\n\nset writeAsChord to not get a symbol, but the notes.  Will return a list of notes.\n>>> dom7.writeAsChord = True\n>>> harmonyList = MEX.chordSymbolToXml(dom7)\n>>> len(harmonyList)\n4\n>>> MEX.dump(harmonyList[0])\n<note>\n  <pitch>\n    <step>C</step>\n    <octave>3</octave>\n  </pitch>\n  <duration>10</duration>\n  <type>quarter</type>\n</note>",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "chordToXml",
        "type": "Title"
    },
    {
        "text": "ChordBase",
        "type": "Title"
    },
    {
        "text": "\u2192 list[xml.etree.ElementTree.Element]",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Returns a list of <note> tags, all but the first with a <chord/> tag on them.\nAnd appends them to self.xmlRoot\nAttributes of notes are merged from different locations: first from the\nduration objects, then from the pitch objects. Finally, GeneralNote\nattributes are added.\n>>> ch = chord.Chord()\n>>> ch.quarterLength = 2\n>>> b = pitch.Pitch('A-2')\n>>> c = pitch.Pitch('D3')\n>>> d = pitch.Pitch('E4')\n>>> e = [b, c, d]\n>>> ch.pitches = e\n\n\n>>> len(ch.pitches)\n3\n>>> MEX = musicxml.m21ToXml.MeasureExporter()\n>>> len(MEX.xmlRoot)\n0\n>>> mxNoteList = MEX.chordToXml(ch)\n>>> len(mxNoteList)  # get three mxNotes\n3\n>>> len(MEX.xmlRoot)\n3\n\n\n>>> MEX.dump(mxNoteList[0])\n<note>\n  <pitch>\n    <step>A</step>\n    <alter>-1</alter>\n    <octave>2</octave>\n  </pitch>\n  <duration>20160</duration>\n  <type>half</type>\n  <accidental>flat</accidental>\n</note>\n\n\n>>> MEX.dump(mxNoteList[1])\n<note>\n  <chord />\n  <pitch>\n    <step>D</step>\n    <octave>3</octave>\n  </pitch>\n  <duration>20160</duration>\n  <type>half</type>\n</note>\n\n\n>>> MEX.dump(mxNoteList[2])\n<note>\n  <chord />\n  <pitch>\n    <step>E</step>\n    <octave>4</octave>\n  </pitch>\n  <duration>20160</duration>\n  <type>half</type>\n</note>\n\n\nTest that notehead and style translation works:\n>>> g = pitch.Pitch('g3')\n>>> h = note.Note('b4')\n>>> h.notehead = 'diamond'\n>>> h.style.color = 'gold'\n>>> h.style.absoluteX = 176\n>>> ch2 = chord.Chord([g, h])\n>>> ch2.quarterLength = 2.0\n>>> mxNoteList = MEX.chordToXml(ch2)\n>>> MEX.dump(mxNoteList[1])\n<note color=\"#FFD700\" default-x=\"176\">\n  <chord />\n  <pitch>\n    <step>B</step>\n    <octave>4</octave>\n  </pitch>\n  <duration>20160</duration>\n  <type>half</type>\n  <notehead color=\"#FFD700\" parentheses=\"no\">diamond</notehead>\n</note>\n\n\nAnd unpitched chord members:\n>>> perc = percussion.PercussionChord([note.Unpitched(), note.Unpitched()])\n>>> for n in MEX.chordToXml(perc):\n...     MEX.dump(n)\n<note>\n  <unpitched>\n    <display-step>B</display-step>\n    <display-octave>4</display-octave>\n  </unpitched>\n  <duration>10080</duration>\n  <type>quarter</type>\n</note>\n<note>\n  <chord />\n  <unpitched>\n    <display-step>B</display-step>\n    <display-octave>4</display-octave>\n  </unpitched>\n  <duration>10080</duration>\n  <type>quarter</type>\n</note>\n\n\nTest articulations of chords with fingerings. Superfluous fingerings will be ignored.\n>>> testChord = chord.Chord('E4 C5')\n>>> testChord.articulations = [articulations.Fingering(1),\n...        articulations.Accent(), articulations.Fingering(5), articulations.Fingering(3)]\n>>> for n in MEX.chordToXml(testChord):\n...     MEX.dump(n)\n<note>\n  ...\n  <notations>\n    <articulations>\n      <accent />\n    </articulations>\n    <technical>\n      <fingering alternate=\"no\" substitution=\"no\">1</fingering>\n    </technical>\n  </notations>\n</note>\n<note>\n  <chord />\n  ...\n  <notations>\n    <technical>\n      <fingering alternate=\"no\" substitution=\"no\">5</fingering>\n    </technical>\n  </notations>\n</note>",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "chordWithFretBoardToXml",
        "type": "Title"
    },
    {
        "text": "cwf",
        "type": "Title"
    },
    {
        "text": "tablature.ChordWithFretBoard",
        "type": "Title"
    },
    {
        "text": "\u2192 Element",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Deals with both chords and frets.\nGenerate harmony and append xml to it.",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "clefToXml",
        "type": "Title"
    },
    {
        "text": "clefObj",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Given a music21 Clef object, return a MusicXML clef\ntag.\n>>> gc = clef.GClef()\n>>> gc\n<music21.clef.GClef>\n>>> MEX = musicxml.m21ToXml.MeasureExporter()\n>>> mxc = MEX.clefToXml(gc)\n>>> MEX.dump(mxc)\n<clef>\n  <sign>G</sign>\n</clef>\n\n\n>>> b = clef.Treble8vbClef()\n>>> b.octaveChange\n-1\n>>> mxc2 = MEX.clefToXml(b)\n>>> MEX.dump(mxc2)\n<clef>\n  <sign>G</sign>\n  <line>2</line>\n  <clef-octave-change>-1</clef-octave-change>\n</clef>\n\n\n>>> pc = clef.PercussionClef()\n>>> mxc3 = MEX.clefToXml(pc)\n>>> MEX.dump(mxc3)\n<clef>\n  <sign>percussion</sign>\n</clef>\n\n\nClefs without signs get exported as G clefs with a warning\n>>> generic = clef.Clef()\n>>> mxc4 = MEX.clefToXml(generic)\nClef with no .sign exported; setting as a G clef\n>>> MEX.dump(mxc4)\n<clef>\n  <sign>G</sign>\n</clef>",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "codaToXml",
        "type": "Title"
    },
    {
        "text": "coda",
        "type": "Title"
    },
    {
        "text": "Coda",
        "type": "Title"
    },
    {
        "text": "\u2192 Element",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "returns a coda inside a direction-type inside a direction IF coda.useSymbol is\nTrue; otherwise returns a textExpression\u2026\nappends to score\n>>> c = repeat.Coda()\n>>> MEX = musicxml.m21ToXml.MeasureExporter()\n>>> mxCodaDir = MEX.codaToXml(c)\n>>> MEX.dump(mxCodaDir)\n<direction>\n  <direction-type>\n    <coda default-y=\"20\" />\n  </direction-type>\n</direction>\n\n\nturn coda.useSymbol to False to get a text expression instead\n>>> c.useSymbol = False\n>>> MEX = musicxml.m21ToXml.MeasureExporter()\n>>> mxCodaText = MEX.codaToXml(c)\n>>> MEX.dump(mxCodaText)\n<direction>\n  <direction-type>\n    <words default-y=\"20\" enclosure=\"none\"\n        justify=\"center\">Coda</words>\n  </direction-type>\n</direction>",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "dealWithNotehead",
        "type": "Title"
    },
    {
        "text": "mxNote",
        "type": "Title"
    },
    {
        "text": "Element",
        "type": "Title"
    },
    {
        "text": "GeneralNote",
        "type": "Title"
    },
    {
        "text": "chordParent",
        "type": "Title"
    },
    {
        "text": "Chord | None",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u2192 None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Determine if an <notehead> element needs to be added to this <note>\nelement (mxNote) and if it does then get the <notehead> element from\nnoteheadToXml and add it to mxNote.\nComplicated because the chordParent might have notehead\nset, which would affect every note along the way.\nReturns nothing.  The mxNote is modified in place.",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "durationXml",
        "type": "Title"
    },
    {
        "text": "dur",
        "type": "Title"
    },
    {
        "text": "Duration",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Convert a duration.Duration object to a <duration> tag using self.currentDivisions\n>>> d = duration.Duration(1.5)\n>>> MEX = musicxml.m21ToXml.MeasureExporter()\n>>> MEX.currentDivisions = 10\n>>> mxDuration = MEX.durationXml(d)\n>>> MEX.dump(mxDuration)\n<duration>15</duration>",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "dynamicToXml",
        "type": "Title"
    },
    {
        "text": "Dynamic",
        "type": "Title"
    },
    {
        "text": "\u2192 Element",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "return a nested tag:\n<direction><direction-type><dynamic><ff>\nor whatever\u2026\n>>> ppp = dynamics.Dynamic('ppp')\n>>> print('%.2f' % ppp.volumeScalar)\n0.15\n>>> ppp.style.relativeY = -10\n\n\n>>> MEX = musicxml.m21ToXml.MeasureExporter()\n>>> mxDirection = MEX.dynamicToXml(ppp)\n>>> MEX.dump(mxDirection)\n<direction>\n  <direction-type>\n    <dynamics default-x=\"-36\" default-y=\"-80\" relative-y=\"-10\">\n      <ppp />\n    </dynamics>\n  </direction-type>\n  <sound dynamics=\"19\" />\n</direction>\n\n\nappends to score.\nNow with offset not zero.\n>>> MEX = musicxml.m21ToXml.MeasureExporter()\n>>> ppp.offset = 1.0\n>>> mxDirection = MEX.dynamicToXml(ppp)\n>>> MEX.dump(mxDirection)\n<direction>\n  <direction-type>\n    <dynamics default-x=\"-36\" default-y=\"-80\" relative-y=\"-10\">\n      <ppp />\n    </dynamics>\n  </direction-type>\n  <offset sound=\"yes\">10080</offset>\n  <sound dynamics=\"19\" />\n</direction>",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "expressionToXml",
        "type": "Title"
    },
    {
        "text": "expression",
        "type": "Title"
    },
    {
        "text": "Expression",
        "type": "Title"
    },
    {
        "text": "\u2192 Element",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Convert a music21 Expression (expression or ornament)\nto a musicxml tag;\nreturn None if no conversion is possible.\nExpressions apply only to the first note of chord.\n>>> invTurn = expressions.InvertedTurn()\n>>> MEX = musicxml.m21ToXml.MeasureExporter()\n>>> mxExpression = MEX.expressionToXml(invTurn)\n>>> MEX.dump(mxExpression)\n<inverted-turn placement=\"above\" />\n\n\n>>> invDelayedTurn = expressions.InvertedTurn(delay=1.)\n>>> invDelayedTurn.placement = 'below'\n>>> MEX = musicxml.m21ToXml.MeasureExporter()\n>>> mxExpression = MEX.expressionToXml(invDelayedTurn)\n>>> MEX.dump(mxExpression)\n<delayed-inverted-turn placement=\"below\" />\n\n\nSome special types\u2026\n>>> f = expressions.Fermata()\n>>> MEX = musicxml.m21ToXml.MeasureExporter()\n>>> mxExpression = MEX.expressionToXml(f)\n>>> MEX.dump(mxExpression)\n<fermata type=\"inverted\" />\n>>> f.shape = 'angled'\n>>> mxExpression = MEX.expressionToXml(f)\n>>> MEX.dump(mxExpression)\n<fermata type=\"inverted\">angled</fermata>\n\n\n>>> trem = expressions.Tremolo()\n>>> trem.numberOfMarks = 4\n>>> MEX = musicxml.m21ToXml.MeasureExporter()\n>>> mxExpression = MEX.expressionToXml(trem)\n>>> MEX.dump(mxExpression)\n<tremolo type=\"single\">4</tremolo>\n\n\n>>> arp = expressions.ArpeggioMark()\n>>> MEX = musicxml.m21ToXml.MeasureExporter()\n>>> mxExpression = MEX.expressionToXml(arp)\n>>> MEX.dump(mxExpression)\n<arpeggiate />\n>>> arp.type = 'down'\n>>> mxExpression = MEX.expressionToXml(arp)\n>>> MEX.dump(mxExpression)\n<arpeggiate direction=\"down\" />\n\n\n>>> nonArp = expressions.ArpeggioMark('non-arpeggio')\n>>> MEX = musicxml.m21ToXml.MeasureExporter()\n>>> mxExpression = MEX.expressionToXml(nonArp)\n>>> MEX.dump(mxExpression)\n<non-arpeggiate />",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "fretBoardToXml",
        "type": "Title"
    },
    {
        "text": "fretBoard",
        "type": "Title"
    },
    {
        "text": "\u2192 Element | None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "The ChordWithFretBoard Object combines chord symbols with FretNote objects.\n>>> myFretNote1 = tablature.FretNote(1, 2, 2)\n>>> myFretNote2 = tablature.FretNote(2, 3, 3)\n>>> myFretNote3 = tablature.FretNote(3, 2, 1)\n>>> guitarChord = tablature.ChordWithFretBoard('DM', numStrings=6,\n...                    fretNotes=[myFretNote1, myFretNote2, myFretNote3])\n>>> guitarChord.tuning = tablature.GuitarFretBoard().tuning\n>>> guitarChord.getPitches()\n[None, None, None,\n <music21.pitch.Pitch A3>, <music21.pitch.Pitch D4>, <music21.pitch.Pitch F#4>]\n>>> MEX = musicxml.m21ToXml.MeasureExporter()\n>>> MEXChordWithFret = MEX.fretBoardToXml(guitarChord)\n>>> MEX.dump(MEXChordWithFret)\n<frame>\n    <frame-strings>6</frame-strings>\n    <frame-frets>4</frame-frets>\n    <frame-note>\n        <string>3</string>\n        <fret>2</fret>\n        <fingering>1</fingering>\n    </frame-note>\n    <frame-note>\n        <string>2</string>\n        <fret>3</fret>\n        <fingering>3</fingering>\n    </frame-note>\n    <frame-note>\n        <string>1</string>\n        <fret>2</fret>\n        <fingering>2</fingering>\n    </frame-note>\n</frame>",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "fretNoteToXml",
        "type": "Title"
    },
    {
        "text": "fretNote",
        "type": "Title"
    },
    {
        "text": "\u2192 Element",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Converts a FretNote Object to MusicXML readable format.\nNote that, although music21 is referring to FretNotes as FretNotes,\nmusicxml refers to the\nthem as frame notes. To convert between the two formats, \u0098Fret-Note'\nmust be converted to\n\u0098Frame-Note'\n>>> fn = tablature.FretNote(string=3, fret=1, fingering=2)\n>>> MEX = musicxml.m21ToXml.MeasureExporter()\n>>> MEXFretNote = MEX.fretNoteToXml(fn)\n>>> MEX.dump(MEXFretNote)\n<frame-note>\n    <string>3</string>\n    <fret>1</fret>\n    <fingering>2</fingering>\n</frame-note>\n\n\nWithout fingering!\n>>> fn2 = tablature.FretNote(string=5, fret=2)\n>>> MEX = musicxml.m21ToXml.MeasureExporter()\n>>> MEXOtherFretNote = MEX.fretNoteToXml(fn2)\n>>> MEX.dump(MEXOtherFretNote)\n<frame-note>\n    <string>5</string>\n    <fret>2</fret>\n</frame-note>",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "getArpeggioNumber",
        "type": "Title"
    },
    {
        "text": "arp",
        "type": "Title"
    },
    {
        "text": "ArpeggioMarkSpanner",
        "type": "Title"
    },
    {
        "text": "\u2192 int",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "intervalToXmlTranspose",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": ">>> ME = musicxml.m21ToXml.MeasureExporter()\n>>> i = interval.Interval('P5')\n>>> mxTranspose = ME.intervalToXmlTranspose(i)\n>>> ME.dump(mxTranspose)\n<transpose>\n  <diatonic>4</diatonic>\n  <chromatic>7</chromatic>\n</transpose>\n\n\n>>> i = interval.Interval('A13')\n>>> mxTranspose = ME.intervalToXmlTranspose(i)\n>>> ME.dump(mxTranspose)\n<transpose>\n  <diatonic>5</diatonic>\n  <chromatic>10</chromatic>\n  <octave-change>1</octave-change>\n</transpose>\n\n\n>>> i = interval.Interval('-M6')\n>>> mxTranspose = ME.intervalToXmlTranspose(i)\n>>> ME.dump(mxTranspose)\n<transpose>\n  <diatonic>-5</diatonic>\n  <chromatic>-9</chromatic>\n</transpose>\n\n\n>>> i = interval.Interval('-M9')\n>>> mxTranspose = ME.intervalToXmlTranspose(i)\n>>> ME.dump(mxTranspose)\n<transpose>\n  <diatonic>-1</diatonic>\n  <chromatic>-2</chromatic>\n  <octave-change>-1</octave-change>\n</transpose>",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "keySignatureToXml",
        "type": "Title"
    },
    {
        "text": "keyOrKeySignature",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "returns a key tag from a music21\nkey.KeySignature or key.Key object\n>>> ks = key.KeySignature(-3)\n>>> ks\n<music21.key.KeySignature of 3 flats>\n\n\n>>> MEX = musicxml.m21ToXml.MeasureExporter()\n>>> mxKey = MEX.keySignatureToXml(ks)\n>>> MEX.dump(mxKey)\n<key>\n  <fifths>-3</fifths>\n</key>\n\n\n>>> ks.mode = 'major'\n>>> mxKey = MEX.keySignatureToXml(ks)\n>>> MEX.dump(mxKey)\n<key>\n  <fifths>-3</fifths>\n  <mode>major</mode>\n</key>\n\n\n>>> ksNonTrad = key.KeySignature(sharps=None)\n>>> ksNonTrad.alteredPitches = ['C#', 'E-4']\n>>> ksNonTrad\n<music21.key.KeySignature of pitches: [C#, E-4]>\n\n\n>>> mxKeyNonTrad = MEX.keySignatureToXml(ksNonTrad)\n>>> MEX.dump(mxKeyNonTrad)\n<key>\n  <key-step>C</key-step>\n  <key-alter>1</key-alter>\n  <key-step>E</key-step>\n  <key-alter>-1</key-alter>\n  <key-octave number=\"2\">4</key-octave>\n</key>",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "lyricToXml",
        "type": "Title"
    },
    {
        "text": "ly",
        "type": "Title"
    },
    {
        "text": "Lyric",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Translate a music21 Lyric object\nto a <lyric> tag.\nLyrics have attribute list %justify, %position, %placement, %color, %print-object",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "mainElementsParse",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "deals with parsing all the elements in a stream, whether it has voices or not.",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "measureStyle",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "return a <measure-style> Element or None according to the contents of the Stream.\nCurrently, only multiple-rest is supported.",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "moveBackward",
        "type": "Title"
    },
    {
        "text": "byOffset",
        "type": "Title"
    },
    {
        "text": "OffsetQL",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Moves self.offsetInMeasure backward by an OffsetQL, appending the appropriate\n<backup> tag (expressed in divisions) to self.xmlRoot.\n>>> MEX = musicxml.m21ToXml.MeasureExporter()\n>>> len(MEX.xmlRoot)\n0\n>>> MEX.moveBackward(2)\n>>> MEX.dump(MEX.xmlRoot)\n<measure>\n  <backup>\n    <duration>20160</duration>\n  </backup>\n</measure>\n>>> len(MEX.xmlRoot)\n1",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "moveForward",
        "type": "Title"
    },
    {
        "text": "byOffset",
        "type": "Title"
    },
    {
        "text": "OffsetQL",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Moves self.offsetInMeasure forward by an OffsetQL, appending the appropriate\n<forward> tag (expressed in divisions) to self.xmlRoot.\n>>> MEX = musicxml.m21ToXml.MeasureExporter()\n>>> len(MEX.xmlRoot)\n0\n>>> MEX.moveForward(1)\n>>> MEX.dump(MEX.xmlRoot)\n<measure>\n  <forward>\n    <duration>10080</duration>\n  </forward>\n</measure>\n>>> len(MEX.xmlRoot)\n1",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "noChordToXml",
        "type": "Title"
    },
    {
        "text": "cs",
        "type": "Title"
    },
    {
        "text": "NoChord",
        "type": "Title"
    },
    {
        "text": "\u2192 Element",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Convert a NoChord object to an mxHarmony object (or a rest\nif .writeAsChord = True).\nExpected attributes of the NoChord object:\n>>> nc = harmony.NoChord()\n>>> nc.chordKind\n'none'\n\n\n>>> nc.chordKindStr\n'N.C.'\n\n\nOther values may not export:\n>>> nc.chordKindStr = ''\n>>> nc.write()\nTraceback (most recent call last):\nmusic21.musicxml.xmlObjects.MusicXMLExportException:\n     In part (None), measure (1): NoChord object's chordKindStr must be non-empty\n\n\n>>> nc.chordKind = None\n>>> nc.write()\nTraceback (most recent call last):\nmusic21.musicxml.xmlObjects.MusicXMLExportException:\n     In part (None), measure (1): NoChord object's chordKind must be 'none'\n\n\nTo realize the NoChord as a rest:\n>>> nc2 = harmony.NoChord()\n>>> nc2.writeAsChord = True\n>>> MEX = musicxml.m21ToXml.MeasureExporter()\n>>> mxNote = MEX.noChordToXml(nc2)\n>>> MEX.dump(mxNote)\n<note>\n    <rest />\n    <duration>10080</duration>\n    <type>quarter</type>\n</note>",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "noteToNotations",
        "type": "Title"
    },
    {
        "text": "GeneralNote",
        "type": "Title"
    },
    {
        "text": "noteIndexInChord",
        "type": "Title"
    },
    {
        "text": "int",
        "type": "Title"
    },
    {
        "text": "chordParent",
        "type": "Title"
    },
    {
        "text": "Chord | None",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u2192 list[xml.etree.ElementTree.Element]",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Take information from .expressions,\n.articulations, and spanners to\nmake the <notations> tag for a note.",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "noteToXml",
        "type": "Title"
    },
    {
        "text": "GeneralNote",
        "type": "Title"
    },
    {
        "text": "noteIndexInChord",
        "type": "Title"
    },
    {
        "text": "chordParent",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Translate a music21 Note or a Rest into a\nElementTree, note element.\nNote that, some note-attached spanners, such\nas octave shifts, produce direction (and direction types)\nin this method.\n>>> n = note.Note('D#5')\n>>> n.quarterLength = 3\n>>> n.volume.velocityScalar = 0.5\n>>> n.style.color = 'silver'\n\n\n>>> MEX = musicxml.m21ToXml.MeasureExporter()\n>>> len(MEX.xmlRoot)\n0\n>>> mxNote = MEX.noteToXml(n)\n>>> mxNote\n<Element 'note' at 0x10113cb38>\n>>> MEX.dump(mxNote)\n<note color=\"#C0C0C0\" dynamics=\"70.56\">\n  <pitch>\n    <step>D</step>\n    <alter>1</alter>\n    <octave>5</octave>\n  </pitch>\n  <duration>30240</duration>\n  <type>half</type>\n  <dot />\n  <accidental>sharp</accidental>\n  <notehead color=\"#C0C0C0\" parentheses=\"no\">normal</notehead>\n</note>\n>>> len(MEX.xmlRoot)\n1\n\n\n>>> r = note.Rest()\n>>> r.quarterLength = 1/3\n>>> r.duration.tuplets[0].type = 'start'\n>>> mxRest = MEX.noteToXml(r)\n>>> MEX.dump(mxRest)\n<note>\n  <rest />\n  <duration>3360</duration>\n  <type>eighth</type>\n  <time-modification>\n    <actual-notes>3</actual-notes>\n    <normal-notes>2</normal-notes>\n    <normal-type>eighth</normal-type>\n  </time-modification>\n  <notations>\n    <tuplet bracket=\"yes\" number=\"1\" placement=\"above\" type=\"start\">\n      <tuplet-actual>\n        <tuplet-number>3</tuplet-number>\n        <tuplet-type>eighth</tuplet-type>\n      </tuplet-actual>\n      <tuplet-normal>\n        <tuplet-number>2</tuplet-number>\n        <tuplet-type>eighth</tuplet-type>\n      </tuplet-normal>\n    </tuplet>\n  </notations>\n</note>\n>>> len(MEX.xmlRoot)\n2\n\n\n>>> n.notehead = 'diamond'\n>>> n.articulations.append(articulations.Pizzicato())\n>>> mxNote = MEX.noteToXml(n)\n>>> MEX.dump(mxNote)\n<note color=\"#C0C0C0\" dynamics=\"70.56\" pizzicato=\"yes\">\n  ...\n  <notehead color=\"#C0C0C0\" parentheses=\"no\">diamond</notehead>\n</note>\n\n\nNotes with complex durations need to be simplified before coming here\notherwise they raise MusicXMLExportException:\n>>> nComplex = note.Note()\n>>> nComplex.duration.quarterLength = 5.0\n>>> mxComplex = MEX.noteToXml(nComplex)\nTraceback (most recent call last):\nmusic21.musicxml.xmlObjects.MusicXMLExportException:\nCannot convert complex durations to MusicXML.\nTry exporting with makeNotation=True or manually running splitAtDurations()\n\n\nTODO: Test with spanners\u2026",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "noteheadToXml",
        "type": "Title"
    },
    {
        "text": "NotRest",
        "type": "Title"
    },
    {
        "text": "\u2192 Element",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Translate a music21 NotRest object\nsuch as a Note, or Chord into a <notehead> tag.\n>>> n = note.Note('C#4')\n>>> n.notehead = 'diamond'\n>>> MEX = musicxml.m21ToXml.MeasureExporter()\n>>> mxN = MEX.noteheadToXml(n)\n>>> MEX.dump(mxN)\n<notehead parentheses=\"no\">diamond</notehead>\n\n\n>>> n1 = note.Note('c3')\n>>> n1.style.color = 'red'\n>>> n1.notehead = 'diamond'\n>>> n1.noteheadParenthesis = True\n>>> n1.noteheadFill = False\n>>> mxN = MEX.noteheadToXml(n1)\n>>> MEX.dump(mxN)\n<notehead color=\"#FF0000\" filled=\"no\" parentheses=\"yes\">diamond</notehead>\n\n\n>>> n1 = note.Note('c3')\n>>> n1.style.color = 'red'\n>>> n1.notehead = 'diamond'\n>>> n1.noteheadParenthesis = True\n>>> n1.noteheadFill = False\n>>> mxN = MEX.noteheadToXml(n1)\n>>> MEX.dump(mxN)\n<notehead color=\"#FF0000\" filled=\"no\" parentheses=\"yes\">diamond</notehead>",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "objectAttachedSpannersToNotations",
        "type": "Title"
    },
    {
        "text": "obj",
        "type": "Title"
    },
    {
        "text": "Music21Object",
        "type": "Title"
    },
    {
        "text": "noteIndexInChord",
        "type": "Title"
    },
    {
        "text": "int",
        "type": "Title"
    },
    {
        "text": "objectSpannerBundle",
        "type": "Title"
    },
    {
        "text": "SpannerBundle | None",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u2192 list[xml.etree.ElementTree.Element]",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "return a list of <notations> from spanners related to the object that should appear\nin the notations tag (slurs, slides, etc.)\n>>> n0 = note.Note('C')\n>>> n1 = note.Note('D')\n>>> trem = expressions.TremoloSpanner([n0, n1])\n>>> m = stream.Measure()\n>>> m.insert(0, trem)\n>>> m.append(n0)\n>>> m.append(n1)\n>>> mex = musicxml.m21ToXml.MeasureExporter(m)\n>>> out = mex.objectAttachedSpannersToNotations(n0, objectSpannerBundle=m.spannerBundle)\n>>> out\n[<Element 'ornaments' at 0x1114d9408>]\n>>> mex.dump(out[0])\n<ornaments>\n  <tremolo type=\"start\">3</tremolo>\n</ornaments>\n\n\n>>> out = mex.objectAttachedSpannersToNotations(n1, objectSpannerBundle=m.spannerBundle)\n>>> mex.dump(out[0])\n<ornaments>\n  <tremolo type=\"stop\">3</tremolo>\n</ornaments>",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "objectAttachedSpannersToTechnicals",
        "type": "Title"
    },
    {
        "text": "obj",
        "type": "Title"
    },
    {
        "text": "objectSpannerBundle",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "return a list of <technical> from spanners related to the object that should appear\nin the technical tag of the notations tag (hammer-on, pull-off etc.)\n>>> n0 = note.Note('C')\n>>> n1 = note.Note('D')\n>>> n2 = note.Note('F')\n>>> n3 = note.Note('E')\n>>> hammerOn01 = articulations.HammerOn([n0, n1])\n>>> pullOff23 = articulations.PullOff([n2, n3])\n>>> m = stream.Measure()\n>>> m.insert(0, hammerOn01)\n>>> m.insert(0, pullOff23)\n>>> m.append(n0)\n>>> m.append(n1)\n>>> m.append(n2)\n>>> m.append(n3)\n>>> mex = musicxml.m21ToXml.MeasureExporter(m)\n>>> out = mex.objectAttachedSpannersToTechnicals(n0, m.spannerBundle)\n>>> out\n[<Element 'hammer-on' at 0x102857f40>]\n>>> mex.dump(out[0])\n<hammer-on number=\"1\" type=\"start\">H</hammer-on>\n>>> out = mex.objectAttachedSpannersToTechnicals(n3, m.spannerBundle)\n>>> mex.dump(out[0])\n<pull-off number=\"1\" type=\"stop\" />",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "ornamentToMxAccidentalMarks",
        "type": "Title"
    },
    {
        "text": "ornamentObj",
        "type": "Title"
    },
    {
        "text": "Ornament",
        "type": "Title"
    },
    {
        "text": "\u2192 list[xml.etree.ElementTree.Element]",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "parse",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "main parse call.\ndeals with transposing, repeat brackets, setting measureNumber and width,\nthe first mxPrint, the first <attributes> tag, the left barline, parsing all internal\nelements, setting the right barline, then returns the root <measure> tag.",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "parseFlatElements",
        "type": "Title"
    },
    {
        "text": "Measure | Voice",
        "type": "Title"
    },
    {
        "text": "backupAfterwards",
        "type": "Title"
    },
    {
        "text": "bool",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "\u2192 None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Deals with parsing all the elements in .elements, assuming that .elements is flat.\nm here can be a Measure or Voice, but flat\u2026\nIf m is a \u0098Voice' class, we use the .id element to set self.currentVoiceId and then\nsend a backup tag to go back to the beginning of the measure.\nNote that if the .id is high enough to be an id(x) memory location, then a small\nvoice number is used instead.",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "parseOneElement",
        "type": "Title"
    },
    {
        "text": "obj",
        "type": "Title"
    },
    {
        "text": "appendSpanners",
        "type": "Title"
    },
    {
        "text": "AppendSpanners",
        "type": "Title"
    },
    {
        "text": "AppendSpanners.NORMAL",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "parse one element completely and add it to xmlRoot, updating\noffsetInMeasure, etc.",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "pitchToXml",
        "type": "Title"
    },
    {
        "text": "Pitch",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Convert a Pitch to xml.\nDoes not create the <accidental> tag.\n>>> p = pitch.Pitch('D#5')\n>>> MEX = musicxml.m21ToXml.MeasureExporter()\n>>> mxPitch = MEX.pitchToXml(p)\n>>> MEX.dump(mxPitch)\n<pitch>\n  <step>D</step>\n  <alter>1</alter>\n  <octave>5</octave>\n</pitch>",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "placeInDirection",
        "type": "Title"
    },
    {
        "text": "mxObj",
        "type": "Title"
    },
    {
        "text": "Element",
        "type": "Title"
    },
    {
        "text": "m21Obj",
        "type": "Title"
    },
    {
        "text": "Music21Object | None",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "setSound",
        "type": "Title"
    },
    {
        "text": "bool",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "\u2192 Element",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Places the mxObj <element> inside <direction><direction-type>\nand sets <offset> if needed.\n\nChanged in v8: added setSound keyword (see setOffsetOptional()).",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "rehearsalMarkToXml",
        "type": "Title"
    },
    {
        "text": "rm",
        "type": "Title"
    },
    {
        "text": "RehearsalMark",
        "type": "Title"
    },
    {
        "text": "\u2192 Element",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Convert a RehearsalMark object to a MusicXML <direction> tag with a <rehearsal> tag\ninside it.\n>>> rm = expressions.RehearsalMark('II')\n>>> rm.style.enclosure = 'square'\n>>> MEX = musicxml.m21ToXml.MeasureExporter()\n>>> mxRehearsal = MEX.rehearsalMarkToXml(rm)\n>>> MEX.dump(mxRehearsal)\n<direction>\n  <direction-type>\n    <rehearsal enclosure=\"square\" halign=\"center\" valign=\"middle\">II</rehearsal>\n    </direction-type>\n  </direction>",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "relatedSpanners",
        "type": "Title"
    },
    {
        "text": "target",
        "type": "Title"
    },
    {
        "text": "Music21Object",
        "type": "Title"
    },
    {
        "text": "\u2192 tuple[Sequence[xml.etree.ElementTree.Element], Sequence[xml.etree.ElementTree.Element]]",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "return two lists or empty tuples:\n(1) spanners related to the object that should appear before the object\nto the <measure> tag. (2) spanners related to the object that should appear after the\nobject in the measure tag.",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "repeatToXml",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "returns a <repeat> tag from a barline object.\n>>> b = bar.Repeat(direction='end')\n>>> MEX = musicxml.m21ToXml.MeasureExporter()\n>>> mxRepeat = MEX.repeatToXml(b)\n>>> MEX.dump(mxRepeat)\n<repeat direction=\"backward\" />\n\n\n>>> b.times = 3\n>>> mxRepeat = MEX.repeatToXml(b)\n>>> MEX.dump(mxRepeat)\n<repeat direction=\"backward\" times=\"3\" />",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "restToXml",
        "type": "Title"
    },
    {
        "text": "Rest",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Convert a Rest object to a <note> with a <rest> tag underneath it.\n>>> MEX = musicxml.m21ToXml.MeasureExporter()\n>>> r = note.Rest(quarterLength=2.0)\n\n\nGive the rest some context:\n>>> m = stream.Measure()\n>>> m.timeSignature = meter.TimeSignature('4/4')\n>>> m.append(r)\n>>> mxNoteRest = MEX.restToXml(r)\n>>> MEX.dump(mxNoteRest)\n<note>\n  <rest />\n  <duration>20160</duration>\n  <type>half</type>\n</note>\n\n\nNow it is a full measure:\n>>> m.timeSignature = meter.TimeSignature('2/4')\n>>> mxNoteRest = MEX.restToXml(r)\n>>> MEX.dump(mxNoteRest)\n<note>\n  <rest measure=\"yes\" />\n  <duration>20160</duration>\n</note>\n\n\nUnless we specify that it should not be converted to a full measure:\n>>> r.fullMeasure = False\n>>> mxNoteRest = MEX.restToXml(r)\n>>> MEX.dump(mxNoteRest)\n<note>\n  <rest />\n  <duration>20160</duration>\n  <type>half</type>\n</note>\n\n\nWith True or \u009calways\u009d it will be converted to full measure even if\nit does not match:\n>>> m.timeSignature = meter.TimeSignature('4/4')\n>>> r.duration.dots = 1\n>>> r.fullMeasure = True\n>>> mxNoteRest = MEX.restToXml(r)\n>>> MEX.dump(mxNoteRest)\n<note>\n  <rest measure=\"yes\" />\n  <duration>30240</duration>\n</note>\n\n\nNote that if a measure has paddingLeft/paddingRight (such as a pickup)\nthen a fullMeasure duration might not match the TimeSignature duration.\nThe display-step and display-octave are set from a Rest's stepShift:\n>>> r = note.Rest()\n>>> r.stepShift = 1\n>>> mxNoteRest = MEX.restToXml(r)\n>>> MEX.dump(mxNoteRest)\n<note>\n  <rest>\n    <display-step>C</display-step>\n    <display-octave>5</display-octave>\n  </rest>\n  <duration>10080</duration>\n  <type>quarter</type>\n</note>\n\n\nClef context matters:\n>>> m = stream.Measure()\n>>> m.clef = clef.BassClef()\n>>> m.append(r)\n>>> mxNoteRest = MEX.restToXml(r)\n>>> MEX.dump(mxNoteRest)\n<note>\n  <rest>\n    <display-step>E</display-step>\n    <display-octave>3</display-octave>\n  </rest>\n  <duration>10080</duration>\n  <type>quarter</type>\n</note>",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "romanNumeralToXml",
        "type": "Title"
    },
    {
        "text": "rn",
        "type": "Title"
    },
    {
        "text": "roman.RomanNumeral",
        "type": "Title"
    },
    {
        "text": "\u2192 Element | list[Element]",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Convert a RomanNumeral object to either a chord (if .writeAsChord is True)\nor a Harmony XML Element.\n>>> rnI = roman.RomanNumeral('I', 'C')\n>>> MEX = musicxml.m21ToXml.MeasureExporter()\n>>> MEX.currentDivisions = 10\n\n\n>>> listMxChords = MEX.romanNumeralToXml(rnI)\n>>> len(listMxChords)\n3\n>>> MEX.dump(listMxChords[1])\n<note>\n  <chord />\n  <pitch>\n    <step>E</step>\n    <octave>4</octave>\n  </pitch>\n  <duration>10</duration>\n  <type>quarter</type>\n</note>\n\n\nIf writeAsChord is False, we create a MusicXML 4.0 <numeral> tag.\nThis does not work in the current version of MuseScore (which only\nsupports MusicXML 3.1) but outputs decently well in Finale.\n>>> rnI.writeAsChord = False\n>>> mxHarmonyFromRN = MEX.romanNumeralToXml(rnI)\n>>> MEX.dump(mxHarmonyFromRN)\n<harmony>\n  <numeral>\n    <numeral-root text=\"I\">1</numeral-root>\n    <numeral-key print-object=\"no\">\n      <numeral-fifths>0</numeral-fifths>\n      <numeral-mode>major</numeral-mode>\n    </numeral-key>\n  </numeral>\n  <kind>major</kind>\n</harmony>\n\n\n>>> complexRn = roman.RomanNumeral('#iio65', 'e-')\n>>> complexRn.followsKeyChange = True\n>>> complexRn.writeAsChord = False\n>>> mxHarmonyFromRN = MEX.romanNumeralToXml(complexRn)\n>>> MEX.dump(mxHarmonyFromRN)\n<harmony>\n  <numeral>\n    <numeral-root text=\"#iio65\">2</numeral-root>\n    <numeral-alter location=\"left\">1.0</numeral-alter>\n    <numeral-key>\n      <numeral-fifths>-6</numeral-fifths>\n      <numeral-mode>minor</numeral-mode>\n    </numeral-key>\n  </numeral>\n  <kind>diminished-seventh</kind>\n  <inversion>1</inversion>\n</harmony>\n\n\n>>> maj6 = roman.RomanNumeral('VI7', 'd')\n>>> maj6.writeAsChord = False\n>>> mxHarmonyFromRN = MEX.romanNumeralToXml(maj6)\n>>> MEX.dump(mxHarmonyFromRN)\n<harmony>\n  <numeral>\n    <numeral-root text=\"VI7\">6</numeral-root>\n    <numeral-key print-object=\"no\">\n      <numeral-fifths>-1</numeral-fifths>\n      <numeral-mode>natural minor</numeral-mode>\n    </numeral-key>\n  </numeral>\n  <kind>major-seventh</kind>\n</harmony>\n\n\n>>> min6 = roman.RomanNumeral('vi', 'd')\n>>> min6.writeAsChord = False\n>>> mxHarmonyFromRN = MEX.romanNumeralToXml(min6)\n>>> mxHarmonyFromRN.find('.//numeral-mode').text\n'melodic minor'\n\n\n>>> dim7 = roman.RomanNumeral('vii\u00c3\u00b865', 'd')\n>>> dim7.writeAsChord = False\n>>> mxHarmonyFromRN = MEX.romanNumeralToXml(dim7)\n>>> mxHarmonyFromRN.find('.//numeral-mode').text\n'harmonic minor'\n>>> mxHarmonyFromRN.find('kind').text\n'half-diminished'\n\n\n>>> maj7 = roman.RomanNumeral('VII64', 'd')\n>>> maj7.writeAsChord = False\n>>> mxHarmonyFromRN = MEX.romanNumeralToXml(maj7)\n>>> mxHarmonyFromRN.find('.//numeral-mode').text\n'natural minor'",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "segnoToXml",
        "type": "Title"
    },
    {
        "text": "segno",
        "type": "Title"
    },
    {
        "text": "Segno",
        "type": "Title"
    },
    {
        "text": "\u2192 Element",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "returns a segno inside a direction-type inside a direction.\nappends to score\n>>> s = repeat.Segno()\n>>> MEX = musicxml.m21ToXml.MeasureExporter()\n>>> mxSegnoDir = MEX.segnoToXml(s)\n>>> MEX.dump(mxSegnoDir)\n<direction>\n  <direction-type>\n    <segno default-y=\"20\" />\n  </direction-type>\n</direction>\n\n\n>>> s.id = 'segno0'\n>>> s.style.alignHorizontal = 'left'\n>>> MEX = musicxml.m21ToXml.MeasureExporter()\n>>> mxSegnoDir = MEX.segnoToXml(s)\n>>> MEX.dump(mxSegnoDir)\n<direction>\n  <direction-type>\n    <segno default-y=\"20\" halign=\"left\" id=\"segno0\" />\n  </direction-type>\n</direction>",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "setBarline",
        "type": "Title"
    },
    {
        "text": "barline",
        "type": "Title"
    },
    {
        "text": "position",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "sets either a left or right barline from a\nbar.Barline() object or bar.Repeat() object",
        "type": "ListItem"
    },
    {
        "text": "static",
        "type": "Title"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "setHarmonic",
        "type": "Title"
    },
    {
        "text": "mxh",
        "type": "Title"
    },
    {
        "text": "Element",
        "type": "Title"
    },
    {
        "text": "harm",
        "type": "Title"
    },
    {
        "text": "StringHarmonic",
        "type": "Title"
    },
    {
        "text": "\u2192 None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Sets the artificial or natural tag (or no tag) and\nzero or one of base-pitch, sounding-pitch, touching-pitch\nCalled from articulationToXmlTechnical\n>>> MEXClass = musicxml.m21ToXml.MeasureExporter\n\n\n>>> a = articulations.StringHarmonic()\n>>> a.harmonicType = 'artificial'\n>>> a.pitchType = 'sounding'\n\n\n>>> from xml.etree.ElementTree import Element\n>>> mxh = Element('harmonic')\n\n\n>>> MEXClass.setHarmonic(mxh, a)\n>>> MEXClass.dump(mxh)\n<harmonic>\n  <artificial />\n  <sounding-pitch />\n</harmonic>\n\n\nHarmonic is probably too general for most uses,\nbut if you use it, you get a harmonic tag with no details:\n>>> b = articulations.Harmonic()\n>>> mxh2 = Element('harmonic')\n>>> MEXClass.setHarmonic(mxh2, b)\n>>> MEXClass.dump(mxh2)\n<harmonic />",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "setLeftBarline",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Calls self.setBarline for the left side if the measure has a .leftBarline set.",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "setLineStyle",
        "type": "Title"
    },
    {
        "text": "mxObject",
        "type": "Title"
    },
    {
        "text": "m21Object",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Sets four additional elements for line elements, conforms to entity\n%line-shape, %line-type, %dashed-formatting (dash-length and space-length)",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "setMxAttributes",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "sets the attributes (x=y) for a measure,\nthat is, number, implicit, and layoutWidth\nDoes not create the <attributes> tag. That's elsewhere\u2026",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "setMxAttributesObjectForStartOfMeasure",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "creates an <attributes> tag at the start of the measure.\nWe create one for each measure unless it is identical to self.parent.mxAttributes",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "setMxPrint",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Creates a <print> element and appends it to root, if one is needed.",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "setNoteInstrument",
        "type": "Title"
    },
    {
        "text": "NotRest",
        "type": "Title"
    },
    {
        "text": "mxNote",
        "type": "Title"
    },
    {
        "text": "Element",
        "type": "Title"
    },
    {
        "text": "chordParent",
        "type": "Title"
    },
    {
        "text": "Chord | None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Insert <instrument> tags if necessary, that is, when there is more than one\ninstrument anywhere in the same musicxml <part>.",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "setOffsetOptional",
        "type": "Title"
    },
    {
        "text": "m21Obj",
        "type": "Title"
    },
    {
        "text": "Music21Object",
        "type": "Title"
    },
    {
        "text": "mxObj",
        "type": "Title"
    },
    {
        "text": "Element | None",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "setSound",
        "type": "Title"
    },
    {
        "text": "bool",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "\u2192 Element | None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "If this object has an offset different from self.offsetInMeasure,\nthen create and return an offset Element.\nIf mxObj is not None then the offset element will be appended to it.",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "setRbSpanners",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Makes a set of spanners from repeat brackets",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "setRightBarline",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Calls self.setBarline for the right side if the measure has a .rightBarline set.",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "setTranspose",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Set the transposition interval based on whether the active\ninstrument for this period has a transposition object.\nStores in self.transpositionInterval.  Returns None",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "staffLayoutToXmlPrint",
        "type": "Title"
    },
    {
        "text": "staffLayout",
        "type": "Title"
    },
    {
        "text": "mxPrint",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "staffLayoutToXmlStaffDetails",
        "type": "Title"
    },
    {
        "text": "staffLayout",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Convert a StaffLayout object to a\n<staff-details> element.\n>>> MEX = musicxml.m21ToXml.MeasureExporter()\n>>> sl = layout.StaffLayout()\n>>> sl.staffLines = 3  # tenor drums?\n>>> sl.staffType = stream.enums.StaffType.CUE\n>>> sl.hidden = True\n>>> mxDetails = MEX.staffLayoutToXmlStaffDetails(sl)\n>>> MEX.dump(mxDetails)\n<staff-details print-object=\"no\">\n      <staff-type>cue</staff-type>\n      <staff-lines>3</staff-lines>\n</staff-details>",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "tempoIndicationToXml",
        "type": "Title"
    },
    {
        "text": "ti",
        "type": "Title"
    },
    {
        "text": "TempoIndication",
        "type": "Title"
    },
    {
        "text": "\u2192 Element",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "returns a <direction> tag for a single tempo indication.\nnote that TWO direction tags may be added to xmlroot, the second one\nas a textExpression\u2026. but only the first will be returned.\n>>> mm = tempo.MetronomeMark('slow', 40, note.Note(type='half'))\n>>> mm.style.justify = 'left'\n\n\n>>> MEX = musicxml.m21ToXml.MeasureExporter()\n>>> mxDirection = MEX.tempoIndicationToXml(mm)\n>>> MEX.dump(mxDirection)\n<direction>\n  <direction-type>\n    <metronome parentheses=\"no\">\n      <beat-unit>half</beat-unit>\n      <per-minute>40</per-minute>\n    </metronome>\n  </direction-type>\n  <sound tempo=\"80\" />\n</direction>\n\n\nIn this case, two directions were added to xmlRoot.  Here is the other one:\n>>> MEX.dump(MEX.xmlRoot.findall('direction')[1])\n<direction>\n  <direction-type>\n    <words default-y=\"45\" enclosure=\"none\" font-weight=\"bold\"\n        justify=\"left\">slow</words>\n  </direction-type>\n</direction>\n\n\n>>> mm = tempo.MetronomeMark('slow', 40, duration.Duration(quarterLength=1.5))\n>>> mxDirection = MEX.tempoIndicationToXml(mm)\n>>> MEX.dump(mxDirection)\n<direction>\n  <direction-type>\n    <metronome parentheses=\"no\">\n      <beat-unit>quarter</beat-unit>\n      <beat-unit-dot />\n      <per-minute>40</per-minute>\n    </metronome>\n  </direction-type>\n  <sound tempo=\"60\" />\n</direction>\n\n\n>>> mmod1 = tempo.MetricModulation()\n>>> mmod1.oldReferent = 0.75  # quarterLength\n>>> mmod1.newReferent = 'quarter'  # type\n>>> mxDirection = MEX.tempoIndicationToXml(mmod1)\n>>> MEX.dump(mxDirection)\n<direction>\n  <direction-type>\n    <metronome parentheses=\"no\">\n      <beat-unit>eighth</beat-unit>\n      <beat-unit-dot />\n      <beat-unit>quarter</beat-unit>\n    </metronome>\n  </direction-type>\n</direction>\n\n\n>>> mmod1.newReferent = 'longa'  # music21 type w/ different musicxml name...\n>>> mxDirection = MEX.tempoIndicationToXml(mmod1)\n>>> MEX.dump(mxDirection)\n<direction>\n  <direction-type>\n    <metronome parentheses=\"no\">\n      <beat-unit>eighth</beat-unit>\n      <beat-unit-dot />\n      <beat-unit>long</beat-unit>\n    </metronome>\n  </direction-type>\n</direction>\n\n\nThis is the case where only a sound tag is added and no metronome mark\n>>> mm = tempo.MetronomeMark()\n>>> mm.numberSounding = 60\n\n\n>>> MEX = musicxml.m21ToXml.MeasureExporter()\n>>> mxDirection = MEX.tempoIndicationToXml(mm)\n>>> MEX.dump(mxDirection)\n<direction>\n  <direction-type>\n    <words />\n  </direction-type>\n  <sound tempo=\"60\" />\n</direction>\n\n\nThis is the case of a TempoText.\n>>> tt = tempo.TempoText('Andante')\n>>> mxDirection = MEX.tempoIndicationToXml(tt)\n>>> MEX.dump(mxDirection)\n<direction>\n  <direction-type>\n    <words default-y=\"45\" enclosure=\"none\" font-weight=\"bold\">Andante</words>\n  </direction-type>\n</direction>",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "textExpressionToXml",
        "type": "Title"
    },
    {
        "text": "teOrRe",
        "type": "Title"
    },
    {
        "text": "TextExpression | RepeatExpression",
        "type": "Title"
    },
    {
        "text": "\u2192 Element",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Convert a TextExpression or RepeatExpression to a MusicXML mxDirection type.\nreturns a musicxml.mxObjects.Direction object",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "tieToXmlTie",
        "type": "Title"
    },
    {
        "text": "m21Tie",
        "type": "Title"
    },
    {
        "text": "Tie",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "returns a list of ties from a Tie object.\nA \u0098continue' tie requires two <tie> tags to represent.\n>>> tieObj = tie.Tie('continue')\n>>> MEX = musicxml.m21ToXml.MeasureExporter()\n>>> tieList = MEX.tieToXmlTie(tieObj)\n>>> for mxT in tieList:\n...     MEX.dump(mxT)\n<tie type=\"stop\" />\n<tie type=\"start\" />",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "tieToXmlTied",
        "type": "NarrativeText"
    },
    {
        "text": "m21Tie",
        "type": "Title"
    },
    {
        "text": "Tie",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "In musicxml, a tie is represented in sound\nby the tie tag (near the pitch object), and\nthe <tied> tag in notations.  This\ncreates the <tied> tag.\nReturns a list since a music21 \u009ccontinue\u009d tie type needs two tags\nin musicxml.  List may be empty if tie.style == \u009chidden\u009d\n>>> tieObj = tie.Tie('continue')\n>>> tieObj.id = 'tied1'\n\n\n>>> MEX = musicxml.m21ToXml.MeasureExporter()\n>>> tiedList = MEX.tieToXmlTied(tieObj)\n>>> for mxT in tiedList:\n...     MEX.dump(mxT)\n<tied id=\"tied1\" type=\"stop\" />\n<tied type=\"start\" />\n\n\n>>> tieObj.style = 'hidden'\n>>> tiedList = MEX.tieToXmlTied(tieObj)\n>>> len(tiedList)\n0",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "timeSignatureToXml",
        "type": "Title"
    },
    {
        "text": "ts",
        "type": "Title"
    },
    {
        "text": "TimeSignature | SenzaMisuraTimeSignature",
        "type": "NarrativeText"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Returns a single <time> tag from a meter.TimeSignature object.\nCompound meters are represented as multiple pairs of beat\nand beat-type elements\n>>> MEX = musicxml.m21ToXml.MeasureExporter()\n>>> a = meter.TimeSignature('3/4')\n>>> b = MEX.timeSignatureToXml(a)\n>>> MEX.dump(b)\n<time>\n  <beats>3</beats>\n  <beat-type>4</beat-type>\n</time>\n\n\n>>> a = meter.TimeSignature('3/4+2/4')\n>>> b = MEX.timeSignatureToXml(a)\n>>> MEX.dump(b)\n<time>\n  <beats>3</beats>\n  <beat-type>4</beat-type>\n  <beats>2</beats>\n  <beat-type>4</beat-type>\n</time>\n\n\n>>> a.setDisplay('5/4')\n>>> b = MEX.timeSignatureToXml(a)\n>>> MEX.dump(b)\n<time>\n  <beats>5</beats>\n  <beat-type>4</beat-type>\n</time>\n\n\n>>> a = meter.TimeSignature('4/4')\n>>> a.symbol = 'common'\n>>> b = MEX.timeSignatureToXml(a)\n>>> MEX.dump(b)\n<time symbol=\"common\">\n  <beats>4</beats>\n  <beat-type>4</beat-type>\n</time>\n\n\n>>> a.symbol = ''\n>>> a.symbolizeDenominator = True\n>>> b = MEX.timeSignatureToXml(a)\n>>> MEX.dump(b)\n<time symbol=\"note\">\n  <beats>4</beats>\n  <beat-type>4</beat-type>\n</time>\n\n\n>>> sm = meter.SenzaMisuraTimeSignature('free')\n>>> b = MEX.timeSignatureToXml(sm)\n>>> MEX.dump(b)\n<time>\n  <senza-misura>free</senza-misura>\n</time>",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "tupletToTimeModification",
        "type": "Title"
    },
    {
        "text": "tup",
        "type": "Title"
    },
    {
        "text": "\u2192 Element",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": ">>> tup = duration.Tuplet(11, 8)\n>>> MEX = musicxml.m21ToXml.MeasureExporter()\n>>> mxTimeMod = MEX.tupletToTimeModification(tup)\n>>> MEX.dump(mxTimeMod)\n<time-modification>\n  <actual-notes>11</actual-notes>\n  <normal-notes>8</normal-notes>\n</time-modification>\n\n\n>>> tup.setDurationType('eighth', dots=2)\n>>> mxTimeMod = MEX.tupletToTimeModification(tup)\n>>> MEX.dump(mxTimeMod)\n<time-modification>\n  <actual-notes>11</actual-notes>\n  <normal-notes>8</normal-notes>\n  <normal-type>eighth</normal-type>\n  <normal-dot />\n  <normal-dot />\n</time-modification>",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "tupletToXmlTuplet",
        "type": "Title"
    },
    {
        "text": "tuplet",
        "type": "Title"
    },
    {
        "text": "tupletIndex",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "In musicxml, a tuplet is represented by\na timeModification and visually by the\n<notations><tuplet> tag.  This method\ncreates the latter.\nReturns a list of them because a\nstartStop type tuplet needs two tuplet\nbrackets.\n\nTODO: make sure something happens ifmakeTupletBrackets is not set.\n\n\n>>> tup = duration.Tuplet(11, 8)\n>>> tup.type = 'start'\n>>> MEX = musicxml.m21ToXml.MeasureExporter()\n>>> mxTup = MEX.tupletToXmlTuplet(tup)\n>>> len(mxTup)\n1\n>>> MEX.dump(mxTup[0])\n<tuplet bracket=\"yes\" number=\"1\" placement=\"above\" type=\"start\">\n  <tuplet-actual>\n    <tuplet-number>11</tuplet-number>\n  </tuplet-actual>\n  <tuplet-normal>\n    <tuplet-number>8</tuplet-number>\n  </tuplet-normal>\n</tuplet>\n\n\n>>> tup.tupletActualShow = 'both'\n>>> tup.tupletNormalShow = 'type'\n>>> mxTup = MEX.tupletToXmlTuplet(tup)\n>>> MEX.dump(mxTup[0])\n<tuplet bracket=\"yes\" number=\"1\" placement=\"above\"\n    show-number=\"actual\" show-type=\"both\" type=\"start\">...</tuplet>",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "unpitchedToXml",
        "type": "Title"
    },
    {
        "text": "up",
        "type": "Title"
    },
    {
        "text": "Unpitched",
        "type": "Title"
    },
    {
        "text": "noteIndexInChord",
        "type": "Title"
    },
    {
        "text": "int",
        "type": "Title"
    },
    {
        "text": "chordParent",
        "type": "Title"
    },
    {
        "text": "ChordBase | None",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u2192 Element",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Convert an Unpitched to a <note>\nwith an <unpitched> subelement.\n>>> up = note.Unpitched(displayName='D5')\n>>> MEX = musicxml.m21ToXml.MeasureExporter()\n>>> mxUnpitched = MEX.unpitchedToXml(up)\n>>> MEX.dump(mxUnpitched)\n<note>\n  <unpitched>\n    <display-step>D</display-step>\n    <display-octave>5</display-octave>\n  </unpitched>\n  <duration>10080</duration>\n  <type>quarter</type>\n</note>\n\n\n>>> graceUp = up.getGrace()\n>>> mxUnpitched = MEX.unpitchedToXml(graceUp)\n>>> MEX.dump(mxUnpitched)\n<note>\n  <grace slash=\"yes\" />\n  <unpitched>\n    <display-step>D</display-step>\n    <display-octave>5</display-octave>\n  </unpitched>\n  <type>quarter</type>\n</note>",
        "type": "ListItem"
    },
    {
        "text": "MeasureExporter.",
        "type": "Title"
    },
    {
        "text": "wrapObjectInAttributes",
        "type": "Title"
    },
    {
        "text": "objectToWrap",
        "type": "Title"
    },
    {
        "text": "Music21Object",
        "type": "Title"
    },
    {
        "text": "methodToMx",
        "type": "Title"
    },
    {
        "text": "Callable",
        "type": "Title"
    },
    {
        "text": "Any",
        "type": "Title"
    },
    {
        "text": "Element",
        "type": "Title"
    },
    {
        "text": "\u2192 Element | None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "given a Clef, KeySignature, or TimeSignature which is in .elements and not m.clef,\netc. insert it in self.xmlRoot as\npart of the current mxAttributes using methodToMx as a wrapper function.\n(or insert into a new mxAttributes if Clef/KeySignature/etc. is not at the beginning\nof the measure and not at the same point as an existing mxAttributes)\n>>> MEX = musicxml.m21ToXml.MeasureExporter()\n>>> MEX.offsetInMeasure = 3.0\n>>> cl = clef.BassClef()\n>>> methodToMx = MEX.clefToXml\n>>> mxAttributes = MEX.wrapObjectInAttributes(cl, methodToMx)\n>>> MEX.dump(mxAttributes)\n<attributes>\n  <clef>\n    <sign>F</sign>\n    <line>4</line>\n  </clef>\n</attributes>\n\n\nAlso puts it in MEX.xmlRoot.\nIf offsetInMeasure is 0.0 then nothing is done or returned:\n>>> MEX.offsetInMeasure = 0.0\n>>> nothing = MEX.wrapObjectInAttributes(cl, methodToMx)\n>>> nothing is None\nTrue",
        "type": "ListItem"
    },
    {
        "text": "Methods inherited from XMLExporterBase:",
        "type": "NarrativeText"
    },
    {
        "text": "accidentalToMx() accidentalToMxAccidentalMark() addDividerComment() asBytes() dump() pageLayoutToXmlPageLayout() pageLayoutToXmlPrint() setColor() setEditorial() setFont() setPosition() setPrintObject() setPrintStyle() setPrintStyleAlign() setStyleAttributes() setTextFormatting() staffLayoutToXmlStaffLayout() systemLayoutToXmlPrint() systemLayoutToXmlSystemLayout() xmlHeader()",
        "type": "Table"
    },
    {
        "text": "PartExporter\u00c2\u00b6",
        "type": "Title"
    },
    {
        "text": "class",
        "type": "Title"
    },
    {
        "text": "music21.musicxml.m21ToXml.",
        "type": "Title"
    },
    {
        "text": "PartExporter",
        "type": "Title"
    },
    {
        "text": "partObj",
        "type": "Title"
    },
    {
        "text": "Part",
        "type": "Title"
    },
    {
        "text": "Score",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "parent",
        "type": "Title"
    },
    {
        "text": "ScoreExporter | None",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Object to convert one Part stream to a <part> tag on .parse()",
        "type": "ListItem"
    },
    {
        "text": "PartExporter bases",
        "type": "Title"
    },
    {
        "text": "XMLExporterBase",
        "type": "ListItem"
    },
    {
        "text": "PartExporter methods",
        "type": "Title"
    },
    {
        "text": "PartExporter.",
        "type": "Title"
    },
    {
        "text": "fixupNotationFlat",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Runs makeNotation on a flatStream, such as one lacking measures.",
        "type": "ListItem"
    },
    {
        "text": "PartExporter.",
        "type": "Title"
    },
    {
        "text": "fixupNotationMeasured",
        "type": "NarrativeText"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Checks to see if there are any attributes in the part stream and moves\nthem into the first measure if necessary.\nChecks if makeAccidentals is run, and haveBeamsBeenMade is done, and\ntuplets have been made.\n\nChanged in v7: no longer accepts measureStream argument.",
        "type": "ListItem"
    },
    {
        "text": "PartExporter.",
        "type": "Title"
    },
    {
        "text": "getXmlScorePart",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "make a <score-part> from a music21 Part object and a parsed mxPart (<part>) element.\ncontains details about instruments, etc.\ncalled directly by the ScoreExporter as a late part of the processing.",
        "type": "ListItem"
    },
    {
        "text": "PartExporter.",
        "type": "Title"
    },
    {
        "text": "instrumentSetup",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Sets self.instrumentStream and self.firstInstrumentObject for the stream,\nchecks for a unique midiChannel and then blocks it off from future use.\n>>> p = converter.parse('tinyNotation: 4/4 c1 d1 e1')\n>>> p.getElementsByClass(stream.Measure)[0].insert(0, instrument.Clarinet())\n>>> p.getElementsByClass(stream.Measure)[1].insert(0, instrument.BassClarinet())\n>>> PEX = musicxml.m21ToXml.PartExporter(p)\n>>> PEX.instrumentStream is None\nTrue\n>>> PEX.firstInstrumentObject is None\nTrue\n>>> PEX.instrumentSetup()\n>>> PEX.instrumentStream\n<music21.stream.Part 0x10ae02780>\n\n\nThe \u009cP\u009d signifies that it is the main instrument associated with a Part.\n>>> PEX.instrumentStream.show('text')\n{0.0} <music21.instrument.Clarinet 'P...: Clarinet'>\n{4.0} <music21.instrument.BassClarinet 'Bass clarinet'>",
        "type": "ListItem"
    },
    {
        "text": "PartExporter.",
        "type": "Title"
    },
    {
        "text": "instrumentToXmlMidiInstrument",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Convert an instrument object to a <midi-instrument> tag and return the element\n>>> i = instrument.Clarinet()\n>>> i.instrumentId = 'clarinet1'\n>>> i.midiChannel = 4\n>>> PEX = musicxml.m21ToXml.PartExporter()\n>>> mxMidiInstrument = PEX.instrumentToXmlMidiInstrument(i)\n>>> PEX.dump(mxMidiInstrument)\n<midi-instrument id=\"clarinet1\">\n  <midi-channel>5</midi-channel>\n  <midi-program>72</midi-program>\n</midi-instrument>\n\n\n>>> m = instrument.Maracas()\n>>> m.instrumentId = 'my maracas'\n>>> m.midiChannel  # 0-indexed\n9\n>>> m.percMapPitch\n70\n>>> PEX = musicxml.m21ToXml.PartExporter()\n>>> mxMidiInstrument = PEX.instrumentToXmlMidiInstrument(m)\n>>> PEX.dump(mxMidiInstrument)  # 1-indexed in MusicXML\n<midi-instrument id=\"my maracas\">\n  <midi-channel>10</midi-channel>\n  <midi-unpitched>71</midi-unpitched>\n</midi-instrument>",
        "type": "ListItem"
    },
    {
        "text": "PartExporter.",
        "type": "Title"
    },
    {
        "text": "instrumentToXmlScoreInstrument",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Convert an Instrument object to a\n<score-instrument> element and return it.\n>>> i = instrument.Clarinet()\n>>> i.instrumentId = 'clarinet1'\n>>> i.midiChannel = 4\n>>> PEX = musicxml.m21ToXml.PartExporter()\n>>> mxScoreInstrument = PEX.instrumentToXmlScoreInstrument(i)\n>>> PEX.dump(mxScoreInstrument)\n<score-instrument id=\"clarinet1\">\n  <instrument-name>Clarinet</instrument-name>\n  <instrument-abbreviation>Cl</instrument-abbreviation>\n</score-instrument>\n\n\n>>> i.instrumentName = \"Klarinette 1.\"\n>>> i.instrumentAbbreviation = 'Kl.1'\n>>> mxScoreInstrument = PEX.instrumentToXmlScoreInstrument(i)\n>>> PEX.dump(mxScoreInstrument)\n<score-instrument id=\"clarinet1\">\n  <instrument-name>Klarinette 1.</instrument-name>\n  <instrument-abbreviation>Kl.1</instrument-abbreviation>\n</score-instrument>",
        "type": "ListItem"
    },
    {
        "text": "PartExporter.",
        "type": "Title"
    },
    {
        "text": "mergeInstrumentStreamPartStaffAware",
        "type": "Title"
    },
    {
        "text": "\u2192 bool",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Merges instrument streams from subsequent parts in a PartStaff group.\nDoes nothing in the normal case of single staves.\nReturns whether instrument processing should short circuit,\nwhich is False for the general case and True for subsequent\nPartStaff objects after the first in a group.",
        "type": "ListItem"
    },
    {
        "text": "PartExporter.",
        "type": "Title"
    },
    {
        "text": "parse",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Set up instruments, convert sounding pitch to written pitch,\ncreate a partId (if no good one exists) and set it on\n<part>, fixes up the notation\n(fixupNotationFlat() or fixupNotationMeasured()),\nsetIdLocals() on spanner bundle. Run parse() on each measure's MeasureExporter and\nappend the output to the <part> object.\nIn other words, one-stop shopping.\nmakeNotation when False, will avoid running\nmakeNotation()\non the Part. Generally this attribute is set on GeneralObjectExporter\nor ScoreExporter and read from there. Running with makeNotation\nas False will raise MusicXMLExportException if no measures are present.\nIf makeNotation is False, the transposition to written pitch is still\nperformed and thus will be done in place.\n>>> from music21.musicxml.m21ToXml import PartExporter\n>>> noMeasures = stream.Part(note.Note())\n>>> pex = PartExporter(noMeasures)\n>>> pex.makeNotation = False\n>>> pex.parse()\nTraceback (most recent call last):\nmusic21.musicxml.xmlObjects.MusicXMLExportException:\nCannot export with makeNotation=False if there are no measures",
        "type": "ListItem"
    },
    {
        "text": "Methods inherited from XMLExporterBase:",
        "type": "NarrativeText"
    },
    {
        "text": "accidentalToMx() accidentalToMxAccidentalMark() addDividerComment() asBytes() dump() pageLayoutToXmlPageLayout() pageLayoutToXmlPrint() setColor() setEditorial() setFont() setPosition() setPrintObject() setPrintStyle() setPrintStyleAlign() setStyleAttributes() setTextFormatting() staffLayoutToXmlStaffLayout() systemLayoutToXmlPrint() systemLayoutToXmlSystemLayout() xmlHeader()",
        "type": "Table"
    },
    {
        "text": "PartExporter instance variables",
        "type": "Title"
    },
    {
        "text": "PartExporter.",
        "type": "Title"
    },
    {
        "text": "previousPartStaffInGroup",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "If the part being exported is a PartStaff,\nthis attribute will be used to store the immediately previous PartStaff\nin the StaffGroup, if any. (E.g. if this is\nthe left hand, store a reference to the right hand.)",
        "type": "ListItem"
    },
    {
        "text": "ScoreExporter\u00c2\u00b6",
        "type": "Title"
    },
    {
        "text": "class",
        "type": "Title"
    },
    {
        "text": "music21.musicxml.m21ToXml.",
        "type": "Title"
    },
    {
        "text": "ScoreExporter",
        "type": "Title"
    },
    {
        "text": "score",
        "type": "Title"
    },
    {
        "text": "Score | None",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "makeNotation",
        "type": "Title"
    },
    {
        "text": "bool",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Convert a Score (or outer stream with .parts) into\na musicxml Element.",
        "type": "ListItem"
    },
    {
        "text": "ScoreExporter bases",
        "type": "Title"
    },
    {
        "text": "XMLExporterBase",
        "type": "ListItem"
    },
    {
        "text": "PartStaffExporterMixin",
        "type": "ListItem"
    },
    {
        "text": "ScoreExporter methods",
        "type": "Title"
    },
    {
        "text": "ScoreExporter.",
        "type": "Title"
    },
    {
        "text": "addStyleToXmlDefaults",
        "type": "Title"
    },
    {
        "text": "mxDefaults",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Optionally add an <appearance> tag (using styleToXmlAppearance)\nand <music-font>, <word-font>, zero or more <lyric-font> tags,\nand zero or more <lyric-language> tags to mxDefaults\nDemonstrating round tripping:\n>>> import xml.etree.ElementTree as ET\n>>> defaults = ET.fromstring('<defaults>'\n...          + '<music-font font-family=\"Maestro, Opus\" font-weight=\"bold\" />'\n...          + '<word-font font-family=\"Garamond\" font-style=\"italic\" />'\n...          + '<lyric-font name=\"verse\" font-size=\"12\" />'\n...          + '<lyric-font name=\"chorus\" font-size=\"14\" />'\n...          + '<lyric-language name=\"verse\" xml:lang=\"fr\" />'\n...          + '<lyric-language name=\"chorus\" xml:lang=\"en\" />'\n...          + '</defaults>')\n\n\n>>> MI = musicxml.xmlToM21.MusicXMLImporter()\n>>> MI.styleFromXmlDefaults(defaults)\n>>> SX = musicxml.m21ToXml.ScoreExporter(MI.stream)\n>>> mxDefaults = ET.Element('defaults')\n>>> SX.addStyleToXmlDefaults(mxDefaults)\n>>> SX.dump(mxDefaults)\n<defaults>\n    <music-font font-family=\"Maestro,Opus\" font-weight=\"bold\" />\n    <word-font font-family=\"Garamond\" font-style=\"italic\" />\n    <lyric-font font-size=\"12\" name=\"verse\" />\n    <lyric-font font-size=\"14\" name=\"chorus\" />\n    <lyric-language name=\"verse\" xml:lang=\"fr\" />\n    <lyric-language name=\"chorus\" xml:lang=\"en\" />\n</defaults>",
        "type": "ListItem"
    },
    {
        "text": "ScoreExporter.",
        "type": "Title"
    },
    {
        "text": "contributorToXmlCreator",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Return a <creator> tag from a Contributor object.\n>>> md = metadata.Metadata()\n>>> md.composer = 'Oliveros, Pauline'\n>>> contrib = md.contributors[0]\n>>> contrib\n<music21.metadata.primitives.Contributor composer:Oliveros, Pauline>\n\n\n>>> SX = musicxml.m21ToXml.ScoreExporter()\n>>> mxCreator = SX.contributorToXmlCreator(contrib)\n>>> SX.dump(mxCreator)\n<creator type=\"composer\">Oliveros, Pauline</creator>",
        "type": "ListItem"
    },
    {
        "text": "ScoreExporter.",
        "type": "Title"
    },
    {
        "text": "emptyObject",
        "type": "Title"
    },
    {
        "text": "\u2192 Element",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Creates a cheeky \u009cThis Page Intentionally Left Blank\u009d for a blank score\n>>> emptySX = musicxml.m21ToXml.ScoreExporter()\n>>> mxScore = emptySX.parse()  # will call emptyObject\n>>> emptySX.dump(mxScore)\n<score-partwise version=\"...\">\n  <work>\n    <work-title>This Page Intentionally Left Blank</work-title>\n  </work>\n  ...\n      <note>\n        <rest />\n        <duration>40320</duration>\n        <type>whole</type>\n      </note>\n    </measure>\n  </part>\n</score-partwise>",
        "type": "ListItem"
    },
    {
        "text": "ScoreExporter.",
        "type": "Title"
    },
    {
        "text": "getSupports",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "return a list of <supports> tags  for what this supports.  Does not append\nCurrently just supports new-system and new-page if s.definesExplicitSystemBreaks\nand s.definesExplicitPageBreaks is True.\n>>> SX = musicxml.m21ToXml.ScoreExporter()\n>>> SX.getSupports()\n[]\n>>> SX.stream.definesExplicitSystemBreaks = True\n>>> SX.getSupports()\n[<Element 'supports' at 0x...>]\n>>> SX.dump(SX.getSupports()[0])\n<supports attribute=\"new-system\" element=\"print\" type=\"yes\" value=\"yes\" />\n\n\n>>> SX.stream.definesExplicitPageBreaks = True\n>>> SX.dump(SX.getSupports()[1])\n<supports attribute=\"new-page\" element=\"print\" type=\"yes\" value=\"yes\" />",
        "type": "ListItem"
    },
    {
        "text": "ScoreExporter.",
        "type": "Title"
    },
    {
        "text": "metadataToMiscellaneous",
        "type": "Title"
    },
    {
        "text": "md",
        "type": "Title"
    },
    {
        "text": "Metadata | None",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u2192 Element | None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Returns an mxMiscellaneous of information from metadata object md or\nfrom self.scoreMetadata if md is None.  If the mxMiscellaneous object\nhas any miscellaneous-fields, then it is appended to self.mxIdentification\nif it exists.\n>>> SX = musicxml.m21ToXml.ScoreExporter()\n>>> md = metadata.Metadata()\n>>> md.date = metadata.primitives.DateRelative('1689', 'onOrBefore')\n>>> md.localeOfComposition = 'Rome'\n\n\n>>> mxMisc = SX.metadataToMiscellaneous(md)\n>>> SX.dump(mxMisc)\n<miscellaneous>\n  <miscellaneous-field name=\"dcterms:created\">1689/--/-- or earlier</miscellaneous-field>\n  <miscellaneous-field name=\"humdrum:OPC\">Rome</miscellaneous-field>\n</miscellaneous>",
        "type": "ListItem"
    },
    {
        "text": "ScoreExporter.",
        "type": "Title"
    },
    {
        "text": "parse",
        "type": "Title"
    },
    {
        "text": "\u2192 Element",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "the main function to call.\nIf self.stream is empty, call self.emptyObject().  Otherwise,\nconvert sounding to written pitch,\nset scorePreliminaries(), call parsePartlikeScore or parseFlatScore, then postPartProcess(),\nclean up circular references for garbage collection, and returns the <score-partwise>\nobject.\n>>> b = corpus.parse('bwv66.6')\n>>> SX = musicxml.m21ToXml.ScoreExporter(b)\n>>> mxScore = SX.parse()\n>>> SX.dump(mxScore)\n<score-partwise version=\"...\">...</score-partwise>",
        "type": "ListItem"
    },
    {
        "text": "ScoreExporter.",
        "type": "Title"
    },
    {
        "text": "parseFlatScore",
        "type": "Title"
    },
    {
        "text": "\u2192 None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "creates a single PartExporter for this Stream and parses it.\nNote that the Score does not need to be totally flat, it just cannot have Parts inside it;\nmeasures are fine.\n>>> c = converter.parse('tinyNotation: 3/4 c2. d e')\n>>> SX = musicxml.m21ToXml.ScoreExporter(c)\n>>> SX.parseFlatScore()\n>>> len(SX.partExporterList)\n1\n>>> SX.partExporterList[0]\n<music21.musicxml.m21ToXml.PartExporter object at 0x...>\n>>> SX.dump(SX.partExporterList[0].xmlRoot)\n<part id=\"...\">\n  <!--========================= Measure 1 ==========================-->\n  <measure implicit=\"no\" number=\"1\">...</measure>\n</part>\n>>> del SX.partExporterList[:]  # for garbage collection",
        "type": "ListItem"
    },
    {
        "text": "ScoreExporter.",
        "type": "Title"
    },
    {
        "text": "parsePartlikeScore",
        "type": "Title"
    },
    {
        "text": "\u2192 None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Called by .parse() if the score has individual parts.\nCreates a PartExporter for each part, and runs .parse() on that part.\nAppends the PartExporter to self.partExporterList\nand runs .parse() on that part. Appends the PartExporter to self.",
        "type": "ListItem"
    },
    {
        "text": "ScoreExporter.",
        "type": "Title"
    },
    {
        "text": "postPartProcess",
        "type": "Title"
    },
    {
        "text": "\u2192 None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "calls .joinPartStaffs() from the\nPartStaffExporterMixin,\nthen calls .setScoreHeader(),\nthen appends each PartExporter's xmlRoot from\nself.partExporterList to self.xmlRoot.\nCalled automatically by .parse().",
        "type": "ListItem"
    },
    {
        "text": "ScoreExporter.",
        "type": "Title"
    },
    {
        "text": "renumberVoicesWithinStaffGroups",
        "type": "Title"
    },
    {
        "text": "\u2192 None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Renumbers voices (as appropriate) in each StaffGroup, so that\nvoices have unique numbers across the entire group.\nCalled automatically by .parse()",
        "type": "ListItem"
    },
    {
        "text": "ScoreExporter.",
        "type": "Title"
    },
    {
        "text": "scorePreliminaries",
        "type": "Title"
    },
    {
        "text": "\u2192 None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Populate the exporter object with\nmeterStream, scoreLayouts, spannerBundle, and textBoxes\n>>> emptySX = musicxml.m21ToXml.ScoreExporter()\n>>> emptySX.scorePreliminaries()  # will call emptyObject\n>>> len(emptySX.textBoxes)\n0\n>>> emptySX.spannerBundle\n<music21.spanner.SpannerBundle of size 0>",
        "type": "ListItem"
    },
    {
        "text": "ScoreExporter.",
        "type": "Title"
    },
    {
        "text": "setDefaults",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Returns a default object from self.firstScoreLayout or a very simple one if none exists.\nSimple:\n>>> SX = musicxml.m21ToXml.ScoreExporter()\n>>> mxDefaults = SX.setDefaults()\n>>> SX.dump(mxDefaults)\n<defaults>\n  <scaling>\n    <millimeters>7</millimeters>\n    <tenths>40</tenths>\n  </scaling>\n</defaults>\n\n\nThese numbers come from the defaults module:\n>>> defaults.scalingMillimeters\n7\n>>> defaults.scalingTenths\n40\n\n\nMore complex:\n>>> s = corpus.parse('schoenberg/opus19', 2)\n>>> SX = musicxml.m21ToXml.ScoreExporter(s)\n>>> SX.setScoreLayouts()  # necessary to call before .setDefaults()\n>>> mxDefaults = SX.setDefaults()\n>>> mxDefaults.tag\n'defaults'\n>>> mxScaling = mxDefaults.find('scaling')\n>>> SX.dump(mxScaling)\n<scaling>\n  <millimeters>6.1472</millimeters>\n  <tenths>40</tenths>\n</scaling>\n\n\n>>> mxPageLayout = mxDefaults.find('page-layout')\n>>> SX.dump(mxPageLayout)\n<page-layout>\n  <page-height>1818</page-height>\n  <page-width>1405</page-width>\n  <page-margins>\n    <left-margin>83</left-margin>\n    <right-margin>83</right-margin>\n    <top-margin>103</top-margin>\n    <bottom-margin>103</bottom-margin>\n  </page-margins>\n</page-layout>\n\n\n>>> mxSystemLayout = mxDefaults.find('system-layout')\n>>> SX.dump(mxSystemLayout)\n<system-layout>\n  <system-margins>\n    <left-margin>0</left-margin>\n    <right-margin>0</right-margin>\n  </system-margins>\n  <system-distance>121</system-distance>\n  <top-system-distance>70</top-system-distance>\n</system-layout>\n\n\n>>> mxStaffLayoutList = mxDefaults.findall('staff-layout')\n>>> len(mxStaffLayoutList)\n1\n>>> SX.dump(mxStaffLayoutList[0])\n<staff-layout>\n  <staff-distance>98</staff-distance>\n</staff-layout>",
        "type": "ListItem"
    },
    {
        "text": "ScoreExporter.",
        "type": "Title"
    },
    {
        "text": "setEncoding",
        "type": "NarrativeText"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Returns an encoding object that might have information about <supports> also.\nand appends to mxIdentification (if any)\nWill use the date of generation as encoding-date.\n>>> SX = musicxml.m21ToXml.ScoreExporter()\n>>> mxEncoding = SX.setEncoding()\n>>> SX.dump(mxEncoding)\n<encoding>\n  <encoding-date>20...-...-...</encoding-date>\n  <software>music21 v...</software>\n</encoding>\n\n\nEncoding-date is in YYYY-MM-DD format.",
        "type": "ListItem"
    },
    {
        "text": "ScoreExporter.",
        "type": "Title"
    },
    {
        "text": "setIdentification",
        "type": "Title"
    },
    {
        "text": "\u2192 Element",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Returns an identification object from self.scoreMetadata.  And appends to the score\u2026\nFor defaults:\n>>> SX = musicxml.m21ToXml.ScoreExporter()\n>>> mxIdentification = SX.setIdentification()\n>>> SX.dump(mxIdentification)\n<identification>\n  <creator type=\"composer\">Music21</creator>\n  <encoding>\n    <encoding-date>20...-...-...</encoding-date>\n    <software>music21 v...</software>\n  </encoding>\n</identification>\n\n\nMore realistic:\n>>> md = metadata.Metadata()\n>>> md.composer = 'Francesca Caccini'\n>>> c = metadata.Contributor(role='arranger', name='Aliyah Shanti')\n>>> md.addContributor(c)\n\n\nneed a fresh ScoreExporter \u2026otherwise appends to existing mxIdentification\n>>> SX = musicxml.m21ToXml.ScoreExporter()\n>>> SX.scoreMetadata = md\n>>> mxIdentification = SX.setIdentification()\n>>> SX.dump(mxIdentification)\n<identification>\n  <creator type=\"composer\">Francesca Caccini</creator>\n  <creator type=\"arranger\">Aliyah Shanti</creator>\n  <encoding>\n    <encoding-date>...</encoding-date>\n    <software>music21 v...</software>\n  </encoding>\n</identification>\n\n\nOverriding the default:\n>>> defaults.author = \"Batch Conversion March 2022\"\n>>> SX = musicxml.m21ToXml.ScoreExporter()\n>>> mxIdentification = SX.setIdentification()\n>>> SX.dump(mxIdentification)\n<identification>\n  <creator type=\"composer\">Batch Conversion March 2022</creator>\n  <encoding>\n    <encoding-date>20...-...-...</encoding-date>\n    <software>music21 v...</software>\n  </encoding>\n</identification>",
        "type": "ListItem"
    },
    {
        "text": "ScoreExporter.",
        "type": "Title"
    },
    {
        "text": "setMeterStream",
        "type": "Title"
    },
    {
        "text": "\u2192 None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "sets self.meterStream or uses a default.\nUsed in makeNotation in Part later.\n>>> b = corpus.parse('bwv66.6')\n>>> SX = musicxml.m21ToXml.ScoreExporter(b)\n>>> SX.setMeterStream()\n>>> SX.meterStream\n<music21.stream.Score bach/bwv66.6.mxl>\n>>> len(SX.meterStream)\n4\n>>> SX.meterStream[0]\n<music21.meter.TimeSignature 4/4>",
        "type": "ListItem"
    },
    {
        "text": "ScoreExporter.",
        "type": "Title"
    },
    {
        "text": "setPartExporterStaffGroups",
        "type": "Title"
    },
    {
        "text": "\u2192 None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Figures out the containing StaffGroup for every PartExporter that has one.\nCalled automatically by .parse()",
        "type": "ListItem"
    },
    {
        "text": "ScoreExporter.",
        "type": "Title"
    },
    {
        "text": "setPartList",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Returns a <part-list> and appends it to self.xmlRoot.\nThis is harder than it looks because MusicXML and music21's idea of where to store\nstaff-groups are quite different.\nWe find each stream in self.partExporterList, then look at the StaffGroup spanners in\nself.spannerBundle.  If the part is the first element in a StaffGroup then we add a\n<staff-group> object with \u0098start' as the starting point (and same for multiple StaffGroups)\nthis is in staffGroupToXmlPartGroup(sg).\nthen we add the <score-part> descriptor of the part and its instruments, etc. (currently\njust one!), then we iterate again through all StaffGroups and if this part is the last\nelement in a StaffGroup we add a <staff-group> descriptor with type=\u009dstop\u009d.\nThis Bach example has four parts and one staff-group bracket linking them:\n>>> b = corpus.parse('bwv66.6')\n>>> SX = musicxml.m21ToXml.ScoreExporter(b)\n\n\nNeeds some strange setup to make this work in a demo.  .parse() takes care of all this.\n>>> SX.scorePreliminaries()\n>>> SX.parsePartlikeScore()\n\n\n>>> mxPartList = SX.setPartList()\n>>> SX.dump(mxPartList)\n<part-list>\n  <part-group number=\"1\" type=\"start\">...\n  <score-part id=\"P1\">...\n  <score-part id=\"P2\">...\n  <score-part id=\"P3\">...\n  <score-part id=\"P4\">...\n  <part-group number=\"1\" type=\"stop\" />\n</part-list>\n\n\nMulti-staff parts (such as piano staves), should NOT receive <part-group> tags,\nsince they are joined by <staff> tags:\n>>> cpe = corpus.parse('cpebach')\n>>> SX = musicxml.m21ToXml.ScoreExporter(cpe)\n>>> SX.scorePreliminaries()\n>>> SX.parsePartlikeScore()\n>>> SX.joinPartStaffs()\n\n\n>>> mxPartList = SX.setPartList()\n>>> SX.dump(mxPartList)\n<part-list>\n  <score-part id=\"P1\">...\n  </score-part>\n</part-list>",
        "type": "ListItem"
    },
    {
        "text": "ScoreExporter.",
        "type": "Title"
    },
    {
        "text": "setPartsAndRefStream",
        "type": "Title"
    },
    {
        "text": "\u2192 None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Transfers the offset of the inner stream to elements and sets self.highestTime\n>>> b = corpus.parse('bwv66.6')\n>>> SX = musicxml.m21ToXml.ScoreExporter(b)\n>>> SX.highestTime\n0.0\n>>> SX.setPartsAndRefStream()\n>>> SX.highestTime\n36.0\n>>> SX.refStreamOrTimeRange\n[0.0, 36.0]\n>>> len(SX.parts)\n4\n>>> isinstance(SX.parts[0], stream.Part)\nTrue\n\n\n>>> b.insert(stream.Score())\n>>> SX = musicxml.m21ToXml.ScoreExporter(b)\n>>> SX.setPartsAndRefStream()\nTraceback (most recent call last):\nmusic21.musicxml.xmlObjects.MusicXMLExportException:\nExporting scores nested inside scores is not supported",
        "type": "ListItem"
    },
    {
        "text": "ScoreExporter.",
        "type": "Title"
    },
    {
        "text": "setScoreHeader",
        "type": "Title"
    },
    {
        "text": "\u2192 None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Sets the group score-header in <score-partwise>.  Note that score-header is not\na separate tag, but just a way of grouping things from the tag.\nruns setTitles(), setIdentification(), setDefaults(), changes textBoxes\nto <credit> and does the major task of setting up the part-list with setPartList().",
        "type": "ListItem"
    },
    {
        "text": "ScoreExporter.",
        "type": "Title"
    },
    {
        "text": "setScoreLayouts",
        "type": "Title"
    },
    {
        "text": "\u2192 None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "sets self.scoreLayouts and self.firstScoreLayout\n>>> b = corpus.parse('schoenberg/opus19', 2)\n>>> SX = musicxml.m21ToXml.ScoreExporter(b)\n>>> SX.setScoreLayouts()\n>>> SX.scoreLayouts\n[<music21.layout.ScoreLayout>]\n>>> len(SX.scoreLayouts)\n1\n>>> SX.firstScoreLayout\n<music21.layout.ScoreLayout>",
        "type": "ListItem"
    },
    {
        "text": "ScoreExporter.",
        "type": "Title"
    },
    {
        "text": "setTitles",
        "type": "Title"
    },
    {
        "text": "\u2192 None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "puts work (with work-title), movement-number, movement-title into the self.xmlRoot",
        "type": "ListItem"
    },
    {
        "text": "ScoreExporter.",
        "type": "Title"
    },
    {
        "text": "staffGroupToXmlPartGroup",
        "type": "Title"
    },
    {
        "text": "staffGroup",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Create and configure an mxPartGroup object for the \u0098start' tag\nfrom a staff group spanner. Note that this object\nis not completely formed by this procedure. (number isn't done\u2026)\n>>> b = corpus.parse('bwv66.6')\n>>> SX = musicxml.m21ToXml.ScoreExporter(b)\n>>> firstStaffGroup = b.spannerBundle.getByClass(layout.StaffGroup)[0]\n>>> mxPartGroup = SX.staffGroupToXmlPartGroup(firstStaffGroup)\n>>> SX.dump(mxPartGroup)\n<part-group type=\"start\">\n  <group-symbol>bracket</group-symbol>\n  <group-barline>yes</group-barline>\n</part-group>\n\n\nAt this point, you should set the number of the mxPartGroup, since it is required:\n>>> mxPartGroup.set('number', str(1))\n\n\nWhat can we do with it?\n>>> firstStaffGroup.name = 'Voices'\n>>> firstStaffGroup.abbreviation = 'Ch.'\n>>> firstStaffGroup.symbol = 'brace' # 'none', 'brace', 'line', 'bracket', 'square'\n>>> firstStaffGroup.barTogether = False  # True, False, or 'Mensurstrich'\n>>> mxPartGroup = SX.staffGroupToXmlPartGroup(firstStaffGroup)\n>>> SX.dump(mxPartGroup)\n<part-group type=\"start\">\n  <group-name>Voices</group-name>\n  <group-abbreviation>Ch.</group-abbreviation>\n  <group-symbol>brace</group-symbol>\n  <group-barline>no</group-barline>\n</part-group>\n\n\nNow we avoid printing the name of the group:\n>>> firstStaffGroup.style.hideObjectOnPrint = True\n>>> mxPartGroup = SX.staffGroupToXmlPartGroup(firstStaffGroup)\n>>> SX.dump(mxPartGroup)\n<part-group type=\"start\">\n  <group-name>Voices</group-name>\n  <group-name-display print-object=\"no\" />\n  <group-abbreviation>Ch.</group-abbreviation>\n  <group-symbol>brace</group-symbol>\n  <group-barline>no</group-barline>\n</part-group>",
        "type": "ListItem"
    },
    {
        "text": "ScoreExporter.",
        "type": "Title"
    },
    {
        "text": "styleToXmlAppearance",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Populates the <appearance> tag of the <defaults> with\ninformation from the stream's .style information.\n>>> s = stream.Score()\n>>> s.style.lineWidths.append(('beam', 5.0))\n>>> s.style.noteSizes.append(('cue', 75))\n>>> s.style.distances.append(('hyphen', 0.1))\n>>> s.style.otherAppearances.append(('flags', 'wavy'))\n>>> SX = musicxml.m21ToXml.ScoreExporter(s)\n>>> mxAppearance = SX.styleToXmlAppearance()\n>>> SX.dump(mxAppearance)\n<appearance>\n  <line-width type=\"beam\">5.0</line-width>\n  <note-size type=\"cue\">75</note-size>\n  <distance type=\"hyphen\">0.1</distance>\n  <other-appearance type=\"flags\">wavy</other-appearance>\n</appearance>",
        "type": "ListItem"
    },
    {
        "text": "ScoreExporter.",
        "type": "Title"
    },
    {
        "text": "textBoxToXmlCredit",
        "type": "Title"
    },
    {
        "text": "textBox",
        "type": "Title"
    },
    {
        "text": "TextBox",
        "type": "Title"
    },
    {
        "text": "\u2192 Element",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Convert a music21 TextBox to a MusicXML Credit.\n>>> tb = text.TextBox('testing')\n>>> tb.style.absoluteY = 400\n>>> tb.style.absoluteX = 300\n>>> tb.page = 3\n>>> SX = musicxml.m21ToXml.ScoreExporter()\n>>> mxCredit = SX.textBoxToXmlCredit(tb)\n>>> SX.dump(mxCredit)\n<credit page=\"3\">\n  <credit-words default-x=\"300\" default-y=\"400\"\n       halign=\"center\" valign=\"top\">testing</credit-words>\n</credit>\n\n\nDefault of page 1:\n>>> tb = text.TextBox('testing')\n>>> tb.page\n1\n>>> mxCredit = SX.textBoxToXmlCredit(tb)\n>>> SX.dump(mxCredit)\n<credit page=\"1\">...</credit>\n\n\n\nChanged in v8: Multi-line text now exports as one <credit-words>\nelement (preserving newlines).\n\n>>> tb = text.TextBox('Snare\\nCymbals')\n>>> mxCredit = SX.textBoxToXmlCredit(tb)\n>>> SX.dump(mxCredit)\n<credit page=\"1\">\n    <credit-words default-x=\"500\" default-y=\"500\" halign=\"center\" valign=\"top\"\n    xml:space=\"preserve\">Snare\n    Cymbals</credit-words>\n</credit>",
        "type": "ListItem"
    },
    {
        "text": "Methods inherited from XMLExporterBase:",
        "type": "NarrativeText"
    },
    {
        "text": "accidentalToMx() accidentalToMxAccidentalMark() addDividerComment() asBytes() dump() pageLayoutToXmlPageLayout() pageLayoutToXmlPrint() setColor() setEditorial() setFont() setPosition() setPrintObject() setPrintStyle() setPrintStyleAlign() setStyleAttributes() setTextFormatting() staffLayoutToXmlStaffLayout() systemLayoutToXmlPrint() systemLayoutToXmlSystemLayout() xmlHeader()",
        "type": "Table"
    },
    {
        "text": "Methods inherited from PartStaffExporterMixin:",
        "type": "NarrativeText"
    },
    {
        "text": "addStaffTagsMultiStaffParts() cleanUpSubsequentPartStaffs() getRootForPartStaff() joinPartStaffs() joinableGroups() moveMeasureContents() movePartStaffMeasureContents() processSubsequentPartStaff() setEarliestAttributesAndClefsPartStaff()",
        "type": "Table"
    },
    {
        "text": "XMLExporterBase\u00c2\u00b6",
        "type": "Title"
    },
    {
        "text": "class",
        "type": "Title"
    },
    {
        "text": "music21.musicxml.m21ToXml.",
        "type": "Title"
    },
    {
        "text": "XMLExporterBase",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "contains functions that could be called\nat multiple levels of exporting (Score, Part, Measure).",
        "type": "ListItem"
    },
    {
        "text": "XMLExporterBase methods",
        "type": "Title"
    },
    {
        "text": "XMLExporterBase.",
        "type": "Title"
    },
    {
        "text": "accidentalToMx",
        "type": "Title"
    },
    {
        "text": "Accidental",
        "type": "Title"
    },
    {
        "text": "elName",
        "type": "Title"
    },
    {
        "text": "str",
        "type": "Title"
    },
    {
        "text": "'accidental'",
        "type": "Title"
    },
    {
        "text": "\u2192 Element",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Convert a pitch.Accidental object to a Element of tag \u0098accidental' (or other name)\n>>> acc = pitch.Accidental()\n>>> acc.set('half-sharp')\n>>> acc.alter == 0.5\nTrue\n\n\n>>> XB = musicxml.m21ToXml.XMLExporterBase()\n>>> a2m = XB.accidentalToMx\n>>> XB.dump(a2m(acc))\n<accidental>quarter-sharp</accidental>\n\n\n>>> acc.set('double-flat')\n>>> XB.dump(a2m(acc))\n<accidental>flat-flat</accidental>\n\n\n>>> acc.set('one-and-a-half-sharp')\n>>> XB.dump(a2m(acc, elName='accidental-mark'))\n<accidental-mark>three-quarters-sharp</accidental-mark>\n\n\n>>> acc.set('half-flat')\n>>> XB.dump(a2m(acc))\n<accidental>quarter-flat</accidental>\n\n\n>>> acc.set('one-and-a-half-flat')\n>>> XB.dump(a2m(acc))\n<accidental>three-quarters-flat</accidental>\n\n\n>>> acc.set('sharp')\n>>> acc.displayStyle = 'parentheses'\n>>> XB.dump(a2m(acc))\n<accidental parentheses=\"yes\">sharp</accidental>\n\n\n>>> acc.displayStyle = 'bracket'\n>>> XB.dump(a2m(acc))\n<accidental bracket=\"yes\">sharp</accidental>\n\n\n>>> acc.displayStyle = 'both'\n>>> XB.dump(a2m(acc))\n<accidental bracket=\"yes\" parentheses=\"yes\">sharp</accidental>\n\n\n>>> acc = pitch.Accidental('flat')\n>>> acc.style.relativeX = -2\n>>> XB.dump(a2m(acc))\n<accidental relative-x=\"-2\">flat</accidental>\n\n\n>>> acc = pitch.Accidental()\n>>> acc.name = 'double-sharp-down'  # musicxml 3.1\n>>> XB.dump(a2m(acc))\n<accidental>double-sharp-down</accidental>\n\n\n>>> acc.name = 'funnyAccidental'  # unknown\n>>> XB.dump(a2m(acc))\n<accidental>other</accidental>",
        "type": "ListItem"
    },
    {
        "text": "XMLExporterBase.",
        "type": "Title"
    },
    {
        "text": "accidentalToMxAccidentalMark",
        "type": "Title"
    },
    {
        "text": "Accidental",
        "type": "Title"
    },
    {
        "text": "\u2192 Element",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "",
        "type": "ListItem"
    },
    {
        "text": "XMLExporterBase.",
        "type": "Title"
    },
    {
        "text": "addDividerComment",
        "type": "Title"
    },
    {
        "text": "comment",
        "type": "Title"
    },
    {
        "text": "str",
        "type": "Title"
    },
    {
        "text": "''",
        "type": "UncategorizedText"
    },
    {
        "text": "\u2192 None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Add a divider to xmlRoot.\n>>> from xml.etree.ElementTree import Element\n>>> e1 = Element('accidental')\n>>> e2 = Element('accidental')\n\n\n>>> XB = musicxml.m21ToXml.ScoreExporter()\n>>> XB.xmlRoot.append(e1)\n>>> XB.addDividerComment('second accidental below')\n>>> XB.xmlRoot.append(e2)\n>>> XB.dump(XB.xmlRoot)\n<score-partwise version=\"...\">\n  <accidental />\n  <!--================== second accidental below ===================-->\n  <accidental />\n  </score-partwise>",
        "type": "ListItem"
    },
    {
        "text": "XMLExporterBase.",
        "type": "Title"
    },
    {
        "text": "asBytes",
        "type": "Title"
    },
    {
        "text": "noCopy",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "\u2192 bytes",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "returns the xmlRoot as a bytes object. If noCopy is True\n(default), modifies the file for pretty-printing in place.  Otherwise,\nmake a copy.",
        "type": "ListItem"
    },
    {
        "text": "static",
        "type": "Title"
    },
    {
        "text": "XMLExporterBase.",
        "type": "Title"
    },
    {
        "text": "dump",
        "type": "Title"
    },
    {
        "text": "obj",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "",
        "type": "ListItem"
    },
    {
        "text": "XMLExporterBase.",
        "type": "Title"
    },
    {
        "text": "pageLayoutToXmlPageLayout",
        "type": "Title"
    },
    {
        "text": "pageLayout",
        "type": "Title"
    },
    {
        "text": "mxPageLayoutIn",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "get a <page-layout> element from a PageLayout\nCalled out from pageLayoutToXmlPrint because it\nis also used in the <defaults> tag",
        "type": "ListItem"
    },
    {
        "text": "XMLExporterBase.",
        "type": "Title"
    },
    {
        "text": "pageLayoutToXmlPrint",
        "type": "Title"
    },
    {
        "text": "pageLayout",
        "type": "Title"
    },
    {
        "text": "mxPrintIn",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Given a PageLayout object, set object data for <print>\n>>> pl = layout.PageLayout()\n>>> pl.pageHeight = 4000\n>>> pl.isNew = True\n>>> pl.rightMargin = 30.25\n>>> pl.leftMargin = 20\n>>> pl.pageNumber = 5\n\n\n>>> XPBase = musicxml.m21ToXml.XMLExporterBase()\n>>> mxPrint = XPBase.pageLayoutToXmlPrint(pl)\n>>> XPBase.dump(mxPrint)\n<print new-page=\"yes\" page-number=\"5\">\n  <page-layout>\n    <page-height>4000</page-height>\n    <page-margins>\n      <left-margin>20</left-margin>\n      <right-margin>30.25</right-margin>\n    </page-margins>\n  </page-layout>\n</print>\n\n\n>>> MP = musicxml.xmlToM21.MeasureParser()\n>>> pl2 = MP.xmlPrintToPageLayout(mxPrint)\n>>> pl2.isNew\nTrue\n>>> pl2.rightMargin\n30.25\n>>> pl2.leftMargin\n20\n>>> pl2.pageNumber\n5\n>>> pl2.pageHeight\n4000",
        "type": "ListItem"
    },
    {
        "text": "XMLExporterBase.",
        "type": "Title"
    },
    {
        "text": "setColor",
        "type": "Title"
    },
    {
        "text": "mxObject",
        "type": "Title"
    },
    {
        "text": "m21Object",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Sets mxObject[\u0098color'] to a normalized version of m21Object.style.color",
        "type": "ListItem"
    },
    {
        "text": "XMLExporterBase.",
        "type": "Title"
    },
    {
        "text": "setEditorial",
        "type": "Title"
    },
    {
        "text": "mxObject",
        "type": "Title"
    },
    {
        "text": "m21Object",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": ">>> from xml.etree.ElementTree import fromstring as El\n>>> XB = musicxml.m21ToXml.XMLExporterBase()\n>>> mxObj = El('<note />')\n>>> n = note.Note('C-5')\n\n\nMost common case: does nothing\n>>> XB.setEditorial(mxObj, n)\n>>> XB.dump(mxObj)\n<note />\n\n\n>>> fn = editorial.Comment('flat is obvious error for sharp')\n>>> fn.levelInformation = 2\n>>> fn.isFootnote = True\n>>> n.editorial.footnotes.append(fn)\n>>> XB.setEditorial(mxObj, n)\n>>> XB.dump(mxObj)\n<note>\n  <footnote>flat is obvious error for sharp</footnote>\n  <level reference=\"no\">2</level>\n</note>\n\n\nPlacing information in .editorial.comments only puts out the level:\n>>> mxObj = El('<note />')\n>>> n = note.Note('C-5')\n>>> com = editorial.Comment('flat is obvious error for sharp')\n>>> com.levelInformation = 'hello'\n>>> com.isReference = True\n>>> n.editorial.comments.append(com)\n>>> XB.setEditorial(mxObj, n)\n>>> XB.dump(mxObj)\n<note>\n  <level reference=\"yes\">hello</level>\n</note>",
        "type": "ListItem"
    },
    {
        "text": "XMLExporterBase.",
        "type": "Title"
    },
    {
        "text": "setFont",
        "type": "Title"
    },
    {
        "text": "mxObject",
        "type": "Title"
    },
    {
        "text": "m21Object",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "sets font-family, font-style, font-size, and font-weight as\nfontFamily (list), fontStyle, fontSize and fontWeight from\nan object into a TextStyle object\nconforms to attr-group %font in the MusicXML DTD\n>>> from xml.etree.ElementTree import fromstring as El\n>>> XB = musicxml.m21ToXml.XMLExporterBase()\n>>> mxObj = El('<text>hi</text>')\n>>> te = expressions.TextExpression('hi!')\n>>> te.style.fontFamily = ['Courier', 'monospaced']\n>>> te.style.fontStyle = 'italic'\n>>> te.style.fontSize = 24.0\n>>> XB.setFont(mxObj, te)\n>>> XB.dump(mxObj)\n<text font-family=\"Courier,monospaced\" font-size=\"24\" font-style=\"italic\">hi</text>\n\n\n>>> XB = musicxml.m21ToXml.XMLExporterBase()\n>>> mxObj = El('<text>hi</text>')\n>>> te = expressions.TextExpression('hi!')\n>>> te.style.fontStyle = 'bold'\n>>> XB.setFont(mxObj, te)\n>>> XB.dump(mxObj)\n<text font-weight=\"bold\">hi</text>\n\n\n>>> te.style.fontStyle = 'bolditalic'\n>>> XB.setFont(mxObj, te)\n>>> XB.dump(mxObj)\n<text font-style=\"italic\" font-weight=\"bold\">hi</text>",
        "type": "ListItem"
    },
    {
        "text": "XMLExporterBase.",
        "type": "Title"
    },
    {
        "text": "setPosition",
        "type": "Title"
    },
    {
        "text": "mxObject",
        "type": "Title"
    },
    {
        "text": "m21Object",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "set positioning information for an mxObject from\ndefault-x, default-y, relative-x, relative-y from\nthe .style attribute's absoluteX, relativeX, etc. attributes.",
        "type": "ListItem"
    },
    {
        "text": "XMLExporterBase.",
        "type": "Title"
    },
    {
        "text": "setPrintObject",
        "type": "Title"
    },
    {
        "text": "mxObject",
        "type": "Title"
    },
    {
        "text": "m21Object",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "sets print-object to \u0098no' if m21Object.style.hideObjectOnPrint is True\nor if m21Object is a StyleObject and has .hideObjectOnPrint set to True.",
        "type": "ListItem"
    },
    {
        "text": "XMLExporterBase.",
        "type": "Title"
    },
    {
        "text": "setPrintStyle",
        "type": "Title"
    },
    {
        "text": "mxObject",
        "type": "Title"
    },
    {
        "text": "m21Object",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "get position, font, and color information from the mxObject\ninto the m21Object, which must have style.TextStyle as its Style class.\nconforms to attr-group %print-style in the MusicXML DTD",
        "type": "ListItem"
    },
    {
        "text": "XMLExporterBase.",
        "type": "Title"
    },
    {
        "text": "setPrintStyleAlign",
        "type": "Title"
    },
    {
        "text": "mxObject",
        "type": "Title"
    },
    {
        "text": "m21Object",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "runs setPrintStyle and then sets horizontalAlign and verticalAlign, on an\nm21Object, which must have style.TextStyle as its Style class.\nconforms to attr-group %print-style-align in the MusicXML DTD",
        "type": "ListItem"
    },
    {
        "text": "XMLExporterBase.",
        "type": "Title"
    },
    {
        "text": "setStyleAttributes",
        "type": "Title"
    },
    {
        "text": "mxObject",
        "type": "Title"
    },
    {
        "text": "m21Object",
        "type": "Title"
    },
    {
        "text": "musicXMLNames",
        "type": "Title"
    },
    {
        "text": "m21Names",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Sets any attribute from .style, doing some conversions.\nm21Object can also be a style.Style object itself.",
        "type": "ListItem"
    },
    {
        "text": "XMLExporterBase.",
        "type": "Title"
    },
    {
        "text": "setTextFormatting",
        "type": "NarrativeText"
    },
    {
        "text": "mxObject",
        "type": "Title"
    },
    {
        "text": "m21Object",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "sets the justification, print-style-align group, and\ntext-decoration, text-rotation,\nletter-spacing, line-height, lang, text-direction, and\nenclosure, on an\nm21Object, which must have style.TextStyle as its Style class,\nand then calls setPrintStyleAlign\nconforms to attr-group %text-formatting in the MusicXML DTD",
        "type": "ListItem"
    },
    {
        "text": "XMLExporterBase.",
        "type": "Title"
    },
    {
        "text": "staffLayoutToXmlStaffLayout",
        "type": "Title"
    },
    {
        "text": "staffLayout",
        "type": "Title"
    },
    {
        "text": "mxStaffLayoutIn",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "get a <staff-layout> tag from a StaffLayout object\nIn music21, the <staff-layout> and <staff-details> are\nintertwined in a StaffLayout object.\n>>> sl = layout.StaffLayout()\n>>> sl.distance = 40.0\n>>> sl.staffNumber = 1\n>>> XPBase = musicxml.m21ToXml.XMLExporterBase()\n>>> mxSl = XPBase.staffLayoutToXmlStaffLayout(sl)\n>>> XPBase.dump(mxSl)\n<staff-layout number=\"1\">\n  <staff-distance>40.0</staff-distance>\n</staff-layout>",
        "type": "ListItem"
    },
    {
        "text": "XMLExporterBase.",
        "type": "Title"
    },
    {
        "text": "systemLayoutToXmlPrint",
        "type": "Title"
    },
    {
        "text": "systemLayout",
        "type": "Title"
    },
    {
        "text": "mxPrintIn",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Given a SystemLayout tag, set a <print> tag\n>>> sl = layout.SystemLayout()\n>>> sl.distance = 55\n>>> sl.isNew = True\n>>> sl.rightMargin = 30.25\n>>> sl.leftMargin = 20\n\n\n>>> XPBase = musicxml.m21ToXml.XMLExporterBase()\n>>> mxPrint = XPBase.systemLayoutToXmlPrint(sl)\n>>> XPBase.dump(mxPrint)\n<print new-system=\"yes\">\n  <system-layout>\n    <system-margins>\n      <left-margin>20</left-margin>\n      <right-margin>30.25</right-margin>\n    </system-margins>\n    <system-distance>55</system-distance>\n  </system-layout>\n</print>\n\n\nTest return conversion\n>>> MP = musicxml.xmlToM21.MeasureParser()\n>>> sl2 = MP.xmlPrintToSystemLayout(mxPrint)\n>>> sl2.isNew\nTrue\n>>> sl2.rightMargin\n30.25\n>>> sl2.leftMargin\n20\n>>> sl2.distance\n55",
        "type": "ListItem"
    },
    {
        "text": "XMLExporterBase.",
        "type": "Title"
    },
    {
        "text": "systemLayoutToXmlSystemLayout",
        "type": "Title"
    },
    {
        "text": "systemLayout",
        "type": "Title"
    },
    {
        "text": "mxSystemLayoutIn",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "get given a SystemLayout object configure <system-layout> or <print>\nCalled out from xmlPrintToSystemLayout because it\nis also used in the <defaults> tag\n>>> sl = layout.SystemLayout()\n>>> sl.distance = 40.0\n>>> sl.topDistance = 70.0\n>>> XPBase = musicxml.m21ToXml.XMLExporterBase()\n>>> mxSl = XPBase.systemLayoutToXmlSystemLayout(sl)\n>>> XPBase.dump(mxSl)\n<system-layout>\n  <system-distance>40.0</system-distance>\n  <top-system-distance>70.0</top-system-distance>\n</system-layout>\n\n\n>>> sl = layout.SystemLayout()\n>>> sl.leftMargin = 30.0\n>>> mxSl = XPBase.systemLayoutToXmlSystemLayout(sl)\n>>> XPBase.dump(mxSl)\n<system-layout>\n  <system-margins>\n    <left-margin>30.0</left-margin>\n  </system-margins>\n</system-layout>",
        "type": "ListItem"
    },
    {
        "text": "XMLExporterBase.",
        "type": "Title"
    },
    {
        "text": "xmlHeader",
        "type": "Title"
    },
    {
        "text": "\u2192 bytes",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "",
        "type": "ListItem"
    },
    {
        "text": "Functions\u00c2\u00b6",
        "type": "Title"
    },
    {
        "text": "music21.musicxml.m21ToXml.",
        "type": "Title"
    },
    {
        "text": "getMetadataFromContext",
        "type": "Title"
    },
    {
        "text": "Stream",
        "type": "Title"
    },
    {
        "text": "\u2192 Metadata | None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Get metadata from site or context, so that a Part\ncan be shown and have the rich metadata of its Score\n>>> s = stream.Score()\n>>> s2 = s.transpose(4)\n>>> md = metadata.Metadata()\n>>> md.title = 'emptiness'\n>>> s.metadata = md\n>>> s2.metadata is None\nTrue\n>>> musicxml.m21ToXml.getMetadataFromContext(s2).title\n'emptiness'\n>>> musicxml.m21ToXml.getMetadataFromContext(s).title\n'emptiness'\n>>> p = stream.Part()\n>>> s2.insert(0, p)\n>>> musicxml.m21ToXml.getMetadataFromContext(p).title\n'emptiness'",
        "type": "ListItem"
    },
    {
        "text": "music21.musicxml.m21ToXml.",
        "type": "Title"
    },
    {
        "text": "normalizeColor",
        "type": "Title"
    },
    {
        "text": "color",
        "type": "Title"
    },
    {
        "text": "str",
        "type": "Title"
    },
    {
        "text": "\u2192 str",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Normalize a css3 name to hex or leave it alone\u2026\n>>> musicxml.m21ToXml.normalizeColor('')\n''\n>>> musicxml.m21ToXml.normalizeColor('red')\n'#FF0000'\n>>> musicxml.m21ToXml.normalizeColor('#00ff00')\n'#00FF00'",
        "type": "ListItem"
    },
    {
        "text": "music21.musicxml.m21ToXml.",
        "type": "Title"
    },
    {
        "text": "typeToMusicXMLType",
        "type": "Title"
    },
    {
        "text": "value",
        "type": "Title"
    },
    {
        "text": "str",
        "type": "Title"
    },
    {
        "text": "\u2192 str",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Convert a music21 type to a MusicXML type or raise a MusicXMLExportException\n>>> musicxml.m21ToXml.typeToMusicXMLType('longa')\n'long'\n>>> musicxml.m21ToXml.typeToMusicXMLType('quarter')\n'quarter'\n>>> musicxml.m21ToXml.typeToMusicXMLType('duplex-maxima')\nTraceback (most recent call last):\nmusic21.musicxml.xmlObjects.MusicXMLExportException:\nCannot convert \"duplex-maxima\" duration to MusicXML (too long).\n>>> musicxml.m21ToXml.typeToMusicXMLType('inexpressible')\nTraceback (most recent call last):\nmusic21.musicxml.xmlObjects.MusicXMLExportException:\nCannot convert inexpressible durations to MusicXML.\n>>> musicxml.m21ToXml.typeToMusicXMLType('zero')\nTraceback (most recent call last):\nmusic21.musicxml.xmlObjects.MusicXMLExportException:\nCannot convert durations without types to MusicXML.",
        "type": "ListItem"
    },
    {
        "text": "Navigation",
        "type": "Title"
    },
    {
        "text": "index",
        "type": "ListItem"
    },
    {
        "text": "modules |",
        "type": "ListItem"
    },
    {
        "text": "next |",
        "type": "ListItem"
    },
    {
        "text": "previous |",
        "type": "ListItem"
    },
    {
        "text": "music21 \u00bb",
        "type": "ListItem"
    },
    {
        "text": "Module Reference \u00bb",
        "type": "ListItem"
    },
    {
        "text": "music21.musicxml.m21ToXml",
        "type": "ListItem"
    },
    {
        "text": "\u00a9 Copyright 2006-2023 Michael Scott Asato Cuthbert.\n      Last updated on Jun 12, 2023.",
        "type": "NarrativeText"
    }
]