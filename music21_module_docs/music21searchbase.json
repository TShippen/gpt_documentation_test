[
    {
        "text": "Navigation",
        "type": "Title"
    },
    {
        "text": "index",
        "type": "ListItem"
    },
    {
        "text": "modules |",
        "type": "ListItem"
    },
    {
        "text": "next |",
        "type": "ListItem"
    },
    {
        "text": "previous |",
        "type": "ListItem"
    },
    {
        "text": "music21 \u00bb",
        "type": "ListItem"
    },
    {
        "text": "Module Reference \u00bb",
        "type": "ListItem"
    },
    {
        "text": "music21.search.base",
        "type": "ListItem"
    },
    {
        "text": "Previous topic",
        "type": "Title"
    },
    {
        "text": "music21.scale.scala",
        "type": "Title"
    },
    {
        "text": "Next topic",
        "type": "Title"
    },
    {
        "text": "music21.search.lyrics",
        "type": "Title"
    },
    {
        "text": "Table of Contents",
        "type": "Title"
    },
    {
        "text": "music21.search.base\nSearchMatch\nSearchMatch\nSearchMatch.elStart\nSearchMatch.els\nSearchMatch.index\nSearchMatch.iterator\n\n\n\n\nStreamSearcher\nStreamSearcher\nStreamSearcher.noteNameAlgorithm()\nStreamSearcher.rhythmAlgorithm()\nStreamSearcher.run()\nStreamSearcher.wildcardAlgorithm()\n\n\n\n\nWildcard\nWildcard\n\n\nWildcardDuration\nWildcardDuration\n\n\nFunctions\napproximateNoteSearch()\napproximateNoteSearchNoRhythm()\napproximateNoteSearchOnlyRhythm()\napproximateNoteSearchWeighted()\nmostCommonMeasureRhythms()\nnoteNameRhythmicSearch()\nnoteNameSearch()\nrhythmicSearch()\nstreamSearchBase()\ntranslateDiatonicStreamToString()\ntranslateDurationToBytes()\ntranslateIntervalsAndSpeed()\ntranslateNoteTieToByte()\ntranslateNoteToByte()\ntranslateNoteWithDurationToBytes()\ntranslateStreamToString()\ntranslateStreamToStringNoRhythm()\ntranslateStreamToStringOnlyRhythm()",
        "type": "ListItem"
    },
    {
        "text": "Table of Contents",
        "type": "Title"
    },
    {
        "text": "About music21",
        "type": "ListItem"
    },
    {
        "text": "User's Guide",
        "type": "ListItem"
    },
    {
        "text": "Module Reference",
        "type": "ListItem"
    },
    {
        "text": "Installation",
        "type": "ListItem"
    },
    {
        "text": "Developer Reference",
        "type": "ListItem"
    },
    {
        "text": "Documentation and tests in progress",
        "type": "ListItem"
    },
    {
        "text": "Quick search",
        "type": "Title"
    },
    {
        "text": "This Page",
        "type": "Title"
    },
    {
        "text": "Show Source",
        "type": "ListItem"
    },
    {
        "text": "music21.search.base\u00c2\u00b6",
        "type": "Title"
    },
    {
        "text": "base classes for searching scores.",
        "type": "NarrativeText"
    },
    {
        "text": "See User's Guide, Chapter 43: Searching in and Among Scores for details.",
        "type": "Title"
    },
    {
        "text": "SearchMatch\u00c2\u00b6",
        "type": "Title"
    },
    {
        "text": "class",
        "type": "Title"
    },
    {
        "text": "music21.search.base.",
        "type": "Title"
    },
    {
        "text": "SearchMatch",
        "type": "Title"
    },
    {
        "text": "elStart",
        "type": "Title"
    },
    {
        "text": "els",
        "type": "Title"
    },
    {
        "text": "index",
        "type": "Title"
    },
    {
        "text": "iterator",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "A lightweight object representing the match (if any) for a search.  Derived from namedtuple",
        "type": "ListItem"
    },
    {
        "text": "SearchMatch bases",
        "type": "Title"
    },
    {
        "text": "SearchMatch",
        "type": "ListItem"
    },
    {
        "text": "SearchMatch instance variables",
        "type": "Title"
    },
    {
        "text": "SearchMatch.",
        "type": "Title"
    },
    {
        "text": "elStart",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "The first element that matches the list.",
        "type": "ListItem"
    },
    {
        "text": "SearchMatch.",
        "type": "Title"
    },
    {
        "text": "els",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "A tuple of all the matching elements.",
        "type": "ListItem"
    },
    {
        "text": "SearchMatch.",
        "type": "Title"
    },
    {
        "text": "index",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "The index in the iterator at which the first element can be found",
        "type": "ListItem"
    },
    {
        "text": "SearchMatch.",
        "type": "Title"
    },
    {
        "text": "iterator",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "The iterator which produced these elements.",
        "type": "ListItem"
    },
    {
        "text": "StreamSearcher\u00c2\u00b6",
        "type": "Title"
    },
    {
        "text": "class",
        "type": "Title"
    },
    {
        "text": "music21.search.base.",
        "type": "Title"
    },
    {
        "text": "StreamSearcher",
        "type": "Title"
    },
    {
        "text": "streamSearch",
        "type": "Title"
    },
    {
        "text": "Stream",
        "type": "Title"
    },
    {
        "text": "searchList",
        "type": "Title"
    },
    {
        "text": "list[music21.base.Music21Object]",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "An object that can search through streams for a set of elements\nor notes or something of that sort.\nCreate a basic Stream first:\n>>> thisStream = converter.parse('tinynotation: 3/4 c4. d8 e4 g4. a8 f4. c4. d4')\n>>> thisStream.show('text')\n{0.0} <music21.stream.Measure 1 offset=0.0>\n    {0.0} <music21.clef.TrebleClef>\n    {0.0} <music21.meter.TimeSignature 3/4>\n    {0.0} <music21.note.Note C>\n    {1.5} <music21.note.Note D>\n    {2.0} <music21.note.Note E>\n{3.0} <music21.stream.Measure 2 offset=3.0>\n    {0.0} <music21.note.Note G>\n    {1.5} <music21.note.Note A>\n    {2.0} <music21.note.Note F>\n{6.0} <music21.stream.Measure 3 offset=6.0>\n    {0.5} <music21.note.Note C>\n    {2.0} <music21.note.Note D>\n    {3.0} <music21.bar.Barline type=final>\n\n\nLet's create something to search for:\n>>> c = note.Note('C', quarterLength=1.5)\n>>> d = note.Note('D', quarterLength=0.5)\n>>> searchList = [c, d]\n\n\nNow create a StreamSearcher:\n>>> ss = search.StreamSearcher(thisStream, searchList)\n\n\nsearchList could also be a Stream in itself.\nLet's configure it for recursive search and to filter so only notes are there:\n>>> ss.recurse = True\n>>> ss.filterNotes = True  # or `.filterNotesAndRests`\n\n\nAlternatively, we could have passed in a StreamIterator instead of thisStream.\nNow let's configure the algorithms:\n>>> ss.algorithms\n[<...StreamSearcher.wildcardAlgorithm...>]\n\n\nWildcard search is a default algorithm that lets you use wildcards.\nI suggest you leave it in place and add to the algorithms list.  We can add the\nrhythmAlgorithm to it:\n>>> ss.algorithms.append(search.StreamSearcher.rhythmAlgorithm)\n>>> ss.algorithms\n[<...StreamSearcher.wildcardAlgorithm...>,\n <...StreamSearcher.rhythmAlgorithm...>]\n\n\nNow run it:\n>>> results = ss.run()\n>>> results\n[SearchMatch(elStart=<music21.note.Note C>, els=len(2), index=0, iterator=[...]),\n SearchMatch(elStart=<music21.note.Note G>, els=len(2), index=3, iterator=[...])]\n\n\n>>> results[0].elStart.measureNumber\n1\n>>> results[1].elStart.measureNumber\n2\n\n\nWildcards can be useful:\n>>> searchStream2 = stream.Stream()\n>>> searchStream2.append(note.Note(quarterLength=0.5))\n>>> searchStream2.append(search.Wildcard())\n>>> searchStream2.append(note.Note(quarterLength=1.5))\n\n\n>>> ss.searchList = searchStream2\n>>> results = ss.run()\n>>> results\n[SearchMatch(elStart=<music21.note.Note D>, els=len(3), index=1, iterator=[...]),\n SearchMatch(elStart=<music21.note.Note A>, els=len(3), index=4, iterator=[...])]\n>>> results[0].els\n(<music21.note.Note D>, <music21.note.Note E>, <music21.note.Note G>)\n>>> [n.duration.quarterLength for n in results[0].els]\n[0.5, 1.0, 1.5]",
        "type": "ListItem"
    },
    {
        "text": "StreamSearcher methods",
        "type": "Title"
    },
    {
        "text": "StreamSearcher.",
        "type": "Title"
    },
    {
        "text": "noteNameAlgorithm",
        "type": "Title"
    },
    {
        "text": "streamEl",
        "type": "Title"
    },
    {
        "text": "Music21Object",
        "type": "Title"
    },
    {
        "text": "searchEl",
        "type": "Title"
    },
    {
        "text": "Music21Object",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "",
        "type": "ListItem"
    },
    {
        "text": "StreamSearcher.",
        "type": "Title"
    },
    {
        "text": "rhythmAlgorithm",
        "type": "Title"
    },
    {
        "text": "streamEl",
        "type": "Title"
    },
    {
        "text": "Music21Object",
        "type": "Title"
    },
    {
        "text": "searchEl",
        "type": "Title"
    },
    {
        "text": "Music21Object",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "",
        "type": "ListItem"
    },
    {
        "text": "StreamSearcher.",
        "type": "Title"
    },
    {
        "text": "run",
        "type": "NarrativeText"
    },
    {
        "text": "\u2192 list[music21.search.base.SearchMatch]",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "",
        "type": "ListItem"
    },
    {
        "text": "StreamSearcher.",
        "type": "Title"
    },
    {
        "text": "wildcardAlgorithm",
        "type": "Title"
    },
    {
        "text": "streamEl",
        "type": "Title"
    },
    {
        "text": "Music21Object",
        "type": "Title"
    },
    {
        "text": "searchEl",
        "type": "Title"
    },
    {
        "text": "Music21Object",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "An algorithm that supports Wildcards \u2014 added by default to the search function.",
        "type": "ListItem"
    },
    {
        "text": "Wildcard\u00c2\u00b6",
        "type": "Title"
    },
    {
        "text": "class",
        "type": "Title"
    },
    {
        "text": "music21.search.base.",
        "type": "Title"
    },
    {
        "text": "Wildcard",
        "type": "Title"
    },
    {
        "text": "**",
        "type": "UncategorizedText"
    },
    {
        "text": "keywords",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "An object that may have some properties defined, but others not that\nmatches a single object in a music21 stream.  Equivalent to the\nregular expression \u009c.\u009d\n>>> wc1 = search.Wildcard()\n>>> wc1.pitch = pitch.Pitch('C')\n>>> st1 = stream.Stream()\n>>> st1.append(note.Note('D', type='half'))\n>>> st1.append(wc1)",
        "type": "ListItem"
    },
    {
        "text": "Wildcard bases",
        "type": "Title"
    },
    {
        "text": "Music21Object",
        "type": "ListItem"
    },
    {
        "text": "ProtoM21Object",
        "type": "ListItem"
    },
    {
        "text": "Wildcard read-only properties",
        "type": "Title"
    },
    {
        "text": "Read-only properties inherited from Music21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "beat beatDuration beatStr beatStrength hasEditorialInformation hasStyleInformation measureNumber",
        "type": "Table"
    },
    {
        "text": "Read-only properties inherited from ProtoM21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "classSet classes",
        "type": "Table"
    },
    {
        "text": "Wildcard read/write properties",
        "type": "Title"
    },
    {
        "text": "Read/write properties inherited from Music21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "activeSite derivation duration editorial id offset priority quarterLength seconds style",
        "type": "Table"
    },
    {
        "text": "Wildcard methods",
        "type": "Title"
    },
    {
        "text": "Methods inherited from Music21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "__eq__() clearCache() containerHierarchy() contextSites() getAllContextsByClass() getContextByClass() getOffsetBySite() getOffsetInHierarchy() getSpannerSites() informSites() mergeAttributes() next() previous() purgeLocations() purgeOrphans() setOffsetBySite() show() sortTuple() splitAtDurations() splitAtQuarterLength() splitByQuarterLengths() write()",
        "type": "Table"
    },
    {
        "text": "Methods inherited from ProtoM21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "isClassOrSubclass()",
        "type": "Table"
    },
    {
        "text": "Wildcard instance variables",
        "type": "Title"
    },
    {
        "text": "Instance variables inherited from Music21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "classSortOrder groups isStream sites",
        "type": "Table"
    },
    {
        "text": "WildcardDuration\u00c2\u00b6",
        "type": "Title"
    },
    {
        "text": "class",
        "type": "Title"
    },
    {
        "text": "music21.search.base.",
        "type": "Title"
    },
    {
        "text": "WildcardDuration",
        "type": "Title"
    },
    {
        "text": "typeOrDuration",
        "type": "Title"
    },
    {
        "text": "str",
        "type": "Title"
    },
    {
        "text": "OffsetQLIn",
        "type": "Title"
    },
    {
        "text": "DurationTuple",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "type",
        "type": "Title"
    },
    {
        "text": "str | None",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "dots",
        "type": "Title"
    },
    {
        "text": "int | None",
        "type": "Title"
    },
    {
        "text": "quarterLength",
        "type": "Title"
    },
    {
        "text": "OffsetQLIn | None",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "durationTuple",
        "type": "Title"
    },
    {
        "text": "DurationTuple | None",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "components",
        "type": "Title"
    },
    {
        "text": "Iterable",
        "type": "Title"
    },
    {
        "text": "DurationTuple",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "client",
        "type": "Title"
    },
    {
        "text": "base.Music21Object | None",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "**",
        "type": "UncategorizedText"
    },
    {
        "text": "keywords",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "a wildcard duration (it might define a duration\nin itself, but the methods here will see that it\nis a wildcard of some sort)\nNo difference from any other duration.",
        "type": "ListItem"
    },
    {
        "text": "WildcardDuration bases",
        "type": "Title"
    },
    {
        "text": "Duration",
        "type": "ListItem"
    },
    {
        "text": "ProtoM21Object",
        "type": "ListItem"
    },
    {
        "text": "SlottedObjectMixin",
        "type": "ListItem"
    },
    {
        "text": "WildcardDuration read-only properties",
        "type": "Title"
    },
    {
        "text": "Read-only properties inherited from Duration:",
        "type": "NarrativeText"
    },
    {
        "text": "fullName isComplex ordinal quarterLengthNoTuplets",
        "type": "Table"
    },
    {
        "text": "Read-only properties inherited from ProtoM21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "classSet classes",
        "type": "Table"
    },
    {
        "text": "WildcardDuration read/write properties",
        "type": "Title"
    },
    {
        "text": "Read/write properties inherited from Duration:",
        "type": "NarrativeText"
    },
    {
        "text": "components dotGroups dots linked quarterLength tuplets type",
        "type": "Table"
    },
    {
        "text": "WildcardDuration methods",
        "type": "Title"
    },
    {
        "text": "Methods inherited from Duration:",
        "type": "NarrativeText"
    },
    {
        "text": "__eq__() addDurationTuple() aggregateTupletMultiplier() appendTuplet() augmentOrDiminish() clear() componentIndexAtQtrPosition() componentStartTime() consolidate() currentComponents() getGraceDuration() informClient() sliceComponentAtPosition() splitDotGroups()",
        "type": "Table"
    },
    {
        "text": "Methods inherited from ProtoM21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "isClassOrSubclass()",
        "type": "Table"
    },
    {
        "text": "WildcardDuration instance variables",
        "type": "Title"
    },
    {
        "text": "Instance variables inherited from Duration:",
        "type": "NarrativeText"
    },
    {
        "text": "client expressionIsInferred",
        "type": "Table"
    },
    {
        "text": "Functions\u00c2\u00b6",
        "type": "Title"
    },
    {
        "text": "music21.search.base.",
        "type": "Title"
    },
    {
        "text": "approximateNoteSearch",
        "type": "Title"
    },
    {
        "text": "thisStream",
        "type": "Title"
    },
    {
        "text": "otherStreams",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "searches the list of otherStreams and returns an ordered list of matches\n(each stream will have a new property of matchProbability to show how\nwell it matches)\n>>> s = converter.parse(\"tinynotation: 4/4 c4 d8 e16 FF a'4 b-\")\n>>> o1 = converter.parse(\"tinynotation: 4/4 c4 d8 e GG a' b-4\")\n>>> o1.id = 'o1'\n>>> o2 = converter.parse(\"tinynotation: 4/4 d#2 f A a' G b\")\n>>> o2.id = 'o2'\n>>> o3 = converter.parse(\"tinynotation: 4/4 c8 d16 e32 FF32 a'8 b-8\")\n>>> o3.id = 'o3'\n>>> l = search.approximateNoteSearch(s, [o1, o2, o3])\n>>> for i in l:\n...    print('%s %r' % (i.id, i.matchProbability))\no1 0.666666...\no3 0.333333...\no2 0.083333...",
        "type": "ListItem"
    },
    {
        "text": "music21.search.base.",
        "type": "Title"
    },
    {
        "text": "approximateNoteSearchNoRhythm",
        "type": "Title"
    },
    {
        "text": "thisStream",
        "type": "Title"
    },
    {
        "text": "otherStreams",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "searches the list of otherStreams and returns an ordered list of matches\n(each stream will have a new property of matchProbability to show how\nwell it matches)\n>>> s = converter.parse(\"tinynotation: 4/4 c4 d8 e16 FF a'4 b-\")\n>>> o1 = converter.parse(\"tinynotation: 4/4 c4 d8 e GG a' b-4\")\n>>> o1.id = 'o1'\n>>> o2 = converter.parse(\"tinynotation: 4/4 d#2 f A a' G b\")\n>>> o2.id = 'o2'\n>>> o3 = converter.parse(\"tinynotation: 4/4 c4 d e GG CCC r\")\n>>> o3.id = 'o3'\n>>> l = search.approximateNoteSearchNoRhythm(s, [o1, o2, o3])\n>>> for i in l:\n...    print('%s %r' % (i.id, i.matchProbability))\no1 0.83333333...\no3 0.5\no2 0.1666666...",
        "type": "ListItem"
    },
    {
        "text": "music21.search.base.",
        "type": "Title"
    },
    {
        "text": "approximateNoteSearchOnlyRhythm",
        "type": "Title"
    },
    {
        "text": "thisStream",
        "type": "Title"
    },
    {
        "text": "otherStreams",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "searches the list of otherStreams and returns an ordered list of matches\n(each stream will have a new property of matchProbability to show how\nwell it matches)\n>>> s = converter.parse(\"tinynotation: 4/4 c4 d8 e16 FF a'4 b-\")\n>>> o1 = converter.parse(\"tinynotation: 4/4 c4 d8 e GG a' b-4\")\n>>> o1.id = 'o1'\n>>> o2 = converter.parse(\"tinynotation: 4/4 d#2 f A a' G b\")\n>>> o2.id = 'o2'\n>>> o3 = converter.parse(\"tinynotation: 4/4 c4 d e GG CCC r\")\n>>> o3.id = 'o3'\n>>> l = search.approximateNoteSearchOnlyRhythm(s, [o1, o2, o3])\n>>> for i in l:\n...    print('%s %r' % (i.id, i.matchProbability))\no1 0.5\no3 0.33...\no2 0.0",
        "type": "ListItem"
    },
    {
        "text": "music21.search.base.",
        "type": "Title"
    },
    {
        "text": "approximateNoteSearchWeighted",
        "type": "NarrativeText"
    },
    {
        "text": "thisStream",
        "type": "Title"
    },
    {
        "text": "otherStreams",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "searches the list of otherStreams and returns an ordered list of matches\n(each stream will have a new property of matchProbability to show how\nwell it matches)\n>>> s = converter.parse(\"tinynotation: 4/4 c4 d8 e16 FF a'4 b-\")\n>>> o1 = converter.parse(\"tinynotation: 4/4 c4 d8 e GG2 a' b-4\")\n>>> o1.id = 'o1'\n>>> o2 = converter.parse(\"tinynotation: 4/4 AAA4 AAA8 AAA16 AAA16 AAA4 AAA4\")\n>>> o2.id = 'o2'\n>>> o3 = converter.parse(\"tinynotation: 4/4 c8 d16 e32 FF32 a'8 b-8\")\n>>> o3.id = 'o3'\n>>> o4 = converter.parse(\"tinynotation: 4/4 c1 d1 e1 FF1 a'1 b-1\")\n>>> o4.id = 'o4'\n>>> l = search.approximateNoteSearchWeighted(s, [o1, o2, o3, o4])\n>>> for i in l:\n...    print('%s %r' % (i.id, i.matchProbability))\no3 0.83333...\no1 0.75\no4 0.75\no2 0.25",
        "type": "ListItem"
    },
    {
        "text": "music21.search.base.",
        "type": "Title"
    },
    {
        "text": "mostCommonMeasureRhythms",
        "type": "Title"
    },
    {
        "text": "streamIn",
        "type": "Title"
    },
    {
        "text": "transposeDiatonic",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "returns a sorted list of dictionaries\nof the most common rhythms in a stream where\neach dictionary contains:\nnumber: the number of times a rhythm appears\nrhythm: the rhythm found (with the pitches of the first instance of the rhythm transposed to C5)\nmeasures: a list of measures containing the rhythm\nrhythmString: a string representation of the rhythm (see translateStreamToStringOnlyRhythm)\n>>> bach = corpus.parse('bwv1.6')\n>>> sortedRhythms = search.mostCommonMeasureRhythms(bach)\n>>> for in_dict in sortedRhythms[0:3]:\n...     print(f\"no: {in_dict['number']} rhythmString: {in_dict['rhythmString']}\")\n...     print('bars: %r' % ([(m.number,\n...                               str(m.getContextByClass(stream.Part).id))\n...                            for m in in_dict['measures']]))\n...     in_dict['rhythm'].show('text')\n...     print('-----')\nno: 34 rhythmString: PPPP\nbars: [(1, 'Soprano'), (2, 'Soprano'), (3, 'Soprano'), ..., (1, 'Alto'), ..., (10, 'Bass')]\n{0.0} <music21.note.Note C>\n{1.0} <music21.note.Note A>\n{2.0} <music21.note.Note F>\n{3.0} <music21.note.Note C>\n-----\nno: 7 rhythmString: ZZ\nbars: [(13, 'Soprano'), (14, 'Soprano'), ..., (14, 'Bass')]\n{0.0} <music21.note.Note C>\n{2.0} <music21.note.Note A>\n-----\nno: 6 rhythmString: ZPP\nbars: [(6, 'Soprano'), (12, 'Soprano'), ..., (18, 'Tenor'), ... (12, 'Bass')]\n{0.0} <music21.note.Note C>\n{2.0} <music21.note.Note B->\n{3.0} <music21.note.Note B->\n-----\n\n\n\nChanged in v7: bars are ordered first by number, then by part.",
        "type": "ListItem"
    },
    {
        "text": "music21.search.base.",
        "type": "Title"
    },
    {
        "text": "noteNameRhythmicSearch",
        "type": "Title"
    },
    {
        "text": "thisStreamOrIterator",
        "type": "Title"
    },
    {
        "text": "searchList",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": ">>> thisStream = converter.parse('tinynotation: 3/4 c4 d8 e c d e f c D E c c4 d# e')\n>>> searchList = [note.Note('C'), note.Note('D'), note.Note('E')]\n>>> for n in searchList:\n...     n.duration.type = 'eighth'\n>>> thisStreamIter = thisStream.recurse().notes\n\n\n>>> search.noteNameRhythmicSearch(thisStreamIter, searchList)\n[3, 7]\n\n\n>>> searchList[0].duration = search.WildcardDuration()\n>>> search.noteNameRhythmicSearch(thisStreamIter, searchList)\n[0, 3, 7]",
        "type": "ListItem"
    },
    {
        "text": "music21.search.base.",
        "type": "Title"
    },
    {
        "text": "noteNameSearch",
        "type": "Title"
    },
    {
        "text": "thisStreamOrIterator",
        "type": "Title"
    },
    {
        "text": "searchList",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": ">>> thisStream = converter.parse('tinynotation: 3/4 c4 d8 e c d e f c D E c c4 d# e')\n>>> searchList = [note.Note('C'), note.Note('D'), note.Note('E')]\n>>> thisStreamIter = thisStream.recurse().notes\n\n\n>>> search.noteNameSearch(thisStreamIter, searchList)\n[0, 3, 7]\n>>> searchList2 = [note.Note('C'), search.Wildcard(), note.Note('E')]\n>>> search.noteNameSearch(thisStreamIter, searchList2)\n[0, 3, 7, 11]",
        "type": "ListItem"
    },
    {
        "text": "music21.search.base.",
        "type": "Title"
    },
    {
        "text": "rhythmicSearch",
        "type": "Title"
    },
    {
        "text": "thisStreamOrIterator",
        "type": "Title"
    },
    {
        "text": "searchList",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Takes two streams \u2014 the first is the stream to be searched and the second\nis a stream of elements whose rhythms must match the first.  Returns a list\nof indices which begin a successful search.\nsearches are made based on quarterLength.\nthus a dotted sixteenth-note and a quadruplet (4:3) eighth\nwill match each other.\nExample 1: First we will set up a simple stream for searching:\n>>> thisStream = converter.parse('tinynotation: 3/4 c4. d8 e4 g4. a8 f4. c4. r4')\n>>> thisStream.show('text')\n{0.0} <music21.stream.Measure 1 offset=0.0>\n    {0.0} <music21.clef.TrebleClef>\n    {0.0} <music21.meter.TimeSignature 3/4>\n    {0.0} <music21.note.Note C>\n    {1.5} <music21.note.Note D>\n    {2.0} <music21.note.Note E>\n{3.0} <music21.stream.Measure 2 offset=3.0>\n    {0.0} <music21.note.Note G>\n    {1.5} <music21.note.Note A>\n    {2.0} <music21.note.Note F>\n{6.0} <music21.stream.Measure 3 offset=6.0>\n    {0.5} <music21.note.Note C>\n    {2.0} <music21.note.Rest quarter>\n    {3.0} <music21.bar.Barline type=final>\n\n\nNow we will search for all dotted-quarter/eighth elements in the Stream:\n>>> thisStreamIter = thisStream.recurse().notes\n\n\n>>> searchStream1 = stream.Stream()\n>>> searchStream1.append(note.Note(quarterLength=1.5))\n>>> searchStream1.append(note.Note(quarterLength=0.5))\n\n\n>>> l = search.rhythmicSearch(thisStreamIter, searchStream1)\n>>> l\n[0, 3]\n>>> stream.Stream(thisStreamIter[3:5]).show('text')\n{0.0} <music21.note.Note G>\n{1.5} <music21.note.Note A>\n\n\nSlightly more advanced search: we will look for any instances of eighth,\nfollowed by a note (or other element) of any length, followed by a dotted quarter\nnote.  Again, we will find two instances; this time we will tag them both with\na TextExpression of \u009c*\u009d and then show the original stream:\n>>> searchStream2 = stream.Stream()\n>>> searchStream2.append(note.Note(quarterLength=0.5))\n>>> searchStream2.append(search.Wildcard())\n>>> searchStream2.append(note.Note(quarterLength=1.5))\n>>> l = search.rhythmicSearch(thisStreamIter, searchStream2)\n>>> l\n[1, 4]\n>>> for found in l:\n...     thisStreamIter[found].lyric = '*'\n>>> thisStream.show()\n\n\n\nNow we can test the search on a real dataset and show the types\nof preparation that are needed to make it most likely a success.\nWe will look through the first movement of Corelli Trio Sonata op. 3 no. 1 (F major)\nlooking to see how much more common the first search term (dotted-quarter, eighth)\nis than the second (eighth, anything, dotted-quarter).  In fact, my hypothesis\nwas wrong, and the second term is actually more common than the first! (n.b. rests\nare being counted here as well as notes)\n>>> grave = corpus.parse('corelli/opus3no1/1grave')\n>>> term1results = []\n>>> term2results = []\n>>> for p in grave.parts:\n...    pf = p.flatten().stripTies().notesAndRests  # consider tied notes as one long note\n...    temp1 = search.rhythmicSearch(pf, searchStream1)\n...    temp2 = search.rhythmicSearch(pf, searchStream2)\n...    for found in temp1:\n...        term1results.append(found)\n...    for found in temp2:\n...        term2results.append(found)\n>>> term1results\n[0, 7, 13, 21, 42, 57, 64, 66, 0, 5, 7, 19, 21, 40, 46, 63, 0, 8, 31, 61, 69, 71, 73, 97]\n>>> term2results\n[5, 29, 95]\n>>> float(len(term1results)) / len(term2results)\n8.0",
        "type": "ListItem"
    },
    {
        "text": "music21.search.base.",
        "type": "Title"
    },
    {
        "text": "streamSearchBase",
        "type": "Title"
    },
    {
        "text": "thisStreamOrIterator",
        "type": "Title"
    },
    {
        "text": "searchList",
        "type": "Title"
    },
    {
        "text": "algorithm",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "A basic search function that is used by other search mechanisms,\nwhich takes in a stream or StreamIterator and a searchList or stream\nand an algorithm to run on each pair of elements to determine if they match.",
        "type": "ListItem"
    },
    {
        "text": "music21.search.base.",
        "type": "Title"
    },
    {
        "text": "translateDiatonicStreamToString",
        "type": "NarrativeText"
    },
    {
        "text": "inputStreamOrIterator",
        "type": "Title"
    },
    {
        "text": "returnMeasures",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Translates a Stream or StreamIterator of Notes and Rests only into a string,\nencoding only the .step (no accidental or octave) and whether\nthe note is slower, faster, or the same speed as the previous\nnote.\nSkips all but the first note of tie. Skips multiple rests in a row\nEach note gets one byte:\nA-G = note of same length as previous\nH-N = note of longer length than previous\nO-U = note of shorter length than previous\nZ = rest\n>>> s = converter.parse(\"tinynotation: 3/4 c4 d8~ d16 r16 FF8 F#8 a'8 b-2.\")\n>>> streamString = search.translateDiatonicStreamToString(s.recurse().notesAndRests)\n>>> print(streamString)\nCRZFFAI\n>>> len(streamString)\n7\n\n\nIf returnMeasures is True, returns an array of measureNumbers where each entry represents\nthe measure number of the measure of the object at that character position :\n>>> streamString2, measures = search.translateDiatonicStreamToString(s.recurse().notesAndRests,\n...                                    returnMeasures=True)\n>>> streamString == streamString2\nTrue\n>>> measures\n[1, 1, 1, 1, 1, 2, 2]",
        "type": "ListItem"
    },
    {
        "text": "music21.search.base.",
        "type": "Title"
    },
    {
        "text": "translateDurationToBytes",
        "type": "Title"
    },
    {
        "text": "GeneralNote",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "takes a note.Note object and translates it to a two-byte representation\ncurrently returns the chr() for the note's midi number. or chr(127) for rests\nfollowed by the log of the quarter length (fitted to 1-127, see formula below)\n>>> n = note.Note('C4')\n>>> n.duration.quarterLength = 3  # dotted half\n>>> trans = search.translateDurationToBytes(n)\n>>> trans\n'_'\n>>> (2 ** (ord(trans[0]) / 10)) / 256  # approximately 3\n2.828...",
        "type": "ListItem"
    },
    {
        "text": "music21.search.base.",
        "type": "Title"
    },
    {
        "text": "translateIntervalsAndSpeed",
        "type": "Title"
    },
    {
        "text": "inputStream",
        "type": "Title"
    },
    {
        "text": "returnMeasures",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Translates a Stream (not StreamIterator) of Notes and Rests only into a string,\nencoding only the chromatic distance from the last note and whether\nthe note is slower, faster, or the same speed as the previous\nnote.\nSkips all but the first note of tie. Skips multiple rests in a row\nEach note gets one byte and encodes up from -13 to 13 (all notes > octave are 13 or -13)\n>>> s = converter.parse(\"tinynotation: 3/4 c4 d8~ d16 r16 F8 F#8 F8 a'8 b-2\")\n>>> sn = s.flatten().notesAndRests.stream()\n>>> streamString = search.translateIntervalsAndSpeed(sn)\n>>> print(streamString)\nIb RHJ<9\n>>> print([ord(x) for x in streamString])\n[73, 98, 32, 82, 72, 74, 60, 57]\n>>> len(streamString)\n8\n\n\nIf returnMeasures is True, returns a triplet of whether the last note\nwas a rest, whether the last note was tied, what the last quarterLength was, and what the\nlast pitches' midi number was\nwhich can be fed back into this algorithm:\n>>> streamString2, measures = search.translateIntervalsAndSpeed(sn, returnMeasures=True)\n>>> streamString == streamString2\nTrue\n>>> measures\n[1, 1, 1, 1, 1, 2, 2, 2]",
        "type": "ListItem"
    },
    {
        "text": "music21.search.base.",
        "type": "Title"
    },
    {
        "text": "translateNoteTieToByte",
        "type": "Title"
    },
    {
        "text": "GeneralNote",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "takes a note.Note object and returns a one-byte representation\nof its tie status.\n\u0098s' if start tie, \u0098e' if stop tie, \u0098c' if continue tie, and \u0098' if no tie\n>>> n = note.Note('E')\n>>> search.translateNoteTieToByte(n)\n''\n\n\n>>> n.tie = tie.Tie('start')\n>>> search.translateNoteTieToByte(n)\n's'\n\n\n>>> n.tie.type = 'continue'\n>>> search.translateNoteTieToByte(n)\n'c'\n\n\n>>> n.tie.type = 'stop'\n>>> search.translateNoteTieToByte(n)\n'e'",
        "type": "ListItem"
    },
    {
        "text": "music21.search.base.",
        "type": "Title"
    },
    {
        "text": "translateNoteToByte",
        "type": "Title"
    },
    {
        "text": "GeneralNote",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "takes a note.Note object and translates it to a single byte representation.\ncurrently returns the chr() for the note's midi number. or chr(127) for rests\nand unpitched.\n>>> n = note.Note('C4')\n>>> b = search.translateNoteToByte(n)\n>>> b\n'<'\n>>> ord(b)\n60\n>>> ord(b) == n.pitch.midi\nTrue\n\n\nChords are currently just searched on the first Note (or treated as a Rest if None)",
        "type": "ListItem"
    },
    {
        "text": "music21.search.base.",
        "type": "Title"
    },
    {
        "text": "translateNoteWithDurationToBytes",
        "type": "Title"
    },
    {
        "text": "GeneralNote",
        "type": "Title"
    },
    {
        "text": "includeTieByte",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "takes a note.Note object and translates it to a three-byte representation.\ncurrently returns the chr() for the note's midi number. or chr(127) for rests\nfollowed by the log of the quarter length (fitted to 1-127, see\ntranslateDurationToBytes())\nfollowed by \u0098s', \u0098c', or \u0098e' if includeTieByte is True and there is a tie.\n>>> n = note.Note('C4')\n>>> n.duration.quarterLength = 3  # dotted half\n>>> trans = search.translateNoteWithDurationToBytes(n)\n>>> trans\n'<_'\n>>> (2**(ord(trans[1])/10.0))/256  # approximately 3\n2.828...\n\n\n>>> n.tie = tie.Tie('stop')\n>>> trans = search.translateNoteWithDurationToBytes(n)\n>>> trans\n'<_e'\n\n\n>>> trans = search.translateNoteWithDurationToBytes(n, includeTieByte=False)\n>>> trans\n'<_'",
        "type": "ListItem"
    },
    {
        "text": "music21.search.base.",
        "type": "Title"
    },
    {
        "text": "translateStreamToString",
        "type": "NarrativeText"
    },
    {
        "text": "inputStreamOrIterator",
        "type": "Title"
    },
    {
        "text": "returnMeasures",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "takes a stream (or streamIterator) of notesAndRests only and returns\na string for searching on.\n>>> s = converter.parse(\"tinynotation: 3/4 c4 d8 r16 FF8. a'8 b-2.\")\n>>> sn = s.flatten().notesAndRests\n>>> streamString = search.translateStreamToString(sn)\n>>> print(streamString)\n<P>F\u007f<)KQFF_\n>>> len(streamString)\n12\n\n\nChords give the pitch only of the first note and Unpitched objects are\ntreated as rests:\n>>> s = stream.Stream([note.Note('C4'), note.Rest(),\n...                    chord.Chord(['C4', 'E4']), note.Unpitched()])\n>>> streamString = search.translateStreamToString(s)\n>>> list(streamString.encode('utf-8'))\n[60, 80, 127, 80, 60, 80, 127, 80]",
        "type": "ListItem"
    },
    {
        "text": "music21.search.base.",
        "type": "Title"
    },
    {
        "text": "translateStreamToStringNoRhythm",
        "type": "Title"
    },
    {
        "text": "inputStream",
        "type": "Title"
    },
    {
        "text": "returnMeasures",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "takes a stream or streamIterator of notesAndRests only and returns\na string for searching on, using translateNoteToByte.\n>>> s = converter.parse(\"tinynotation: 4/4 c4 d e FF a'2 b-2\")\n>>> sn = s.flatten().notesAndRests\n>>> search.translateStreamToStringNoRhythm(sn)\n'<>@)QF'\n\n\nWith returnMeasures, will return a tuple of bytes and a list of measure numbers:\n>>> search.translateStreamToStringNoRhythm(sn, returnMeasures=True)\n('<>@)QF', [1, 1, 1, 1, 2, 2])",
        "type": "ListItem"
    },
    {
        "text": "music21.search.base.",
        "type": "Title"
    },
    {
        "text": "translateStreamToStringOnlyRhythm",
        "type": "Title"
    },
    {
        "text": "inputStream",
        "type": "Title"
    },
    {
        "text": "returnMeasures",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "takes a stream or streamIterator of notesAndRests only and returns\na string for searching on.\n>>> s = converter.parse(\"tinynotation: 3/4 c4 d8 e16 FF8. a'8 b-2.\")\n>>> sn = s.flatten().notesAndRests\n>>> streamString = search.translateStreamToStringOnlyRhythm(sn)\n>>> print(streamString)\nPF<KF_\n>>> len(streamString)\n6",
        "type": "ListItem"
    },
    {
        "text": "Navigation",
        "type": "Title"
    },
    {
        "text": "index",
        "type": "ListItem"
    },
    {
        "text": "modules |",
        "type": "ListItem"
    },
    {
        "text": "next |",
        "type": "ListItem"
    },
    {
        "text": "previous |",
        "type": "ListItem"
    },
    {
        "text": "music21 \u00bb",
        "type": "ListItem"
    },
    {
        "text": "Module Reference \u00bb",
        "type": "ListItem"
    },
    {
        "text": "music21.search.base",
        "type": "ListItem"
    },
    {
        "text": "\u00a9 Copyright 2006-2023 Michael Scott Asato Cuthbert.\n      Last updated on Jun 12, 2023.",
        "type": "NarrativeText"
    }
]