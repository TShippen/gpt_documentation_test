[
    {
        "text": "Navigation",
        "type": "Title"
    },
    {
        "text": "index",
        "type": "ListItem"
    },
    {
        "text": "modules |",
        "type": "ListItem"
    },
    {
        "text": "next |",
        "type": "ListItem"
    },
    {
        "text": "previous |",
        "type": "ListItem"
    },
    {
        "text": "music21 \u00bb",
        "type": "ListItem"
    },
    {
        "text": "Module Reference \u00bb",
        "type": "ListItem"
    },
    {
        "text": "music21.musicxml.xmlToM21",
        "type": "ListItem"
    },
    {
        "text": "Previous topic",
        "type": "Title"
    },
    {
        "text": "music21.musicxml.xmlSoundParser",
        "type": "Title"
    },
    {
        "text": "Next topic",
        "type": "Title"
    },
    {
        "text": "music21.note",
        "type": "Title"
    },
    {
        "text": "Table of Contents",
        "type": "Title"
    },
    {
        "text": "music21.musicxml.xmlToM21\nMeasureParser\nMeasureParser\nMeasureParser.addToStaffReference()\nMeasureParser.findM21VoiceFromXmlVoice()\nMeasureParser.getStaffNumber()\nMeasureParser.handleClef()\nMeasureParser.handleFingering()\nMeasureParser.handleKeySignature()\nMeasureParser.handleMeasureStyle()\nMeasureParser.handleStaffDetails()\nMeasureParser.handleTimeSignature()\nMeasureParser.insertCoreAndRef()\nMeasureParser.insertInMeasureOrVoice()\nMeasureParser.mxKeyOctaves()\nMeasureParser.nonTraditionalKeySignature()\nMeasureParser.parse()\nMeasureParser.parseAttributesTag()\nMeasureParser.parseMeasureAttributes()\nMeasureParser.parseMeasureNumbers()\nMeasureParser.setDirectionInDirectionType()\nMeasureParser.setDynamicsDirection()\nMeasureParser.setHarmonic()\nMeasureParser.setSound()\nMeasureParser.updateLyricsFromList()\nMeasureParser.updateVoiceInformation()\nMeasureParser.xmlBackup()\nMeasureParser.xmlBarline()\nMeasureParser.xmlDirection()\nMeasureParser.xmlDirectionTypeToSpanners()\nMeasureParser.xmlForward()\nMeasureParser.xmlGraceToGrace()\nMeasureParser.xmlHarmony()\nMeasureParser.xmlNotations()\nMeasureParser.xmlNotationsToSpanners()\nMeasureParser.xmlNoteToGeneralNoteHelper()\nMeasureParser.xmlNotehead()\nMeasureParser.xmlOneSpanner()\nMeasureParser.xmlOrnamentToExpression()\nMeasureParser.xmlPrint()\nMeasureParser.xmlSound()\nMeasureParser.xmlStaffLayoutFromStaffDetails()\nMeasureParser.xmlTechnicalToArticulation()\nMeasureParser.xmlToAccidental()\nMeasureParser.xmlToArticulation()\nMeasureParser.xmlToBarline()\nMeasureParser.xmlToBeam()\nMeasureParser.xmlToBeams()\nMeasureParser.xmlToChord()\nMeasureParser.xmlToChordSymbol()\nMeasureParser.xmlToClef()\nMeasureParser.xmlToDuration()\nMeasureParser.xmlToKeySignature()\nMeasureParser.xmlToLyric()\nMeasureParser.xmlToNote()\nMeasureParser.xmlToOffset()\nMeasureParser.xmlToPitch()\nMeasureParser.xmlToRehearsalMark()\nMeasureParser.xmlToRepeat()\nMeasureParser.xmlToRest()\nMeasureParser.xmlToSimpleNote()\nMeasureParser.xmlToTempoIndication()\nMeasureParser.xmlToTextExpression()\nMeasureParser.xmlToTie()\nMeasureParser.xmlToTimeSignature()\nMeasureParser.xmlToTremolo()\nMeasureParser.xmlToTuplets()\nMeasureParser.xmlToUnpitched()\nMeasureParser.xmlTransposeToInterval()\n\n\n\n\nMusicXMLImporter\nMusicXMLImporter\nMusicXMLImporter.creatorToContributor()\nMusicXMLImporter.identificationToMetadata()\nMusicXMLImporter.isRecognizableMetadataKey()\nMusicXMLImporter.parsePartList()\nMusicXMLImporter.parseXMLText()\nMusicXMLImporter.partGroups()\nMusicXMLImporter.processEncoding()\nMusicXMLImporter.readFile()\nMusicXMLImporter.rightsToCopyright()\nMusicXMLImporter.scoreFromFile()\nMusicXMLImporter.styleFromXmlDefaults()\nMusicXMLImporter.xmlAppearanceToStyle()\nMusicXMLImporter.xmlCreditToTextBox()\nMusicXMLImporter.xmlDefaultsToScoreLayout()\nMusicXMLImporter.xmlMetadata()\nMusicXMLImporter.xmlPartToPart()\nMusicXMLImporter.xmlRootToScore()\n\n\n\n\nPartGroup\nPartGroup\nPartGroup.add()\n\n\n\n\nPartParser\nPartParser\nPartParser.adjustTimeAttributesFromMeasure()\nPartParser.applyMultiMeasureRest()\nPartParser.getDefaultInstrument()\nPartParser.parse()\nPartParser.parseMeasures()\nPartParser.parseXmlScorePart()\nPartParser.reclassifyInstrumentFromName()\nPartParser.removeEndForwardRest()\nPartParser.separateOutPartStaves()\nPartParser.setLastMeasureInfo()\nPartParser.updateTransposition()\nPartParser.xmlMeasureToMeasure()\n\n\n\n\nXMLParserBase\nXMLParserBase\nXMLParserBase.setColor()\nXMLParserBase.setEditorial()\nXMLParserBase.setFont()\nXMLParserBase.setLineStyle()\nXMLParserBase.setPlacement()\nXMLParserBase.setPosition()\nXMLParserBase.setPrintObject()\nXMLParserBase.setPrintStyle()\nXMLParserBase.setPrintStyleAlign()\nXMLParserBase.setStyleAttributes()\nXMLParserBase.setTextFormatting()\nXMLParserBase.xmlPageLayoutToPageLayout()\nXMLParserBase.xmlPrintToPageLayout()\nXMLParserBase.xmlPrintToSystemLayout()\nXMLParserBase.xmlStaffLayoutToStaffLayout()\nXMLParserBase.xmlSystemLayoutToSystemLayout()\n\n\n\n\nFunctions\nmusicXMLTypeToType()\nstrippedText()",
        "type": "ListItem"
    },
    {
        "text": "Table of Contents",
        "type": "Title"
    },
    {
        "text": "About music21",
        "type": "ListItem"
    },
    {
        "text": "User's Guide",
        "type": "ListItem"
    },
    {
        "text": "Module Reference",
        "type": "ListItem"
    },
    {
        "text": "Installation",
        "type": "ListItem"
    },
    {
        "text": "Developer Reference",
        "type": "ListItem"
    },
    {
        "text": "Documentation and tests in progress",
        "type": "ListItem"
    },
    {
        "text": "Quick search",
        "type": "Title"
    },
    {
        "text": "This Page",
        "type": "Title"
    },
    {
        "text": "Show Source",
        "type": "ListItem"
    },
    {
        "text": "music21.musicxml.xmlToM21\u00c2\u00b6",
        "type": "Title"
    },
    {
        "text": "MeasureParser\u00c2\u00b6",
        "type": "Title"
    },
    {
        "text": "class",
        "type": "Title"
    },
    {
        "text": "music21.musicxml.xmlToM21.",
        "type": "Title"
    },
    {
        "text": "MeasureParser",
        "type": "Title"
    },
    {
        "text": "mxMeasure",
        "type": "Title"
    },
    {
        "text": "Element | None",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "parent",
        "type": "Title"
    },
    {
        "text": "PartParser | None",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "parser to work with a single <measure> tag.\ncalled out for simplicity.\n>>> from xml.etree.ElementTree import fromstring as EL\n\n\n>>> scoreMeasure = '<measure><note><rest/><duration>40320</duration></note></measure>'\n>>> mxMeasure = EL(scoreMeasure)\n>>> mp = musicxml.xmlToM21.MeasureParser(mxMeasure)\n>>> mp.parse()\n>>> mp.restAndNoteCount['rest']\n1\n>>> mp.restAndNoteCount['note']\n0\n\n\nfullMeasureRest indicates that a rest lasts the full measure of the current time signature.\n>>> mp.fullMeasureRest\nTrue",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser bases",
        "type": "Title"
    },
    {
        "text": "XMLParserBase",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser methods",
        "type": "Title"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "addToStaffReference",
        "type": "Title"
    },
    {
        "text": "mxObjectOrNumber",
        "type": "Title"
    },
    {
        "text": "m21Object",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Utility routine for importing musicXML objects;\nhere, we store a reference to the music21 object in a dictionary,\nwhere keys are the staff values. Staff values may be None, 1, 2, etc.\n>>> MP = musicxml.xmlToM21.MeasureParser()\n>>> MP.addToStaffReference(1, note.Note('C5'))\n>>> MP.addToStaffReference(2, note.Note('D3'))\n>>> MP.addToStaffReference(2, note.Note('E3'))\n>>> len(MP.staffReference)\n2\n>>> list(sorted(MP.staffReference.keys()))\n[1, 2]\n>>> MP.staffReference[1]\n[<music21.note.Note C>]\n>>> MP.staffReference[2]\n[<music21.note.Note D>, <music21.note.Note E>]\n\n\n>>> from xml.etree.ElementTree import fromstring as EL\n>>> mxNote = EL('<note><staff>1</staff></note>')\n>>> MP.addToStaffReference(mxNote, note.Note('F5'))\n>>> MP.staffReference[1]\n[<music21.note.Note C>, <music21.note.Note F>]\n\n\nNo staff reference.\n>>> mxNote = EL('<note />')\n>>> MP.addToStaffReference(mxNote, note.Note('G4'))\n>>> len(MP.staffReference)\n3\n>>> MP.staffReference[0]\n[<music21.note.Note G>]",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "findM21VoiceFromXmlVoice",
        "type": "Title"
    },
    {
        "text": "mxVoice",
        "type": "Title"
    },
    {
        "text": "Element | None",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u2192 Voice | None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Find the stream.Voice object from a <voice> tag or None.",
        "type": "ListItem"
    },
    {
        "text": "static",
        "type": "Title"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "getStaffNumber",
        "type": "Title"
    },
    {
        "text": "mxObjectOrNumber",
        "type": "Title"
    },
    {
        "text": "\u2192 int",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "gets an int representing a staff number, or 0 (representing no staff assigned)\nfrom an mxObject or a number\u2026\n>>> mp = musicxml.xmlToM21.MeasureParser()\n>>> from xml.etree.ElementTree import fromstring as EL\n\n\n>>> gsn = mp.getStaffNumber\n>>> gsn(1)\n1\n>>> gsn('2')\n2\n\n\n<note> tags store their staff numbers in a <staff> tag's text\u2026\n>>> gsn(EL('<note><staff>2</staff></note>'))\n2\n\n\n\u2026or not at all.\n>>> el = EL('<note><pitch><step>C</step><octave>4</octave></pitch></note>')\n>>> gsn(el) == musicxml.xmlToM21.NO_STAFF_ASSIGNED\nTrue\n\n\nClefs, however, store theirs in a number attribute.\n>>> gsn(EL('<clef number=\"2\"/>'))\n2\n>>> gsn(None) == musicxml.xmlToM21.NO_STAFF_ASSIGNED\nTrue",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "handleClef",
        "type": "Title"
    },
    {
        "text": "mxClef",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Handles a clef object, appending it to the core, and\nsetting self.lastClefs for the staff number.\n>>> import xml.etree.ElementTree as ET\n>>> mxClef = ET.fromstring('<clef><sign>G</sign><line>2</line></clef>')\n\n\n>>> MP = musicxml.xmlToM21.MeasureParser()\n>>> MP.handleClef(mxClef)\n>>> MP.lastClefs\n{0: <music21.clef.TrebleClef>}\n\n\n>>> mxClefBC = ET.fromstring('<clef number=\"2\"><sign>F</sign><line>4</line></clef>')\n>>> MP.handleClef(mxClefBC)\n>>> MP.lastClefs[2]\n<music21.clef.BassClef>\n>>> MP.lastClefs[0]\n<music21.clef.TrebleClef>",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "handleFingering",
        "type": "NarrativeText"
    },
    {
        "text": "tech",
        "type": "Title"
    },
    {
        "text": "mxObj",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "A few specialized functions for dealing with fingering objects",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "handleKeySignature",
        "type": "Title"
    },
    {
        "text": "mxKey",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "convert mxKey to a Key or KeySignature and run insertCoreAndRef on it",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "handleMeasureStyle",
        "type": "Title"
    },
    {
        "text": "mxMeasureStyle",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "measure + multi-measure repeats, slashed repeats, etc.\nBut currently only multiMeasure rests are supported.\nEach of these applies to the entire measure, so there's\nno need to insert into the stream.\nDoes not support multiple staves yet.",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "handleStaffDetails",
        "type": "Title"
    },
    {
        "text": "mxDetails",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "StaffDetails (staff-details) handles attributes about\nthe staff itself \u2014 its size, number of lines, tuning,\nfrets, etc.\nIt is different from StaffLayout (staff-layout) which\nonly handles relationship of one staff to another (the\ndistance)\nRather than returning a StaffLayout object,\nit adds it to self.staffLayoutObjects checking\nto see if there is already an incomplete\nStaffLayout object for this staff.",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "handleTimeSignature",
        "type": "Title"
    },
    {
        "text": "mxTime",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Creates a TimeSignature using xmlToTimeSignature and inserts it into\nthe stream if it is appropriate to do so (now always yes.)",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "insertCoreAndRef",
        "type": "Title"
    },
    {
        "text": "offset",
        "type": "Title"
    },
    {
        "text": "mxObjectOrNumber",
        "type": "Title"
    },
    {
        "text": "m21Object",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "runs addToStaffReference and then insertCore.\n>>> from xml.etree.ElementTree import fromstring as EL\n>>> mxNote = EL('<note><staff>1</staff></note>')\n\n\n>>> MP = musicxml.xmlToM21.MeasureParser()\n>>> MP.insertCoreAndRef(1.0, mxNote, note.Note('F5'))\n\n\nThis routine leaves MP.stream in an unusable state, because\nit runs insertCore.  Thus, before querying the stream we need to run at end:\n>>> MP.stream.coreElementsChanged()\n>>> MP.stream.show('text')\n{1.0} <music21.note.Note F>",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "insertInMeasureOrVoice",
        "type": "Title"
    },
    {
        "text": "mxElement",
        "type": "Title"
    },
    {
        "text": "el",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Adds an object to a measure or a voice.  Needs a note element (obviously)\nbut also mxNote to get the voice.  Uses coreInsert and thus leaves insertStream\non the inner voice in an unusable state.",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "mxKeyOctaves",
        "type": "Title"
    },
    {
        "text": "mxKey",
        "type": "Title"
    },
    {
        "text": "ks",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "process the <key-octave> tags to potentially change a key signature\nto a non-standard key signature.\n>>> import xml.etree.ElementTree as ET\n>>> mxKey = ET.fromstring('<key><fifths>-4</fifths>'\n...   + '<key-octave number=\"1\">3</key-octave>'\n...   + '<key-octave number=\"2\">4</key-octave>'\n...   + '<key-octave number=\"4\">3</key-octave>'\n...   + '</key>')\n\n\n>>> ks = key.KeySignature(-4)\n>>> MP = musicxml.xmlToM21.MeasureParser()\n>>> MP.mxKeyOctaves(mxKey, ks)\n>>> ks.alteredPitches\n[<music21.pitch.Pitch B-3>,\n <music21.pitch.Pitch E-4>,\n <music21.pitch.Pitch A->,\n <music21.pitch.Pitch D-3>]",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "nonTraditionalKeySignature",
        "type": "Title"
    },
    {
        "text": "mxKey",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Returns a KeySignature object that represents a nonTraditional Key Signature\ncalled by xmlToKeySignature if <fifths> is not present.\n>>> import xml.etree.ElementTree as ET\n>>> MP = musicxml.xmlToM21.MeasureParser()\n\n\n>>> mxKey = ET.fromstring('<key><key-step>E</key-step><key-alter>-1</key-alter></key>')\n>>> MP.nonTraditionalKeySignature(mxKey)\n<music21.key.KeySignature of pitches: [E-]>\n\n\nShould be the same:\n>>> MP.xmlToKeySignature(mxKey)\n<music21.key.KeySignature of pitches: [E-]>\n\n\nWorks with key-accidental also:\n>>> mxKey = ET.fromstring('<key><key-step>G</key-step><key-alter>1</key-alter>'\n...                       + '<key-accidental>sharp</key-accidental></key>')\n>>> MP.nonTraditionalKeySignature(mxKey)\n<music21.key.KeySignature of pitches: [G#]>",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "parse",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "parseAttributesTag",
        "type": "Title"
    },
    {
        "text": "mxAttributes",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Parses a single attributes tag (mxAttributes) and sets\nself.attributesAreInternal to False,\nself.activeAttributes to mxAttributes,\nself.parent.activeAttributes to mxAttributes\nand then runs the appropriate attributeTagsToMethods for\nthe attribute.\nAlso sets self.divisions for the current divisions\n(along with self.parent.lastDivisions)\nand self.transposition and\nto the current transpose.",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "parseMeasureAttributes",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "parses the attributes of the <measure> tag.  Not the\n<attributes> tag inside the measure tag.\ncalls parseMeasureNumbers(), and gets the width from the width tag.\n# TODO: non-controlling\n# may need to do a format/unit conversion?",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "parseMeasureNumbers",
        "type": "Title"
    },
    {
        "text": "mNumRaw",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Gets the measure number from the \u0098number' attribute of the\n<measure> tag.  (Or, for testing, from the mNumRaw\nargument).  Sets MeasureParser.stream.number and possibly\nMeasureParser.stream.numberSuffix\n>>> MP = musicxml.xmlToM21.MeasureParser()\n>>> MP.parseMeasureNumbers('5')\n>>> MP.stream.number\n5\n\n\nSets not only stream.number, but also MeasureParser.measureNumber and\nMeasureParser.numberSuffix\n>>> MP.parseMeasureNumbers('44b')\n>>> MP.stream.number\n44\n>>> MP.stream.numberSuffix\n'b'\n>>> MP.measureNumber\n44\n>>> MP.numberSuffix\n'b'\n\n\n>>> MP.parseMeasureNumbers('X1')\n>>> MP.stream.number\n1\n>>> MP.stream.numberSuffix\n'X'",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "setDirectionInDirectionType",
        "type": "Title"
    },
    {
        "text": "mxDir",
        "type": "Title"
    },
    {
        "text": "Element",
        "type": "Title"
    },
    {
        "text": "mxDirection",
        "type": "Title"
    },
    {
        "text": "Element",
        "type": "Title"
    },
    {
        "text": "staffKey",
        "type": "Title"
    },
    {
        "text": "int",
        "type": "Title"
    },
    {
        "text": "totalOffset",
        "type": "Title"
    },
    {
        "text": "float",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "setDynamicsDirection",
        "type": "Title"
    },
    {
        "text": "mxDir",
        "type": "Title"
    },
    {
        "text": "Element",
        "type": "Title"
    },
    {
        "text": "mxDyn",
        "type": "Title"
    },
    {
        "text": "Element",
        "type": "Title"
    },
    {
        "text": "mxDirection",
        "type": "Title"
    },
    {
        "text": "Element",
        "type": "Title"
    },
    {
        "text": "staffKey",
        "type": "Title"
    },
    {
        "text": "int",
        "type": "Title"
    },
    {
        "text": "totalOffset",
        "type": "Title"
    },
    {
        "text": "float",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Add a single dynamic element to the core and staffReference.",
        "type": "ListItem"
    },
    {
        "text": "static",
        "type": "Title"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "setHarmonic",
        "type": "Title"
    },
    {
        "text": "mxh",
        "type": "Title"
    },
    {
        "text": "harm",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "From the artificial or natural tag (or no tag) and\nzero or one of base-pitch, sounding-pitch, touching-pitch,\nsets .harmonicType and .pitchType on an articulations.Harmonic object\nCalled from xmlTechnicalToArticulation\n>>> from xml.etree.ElementTree import fromstring as EL\n>>> MP = musicxml.xmlToM21.MeasureParser()\n\n\n>>> mxTech = EL('<harmonic><artificial/><sounding-pitch/></harmonic>')\n>>> a = MP.xmlTechnicalToArticulation(mxTech)\n>>> a\n<music21.articulations.StringHarmonic>\n\n\n>>> a.harmonicType\n'artificial'\n>>> a.pitchType\n'sounding'",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "setSound",
        "type": "Title"
    },
    {
        "text": "mxSound",
        "type": "Title"
    },
    {
        "text": "Element",
        "type": "Title"
    },
    {
        "text": "mxDir",
        "type": "Title"
    },
    {
        "text": "Element | None",
        "type": "Title"
    },
    {
        "text": "staffKey",
        "type": "Title"
    },
    {
        "text": "int",
        "type": "Title"
    },
    {
        "text": "totalOffset",
        "type": "Title"
    },
    {
        "text": "float",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Takes a <sound> tag and creates objects from it.\nPresently only handles <sound tempo='x'> events and inserts them as MetronomeMarks.\nIf the <sound> tag is a child of a <direction> tag, the direction information\nis used to set the placement of the MetronomeMark.",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "updateLyricsFromList",
        "type": "Title"
    },
    {
        "text": "lyricList",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Takes a list of <lyric> elements and update the\nnote's lyrics from that list.\n>>> import xml.etree.ElementTree as ET\n>>> MP = musicxml.xmlToM21.MeasureParser()\n\n\n>>> mxLyric1 = ET.fromstring('<lyric><text>Hi</text><elision/><text>There</text></lyric>')\n>>> mxLyric2 = ET.fromstring('<lyric><text>Bye</text></lyric>')\n>>> n = note.Note()\n>>> MP.updateLyricsFromList(n, [mxLyric1, mxLyric2])\n>>> n.lyrics\n[<music21.note.Lyric number=1 syllabic=composite text='Hi There'>,\n <music21.note.Lyric number=2 text='Bye'>]",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "updateVoiceInformation",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Finds all the \u009cvoice\u009d information in <note> tags and updates the set of\n.voiceIndices to be a set of all the voice texts, and if there is\nmore than one voice in the measure, sets .useVoices to True\nand creates a voice for each.\n>>> import xml.etree.ElementTree as ET\n>>> MP = musicxml.xmlToM21.MeasureParser()\n>>> MP.mxMeasure = ET.fromstring('<measure><note><voice>1</voice></note></measure>')\n>>> MP.updateVoiceInformation()\n\n\nPuts a set object in .voiceIndices\n>>> MP.voiceIndices\n{'1'}\n>>> MP.useVoices\nFalse\n\n\n>>> MP = musicxml.xmlToM21.MeasureParser()\n>>> MP.mxMeasure = ET.fromstring('<measure><note><voice>1</voice></note>'\n...                                     + '<note><voice>2</voice></note></measure>')\n>>> MP.updateVoiceInformation()\n>>> sorted(list(MP.voiceIndices))\n['1', '2']\n>>> MP.useVoices\nTrue\n>>> len(MP.stream)\n2\n>>> list(MP.stream.getElementsByClass(stream.Voice))\n[<music21.stream.Voice 1>, <music21.stream.Voice 2>]",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "xmlBackup",
        "type": "Title"
    },
    {
        "text": "mxObj",
        "type": "Title"
    },
    {
        "text": "Element",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Parse a backup tag by changing offsetMeasureNote.\nA floor of 0.0 is enforced in case of float rounding issues.\n>>> MP = musicxml.xmlToM21.MeasureParser()\n>>> MP.divisions = 100\n>>> MP.offsetMeasureNote = 1.9979\n\n\n>>> from xml.etree.ElementTree import fromstring as EL\n>>> mxBackup = EL('<backup><duration>100</duration></backup>')\n>>> MP.xmlBackup(mxBackup)\n>>> MP.offsetMeasureNote\n0.9979\n\n\n>>> MP.xmlBackup(mxBackup)\n>>> MP.offsetMeasureNote\n0.0",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "xmlBarline",
        "type": "Title"
    },
    {
        "text": "mxBarline",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Handles everything for putting a barline into a Stream\nand updating repeat characteristics.",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "xmlDirection",
        "type": "Title"
    },
    {
        "text": "mxDirection",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "convert a <direction> tag to one or more expressions, metronome marks, etc.\nand add them to the core and staffReference.",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "xmlDirectionTypeToSpanners",
        "type": "Title"
    },
    {
        "text": "mxObj",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Some spanners, such as MusicXML wedge, bracket, dashes, and ottava\nare encoded as MusicXML directions.\n>>> from xml.etree.ElementTree import fromstring as EL\n>>> MP = musicxml.xmlToM21.MeasureParser()\n>>> n1 = note.Note('D4')\n>>> MP.nLast = n1\n\n\n>>> len(MP.spannerBundle)\n0\n>>> mxDirectionType = EL('<wedge type=\"crescendo\" number=\"2\"/>')\n>>> retList = MP.xmlDirectionTypeToSpanners(mxDirectionType)\n>>> retList\n[<music21.dynamics.Crescendo>]\n\n\n>>> len(MP.spannerBundle)\n1\n>>> sp = MP.spannerBundle[0]\n>>> sp\n<music21.dynamics.Crescendo>\n\n\n>>> mxDirectionType2 = EL('<wedge type=\"stop\" number=\"2\"/>')\n>>> retList = MP.xmlDirectionTypeToSpanners(mxDirectionType2)\n\n\nretList is empty because nothing new has been added.\n>>> retList\n[]\n\n\n>>> len(MP.spannerBundle)\n1\n>>> sp = MP.spannerBundle[0]\n>>> sp\n<music21.dynamics.Crescendo <music21.note.Note D>>",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "xmlForward",
        "type": "Title"
    },
    {
        "text": "mxObj",
        "type": "Title"
    },
    {
        "text": "Element",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Parse a forward tag by changing offsetMeasureNote.",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "xmlGraceToGrace",
        "type": "Title"
    },
    {
        "text": "mxGrace",
        "type": "Title"
    },
    {
        "text": "noteOrChord",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Given a completely formed, non-grace Note or Chord that should become one\ncreate and return a m21 grace version of the same.",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "xmlHarmony",
        "type": "Title"
    },
    {
        "text": "mxHarmony",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Create a ChordSymbol object and insert it to the core and staff reference.",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "xmlNotations",
        "type": "Title"
    },
    {
        "text": "mxNotations",
        "type": "Title"
    },
    {
        "text": "Element",
        "type": "Title"
    },
    {
        "text": "GeneralNote",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": ">>> from xml.etree.ElementTree import fromstring as EL\n>>> MP = musicxml.xmlToM21.MeasureParser()\n\n\n>>> mxNotations = EL('<notations>' +\n...     '<fermata type=\"upright\">angled</fermata>' +\n...     '</notations>')\n>>> n = note.Note()\n>>> MP.xmlNotations(mxNotations, n)\n>>> n.expressions\n[<music21.expressions.Fermata>]\n>>> n.expressions[0].type\n'upright'\n>>> n.expressions[0].shape\n'angled'",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "xmlNotationsToSpanners",
        "type": "Title"
    },
    {
        "text": "mxNotations",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "xmlNoteToGeneralNoteHelper",
        "type": "Title"
    },
    {
        "text": "mxNote",
        "type": "Title"
    },
    {
        "text": "freeSpanners",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Combined function to work on all <note> tags, where n can be\na Note or Rest.\n>>> from xml.etree.ElementTree import fromstring as EL\n>>> n = note.Note()\n>>> mxNote = EL('<note color=\"silver\"></note>')\n>>> MP = musicxml.xmlToM21.MeasureParser()\n>>> n = MP.xmlNoteToGeneralNoteHelper(n, mxNote)\n>>> n.style.color\n'silver'",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "xmlNotehead",
        "type": "Title"
    },
    {
        "text": "mxNotehead",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Set notehead information from the mxNotehead object\n>>> from xml.etree.ElementTree import fromstring as EL\n>>> MP = musicxml.xmlToM21.MeasureParser()\n\n\n>>> n = note.Note()\n>>> nh = EL('<notehead color=\"#FF0000\" filled=\"no\" parentheses=\"yes\">'\n...         + 'diamond</notehead>')\n\n\n>>> MP.xmlNotehead(n, nh)\n>>> n.notehead\n'diamond'\n>>> n.noteheadFill\nFalse\n>>> n.noteheadParenthesis\nTrue\n>>> n.style.color\n'#FF0000'",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "xmlOneSpanner",
        "type": "Title"
    },
    {
        "text": "mxObj",
        "type": "Title"
    },
    {
        "text": "target",
        "type": "Title"
    },
    {
        "text": "spannerClass",
        "type": "Title"
    },
    {
        "text": "allowDuplicateIds",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Some spanner types do not have an id necessarily, we allow duplicates of them\nif allowDuplicateIds is True. Wedges are one.\nReturns the new spanner created.",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "xmlOrnamentToExpression",
        "type": "Title"
    },
    {
        "text": "mxObj",
        "type": "Title"
    },
    {
        "text": "mostRecentOrnament",
        "type": "Title"
    },
    {
        "text": "Ornament | None",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Convert mxOrnament into a music21 ornament.\nThis only processes non-spanner ornaments.\nMany mxOrnaments are spanners: these are handled elsewhere.\nReturns None if it cannot be converted or is not defined, or if the\nmxObj is an accidental-mark (in which case the accidental is placed\nin the mostRecentOrnament instead).\nReturn an articulation from an mxObj, setting placement\n>>> from xml.etree.ElementTree import fromstring as EL\n>>> MP = musicxml.xmlToM21.MeasureParser()\n\n\n>>> mxOrn = EL('<inverted-turn placement=\"above\" font-size=\"24\"/>')\n>>> a = MP.xmlOrnamentToExpression(mxOrn)\n>>> a\n<music21.expressions.InvertedTurn>\n>>> a.placement\n'above'\n>>> a.style.fontSize\n24\n\n\nIf it can't be converted, return None\n>>> mxOrn = EL('<crazy-slide placement=\"above\"/>')\n>>> a = MP.xmlOrnamentToExpression(mxOrn)\n>>> a is None\nTrue\n\n\nIf it is \u0098accidental-mark', add to mostRecentOrnament, and return None\n>>> turn = expressions.Turn()\n>>> turn.lowerAccidental is None\nTrue\n>>> turn.upperAccidental is None\nTrue\n>>> mxOrn = EL('<accidental-mark placement=\"below\">flat</accidental-mark>')\n>>> a = MP.xmlOrnamentToExpression(mxOrn, mostRecentOrnament=turn)\n>>> a is None\nTrue\n>>> turn.lowerAccidental\n<music21.pitch.Accidental flat>\n>>> turn.upperAccidental is None\nTrue\n\n\nNot supported currently: \u0098vertical-turn'",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "xmlPrint",
        "type": "Title"
    },
    {
        "text": "mxPrint",
        "type": "Title"
    },
    {
        "text": "Element",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "<print> handles changes in pages, numbering, layout,\netc. so can generate PageLayout, SystemLayout, or StaffLayout\nobjects.\nShould also be able to set measure attributes on self.stream",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "xmlSound",
        "type": "Title"
    },
    {
        "text": "mxSound",
        "type": "Title"
    },
    {
        "text": "Element",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Convert a <sound> tag to a relevant object (presently just MetronomeMark),\nand add it to the core and staffReference.",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "xmlStaffLayoutFromStaffDetails",
        "type": "Title"
    },
    {
        "text": "mxDetails",
        "type": "Title"
    },
    {
        "text": "m21staffLayout",
        "type": "Title"
    },
    {
        "text": "StaffLayout | None",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u2192 StaffLayout | None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Returns a new StaffLayout object from staff-details or sets attributes on an existing one\n>>> from xml.etree.ElementTree import fromstring as EL\n>>> MP = musicxml.xmlToM21.MeasureParser()\n>>> mxDetails = EL('<details number=\"2\" print-object=\"no\">'\n...                + '<staff-size>21.2</staff-size><staff-lines>4</staff-lines>'\n...                + '</details>')\n>>> stl = MP.xmlStaffLayoutFromStaffDetails(mxDetails)\n>>> stl.staffSize\n21.2\n>>> stl.staffLines\n4\n>>> stl.staffNumber\n2\n>>> stl.hidden\nTrue\n\n\nstaffType defaults to Regular:\n>>> stl.staffType\n<StaffType.REGULAR: 'regular'>\n>>> mxDetails2 = EL(r'<details number=\"2\"><staff-type>cue</staff-type></details>')\n>>> MP.xmlStaffLayoutFromStaffDetails(mxDetails2, m21staffLayout=stl)\n>>> stl.staffType\n<StaffType.CUE: 'cue'>",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "xmlTechnicalToArticulation",
        "type": "Title"
    },
    {
        "text": "mxObj",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Convert an mxArticulationMark to a music21.articulations.Articulation\nobject or one of its subclasses.\n>>> from xml.etree.ElementTree import fromstring as EL\n>>> MP = musicxml.xmlToM21.MeasureParser()\n\n\n>>> mxTech = EL('<down-bow placement=\"below\"/>')\n>>> a = MP.xmlTechnicalToArticulation(mxTech)\n>>> a\n<music21.articulations.DownBow>\n>>> a.placement\n'below'\n\n\nFingering might have substitution or alternate\n>>> mxTech = EL('<fingering substitution=\"yes\">5</fingering>')\n>>> f = MP.xmlTechnicalToArticulation(mxTech)\n>>> f\n<music21.articulations.Fingering 5>\n>>> f.substitution\nTrue\n>>> f.alternate\nFalse\n\n\nFingerNumbers get converted to ints if possible\n>>> f.fingerNumber\n5\n\n\n>>> mxTech = EL('<fingering alternate=\"yes\">4-3</fingering>')\n>>> f = MP.xmlTechnicalToArticulation(mxTech)\n>>>\n<music21.articulations.Fingering 4-3>\n>>> f.alternate\nTrue\n>>> f.fingerNumber\n'4-3'",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "xmlToAccidental",
        "type": "Title"
    },
    {
        "text": "mxAccidental",
        "type": "Title"
    },
    {
        "text": "Element",
        "type": "Title"
    },
    {
        "text": "inputM21",
        "type": "Title"
    },
    {
        "text": "Accidental | None",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u2192 Accidental",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": ">>> from xml.etree.ElementTree import fromstring as EL\n>>> MP = musicxml.xmlToM21.MeasureParser()\n\n\n>>> a = EL('<accidental parentheses=\"yes\">sharp</accidental>')\n>>> b = MP.xmlToAccidental(a)\n>>> b.name\n'sharp'\n>>> b.alter\n1.0\n>>> b.displayStyle\n'parentheses'\n\n\n>>> a = EL('<accidental>half-flat</accidental>')\n>>> b = pitch.Accidental()\n>>> unused = MP.xmlToAccidental(a, b)\n>>> b.name\n'half-flat'\n>>> b.alter\n-0.5\n\n\n>>> a = EL('<accidental bracket=\"yes\">sharp</accidental>')\n>>> b = MP.xmlToAccidental(a)\n>>> b.displayStyle\n'bracket'\n\n\n>>> a = EL('<accidental bracket=\"yes\" parentheses=\"yes\">sharp</accidental>')\n>>> b = MP.xmlToAccidental(a)\n>>> b.displayStyle\n'both'",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "xmlToArticulation",
        "type": "Title"
    },
    {
        "text": "mxObj",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Return an articulation from an mxObj, setting placement\n>>> from xml.etree.ElementTree import fromstring as EL\n>>> MP = musicxml.xmlToM21.MeasureParser()\n\n\n>>> mxArt = EL('<spiccato placement=\"above\"/>')\n>>> a = MP.xmlToArticulation(mxArt)\n>>> a\n<music21.articulations.Spiccato>\n>>> a.placement\n'above'\n\n\n>>> mxArt = EL('<doit dash-length=\"2\" default-x=\"5\" default-y=\"2\" '\n...            + 'line-shape=\"curved\" line-type=\"dashed\" space-length=\"1\" />')\n>>> a = MP.xmlToArticulation(mxArt)\n>>> a\n<music21.articulations.Doit>\n>>> a.placement is None\nTrue\n>>> a.style.dashLength\n2\n>>> a.style.absoluteX\n5\n>>> a.style.lineShape\n'curved'",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "xmlToBarline",
        "type": "Title"
    },
    {
        "text": "mxBarline",
        "type": "Title"
    },
    {
        "text": "inputM21",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Given an mxBarline, fill the necessary parameters\n>>> import xml.etree.ElementTree as ET\n>>> MP = musicxml.xmlToM21.MeasureParser()\n\n\n>>> mxBarline = ET.fromstring(\n...    '<barline location=\"right\"><bar-style>light-light</bar-style></barline>')\n>>> b = MP.xmlToBarline(mxBarline)\n>>> b\n<music21.bar.Barline type=double>\n>>> b.type  # music21.type is different from musicxml.style\n'double'\n>>> b.location\n'right'",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "xmlToBeam",
        "type": "Title"
    },
    {
        "text": "mxBeam",
        "type": "Title"
    },
    {
        "text": "Element",
        "type": "Title"
    },
    {
        "text": "inputM21",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "given an mxBeam object return a Beam object\n>>> from xml.etree.ElementTree import fromstring as EL\n>>> MP = musicxml.xmlToM21.MeasureParser()\n\n\n>>> mxBeam = EL('<beam>begin</beam>')\n>>> a = MP.xmlToBeam(mxBeam)\n>>> a.type\n'start'\n\n\n>>> mxBeam = EL('<beam>continue</beam>')\n>>> a = MP.xmlToBeam(mxBeam)\n>>> a.type\n'continue'\n\n\n>>> mxBeam = EL('<beam>end</beam>')\n>>> a = MP.xmlToBeam(mxBeam)\n>>> a.type\n'stop'\n\n\n>>> mxBeam = EL('<beam>forward hook    </beam>')\n>>> a = MP.xmlToBeam(mxBeam)\n>>> a.type\n'partial'\n>>> a.direction\n'right'\n\n\n>>> mxBeam = EL('<beam>backward hook</beam>')\n>>> a = MP.xmlToBeam(mxBeam)\n>>> a.type\n'partial'\n>>> a.direction\n'left'\n\n\n>>> mxBeam = EL('<beam>crazy</beam>')\n>>> a = MP.xmlToBeam(mxBeam)\nTraceback (most recent call last):\nmusic21.musicxml.xmlObjects.MusicXMLImportException:\n     unexpected beam type encountered (crazy)",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "xmlToBeams",
        "type": "Title"
    },
    {
        "text": "mxBeamList",
        "type": "Title"
    },
    {
        "text": "inputM21",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "given a list of mxBeam objects, sets the beamsList\n>>> from xml.etree.ElementTree import fromstring as EL\n>>> MP = musicxml.xmlToM21.MeasureParser()\n\n\n>>> mxBeam1 = EL('<beam>begin</beam>')\n>>> mxBeam2 = EL('<beam>begin</beam>')\n>>> mxBeamList = [mxBeam1, mxBeam2]\n>>> b = MP.xmlToBeams(mxBeamList)\n>>> b\n<music21.beam.Beams <music21.beam.Beam 1/start>/<music21.beam.Beam 2/start>>",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "xmlToChord",
        "type": "Title"
    },
    {
        "text": "mxNoteList",
        "type": "Title"
    },
    {
        "text": "list[xml.etree.ElementTree.Element]",
        "type": "Title"
    },
    {
        "text": "\u2192 ChordBase",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Given an a list of mxNotes, fill the necessary parameters\n>>> from xml.etree.ElementTree import fromstring as EL\n>>> MP = musicxml.xmlToM21.MeasureParser()\n>>> MP.divisions = 10080\n\n\n>>> qnDuration = r'<duration>7560</duration><type>quarter</type>'\n\n\n>>> a = EL(r'<note><pitch><step>A</step><octave>3</octave></pitch>'\n...          + qnDuration + '</note>')\n>>> b = EL(r'<note><chord/><pitch><step>B</step><octave>3</octave></pitch>'\n...          + qnDuration + '</note>')\n\n\n>>> c = MP.xmlToChord([a, b])\n>>> len(c.pitches)\n2\n>>> c.pitches[0]\n<music21.pitch.Pitch A3>\n>>> c.pitches[1]\n<music21.pitch.Pitch B3>\n>>> c.duration\n<music21.duration.Duration unlinked type:quarter quarterLength:0.75>\n\n\n>>> a = EL('<note><pitch><step>A</step><octave>3</octave></pitch>'\n...        + qnDuration\n...        + '<notehead>diamond</notehead></note>')\n>>> c = MP.xmlToChord([a, b])\n>>> c.getNotehead(c.pitches[0])\n'diamond'\n\n\n>>> a = EL('<note><unpitched><display-step>A</display-step>'\n...        + '<display-octave>3</display-octave></unpitched>'\n...        + qnDuration\n...        + '<notehead>diamond</notehead></note>')\n>>> MP.xmlToChord([a, b])\n<music21.percussion.PercussionChord [unpitched[A3] B3]>",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "xmlToChordSymbol",
        "type": "Title"
    },
    {
        "text": "mxHarmony",
        "type": "Title"
    },
    {
        "text": "Element",
        "type": "Title"
    },
    {
        "text": "\u2192 ChordSymbol | NoChord | ChordWithFretBoard",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Convert a <harmony> tag to a harmony.ChordSymbol object:\n>>> from xml.etree.ElementTree import fromstring as EL\n>>> MP = musicxml.xmlToM21.MeasureParser()\n\n\n>>> elStr = '<harmony><root><root-step>D</root-step><root-alter>-1</root-alter>'\n>>> elStr += '</root><kind>major-seventh</kind></harmony>'\n>>> mxHarmony = EL(elStr)\n\n\n>>> cs = MP.xmlToChordSymbol(mxHarmony)\n>>> cs\n<music21.harmony.ChordSymbol D-maj7>\n\n\n>>> cs.figure\n'D-maj7'\n\n\n>>> cs.pitches\n(<music21.pitch.Pitch D-3>,\n <music21.pitch.Pitch F3>,\n <music21.pitch.Pitch A-3>,\n <music21.pitch.Pitch C4>)\n\n\n>>> cs.root()\n<music21.pitch.Pitch D-3>\n\n\nTODO: this is very classically-oriented.  Make more Jazz/Rock like possible/default?.\n>>> mxHarmony.find('kind').text = 'major-sixth'\n>>> cs = MP.xmlToChordSymbol(mxHarmony)\n>>> cs\n<music21.harmony.ChordSymbol D-6>\n\n\n>>> cs.figure\n'D-6'\n\n\n>>> cs.pitches\n(<music21.pitch.Pitch D-3>, <music21.pitch.Pitch F3>,\n <music21.pitch.Pitch A-3>, <music21.pitch.Pitch B-3>)\n\n\n>>> cs.root()\n<music21.pitch.Pitch D-3>",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "xmlToClef",
        "type": "Title"
    },
    {
        "text": "mxClef",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Returns a music21 Clef object from an mxClef element.\n>>> import xml.etree.ElementTree as ET\n>>> mxClef = ET.fromstring('<clef><sign>G</sign><line>2</line></clef>')\n\n\n>>> MP = musicxml.xmlToM21.MeasureParser()\n>>> MP.xmlToClef(mxClef)\n<music21.clef.TrebleClef>\n\n\n>>> mxClef = ET.fromstring('<clef><sign>G</sign><line>2</line>'\n...                        + '<clef-octave-change>-1</clef-octave-change></clef>')\n>>> MP.xmlToClef(mxClef)\n<music21.clef.Treble8vbClef>\n\n\n>>> mxClef = ET.fromstring('<clef><sign>TAB</sign></clef>')\n>>> MP.xmlToClef(mxClef)\n<music21.clef.TabClef>",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "xmlToDuration",
        "type": "Title"
    },
    {
        "text": "mxNote",
        "type": "Title"
    },
    {
        "text": "inputM21",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Translate a MusicXML <note> object's\n<duration>, <type>, <dot>, tuplets, etc.\nto a music21 Duration object.\n>>> from xml.etree.ElementTree import fromstring as EL\n>>> MP = musicxml.xmlToM21.MeasureParser()\n\n\n>>> MP.divisions = 10080\n\n\n>>> mxNote = EL('<note><pitch><step>D</step>' +\n...     '<alter>-1</alter><octave>6</octave></pitch>' +\n...     '<duration>7560</duration>' +\n...     '<type>eighth</type><dot/></note>')\n\n\n>>> c = duration.Duration()\n>>> MP.xmlToDuration(mxNote, c)\n>>> c\n<music21.duration.Duration 0.75>\n>>> c.quarterLength\n0.75\n>>> c.type\n'eighth'\n>>> c.dots\n1\n\n\nIf the <duration> doesn't match the <type> and <dots>,\nan unlinked duration is created so that .quarterLength agrees with\n<duration> but the notated types can still be represented.\nCreate a second dot on mxNote and parse again, observing the identical\nquarterLength:\n>>> from xml.etree.ElementTree import SubElement\n>>> unused = SubElement(mxNote, 'dot')\n>>> c2 = MP.xmlToDuration(mxNote)\n>>> c2\n<music21.duration.Duration unlinked type:eighth quarterLength:0.75>\n>>> c2.quarterLength\n0.75\n>>> c2.type\n'eighth'\n>>> c2.dots\n2\n\n\nGrace note durations will be converted later to GraceDurations:\n>>> mxDuration = mxNote.find('duration')\n>>> mxNote.remove(mxDuration)\n>>> mxGrace = SubElement(mxNote, 'grace')\n>>> MP.xmlToDuration(mxNote, inputM21=c2)\n>>> c2\n<music21.duration.Duration unlinked type:eighth quarterLength:0.0>\n>>> gn1 = note.Note(duration=c2)\n>>> gn2 = MP.xmlGraceToGrace(mxGrace, gn1)\n>>> gn2.duration\n<music21.duration.GraceDuration unlinked type:eighth quarterLength:0.0>",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "xmlToKeySignature",
        "type": "Title"
    },
    {
        "text": "mxKey",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Returns either a KeySignature (traditional or non-traditional)\nor a Key object based on whether fifths and mode is present.\n>>> import xml.etree.ElementTree as ET\n>>> mxKey = ET.fromstring('<key><fifths>-4</fifths></key>')\n\n\n>>> MP = musicxml.xmlToM21.MeasureParser()\n>>> MP.xmlToKeySignature(mxKey)\n<music21.key.KeySignature of 4 flats>\n\n\n>>> mxKey = ET.fromstring('<key><fifths>-4</fifths><mode>minor</mode></key>')\n\n\n>>> MP = musicxml.xmlToM21.MeasureParser()\n>>> MP.xmlToKeySignature(mxKey)\n<music21.key.Key of f minor>\n\n\nInvalid modes get ignored and returned as KeySignatures\n>>> mxKey = ET.fromstring('<key><fifths>-4</fifths><mode>crazy</mode></key>')\n\n\n>>> MP = musicxml.xmlToM21.MeasureParser()\n>>> MP.xmlToKeySignature(mxKey)\n<music21.key.KeySignature of 4 flats>",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "xmlToLyric",
        "type": "Title"
    },
    {
        "text": "mxLyric",
        "type": "Title"
    },
    {
        "text": "inputM21",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u2192 Lyric | None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Translate a MusicXML <lyric> tag to a\nmusic21 Lyric object or return None if no Lyric object\nshould be created (empty lyric tags, for instance)\nIf inputM21 is a Lyric object, then the values of the\nmxLyric are transferred there and nothing returned.\nOtherwise, a new Lyric object is created and returned.\n>>> import xml.etree.ElementTree as ET\n>>> MP = musicxml.xmlToM21.MeasureParser()\n\n\n>>> mxLyric = ET.fromstring('<lyric number=\"4\" color=\"red\">'\n...                         + '<syllabic>single</syllabic>'\n...                         + '<text>word</text></lyric>')\n>>> lyricObj = note.Lyric()\n>>> MP.xmlToLyric(mxLyric, lyricObj)\n>>> lyricObj\n<music21.note.Lyric number=4 syllabic=single text='word'>\n>>> lyricObj.style.color\n'red'\n\n\nNon-numeric MusicXML lyric \u009cnumber\u009ds are converted to identifiers:\n>>> mxLyric.set('number', 'part2verse1')\n>>> l2 = MP.xmlToLyric(mxLyric)\n>>> l2\n<music21.note.Lyric number=0 identifier='part2verse1' syllabic=single text='word'>\n\n\nMultiple texts can be created and result in composite lyrics\n>>> mxBianco = ET.fromstring('<lyric>'\n...                         + '<syllabic>end</syllabic>'\n...                         + '<text>co</text>'\n...                         + '<elision>_</elision>'\n...                         + '<syllabic>single</syllabic>'\n...                         + '<text>e</text>'\n...                         + '</lyric>')\n>>> bianco = MP.xmlToLyric(mxBianco)\n>>> bianco\n<music21.note.Lyric number=0 syllabic=composite text='co_e'>\n>>> bianco.components\n[<music21.note.Lyric number=1 syllabic=end text='co'>,\n <music21.note.Lyric number=1 syllabic=single text='e'>]",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "xmlToNote",
        "type": "Title"
    },
    {
        "text": "mxNote",
        "type": "Title"
    },
    {
        "text": "Element",
        "type": "Title"
    },
    {
        "text": "\u2192 None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Handles everything for creating a Note or Rest or Chord\nDoes not actually return the note, but sets self.nLast to the note.\nThis routine uses coreInserts for speed, so it can leave either\nself.stream or a Voice object within self.stream in an unstable state.",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "xmlToOffset",
        "type": "Title"
    },
    {
        "text": "mxObj",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Finds an <offset> inside the mxObj and returns it as\na music21 offset (in quarterLengths)\n>>> from xml.etree.ElementTree import fromstring as EL\n>>> MP = musicxml.xmlToM21.MeasureParser()\n>>> MP.divisions = 40\n>>> off = EL(r'<direction><offset>100</offset></direction>')\n>>> MP.xmlToOffset(off)\n2.5\n\n\nReturns a float, not fraction.\n>>> MP.divisions = 30\n>>> off = EL(r'<direction><offset>10</offset></direction>')\n>>> MP.xmlToOffset(off)\n0.33333...",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "xmlToPitch",
        "type": "Title"
    },
    {
        "text": "mxNote",
        "type": "Title"
    },
    {
        "text": "inputM21",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Given a MusicXML Note object, set this Pitch object to its values.\n>>> from xml.etree.ElementTree import fromstring as EL\n>>> MP = musicxml.xmlToM21.MeasureParser()\n\n\n>>> b = EL('<note><pitch><step>E</step><alter>-1</alter>'\n...        + '<octave>3</octave></pitch></note>')\n>>> a = MP.xmlToPitch(b)\n>>> print(a)\nE-3\n\n\nConflicting alter and accidental \u2014 alter is still stored, but name is :\n>>> b = EL('<note><pitch><step>E</step><alter>-1</alter><octave>3</octave></pitch>'\n...              + '<accidental>sharp</accidental></note>')\n>>> a = MP.xmlToPitch(b)\n>>> print(a)\nE#3\n>>> a.fullName\n'E-sharp in octave 3'\n\n\n>>> a.accidental.alter\n-1.0\n\n\n>>> a.accidental.name\n'sharp'\n\n\n>>> a.accidental.modifier\n'#'",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "xmlToRehearsalMark",
        "type": "Title"
    },
    {
        "text": "mxRehearsal",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Return a rehearsal mark from a rehearsal tag.",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "xmlToRepeat",
        "type": "Title"
    },
    {
        "text": "mxBarline",
        "type": "Title"
    },
    {
        "text": "inputM21",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Given an mxBarline (not an mxRepeat object) with repeatObj as a parameter,\nfile the necessary parameters and return a bar.Repeat() object\n>>> import xml.etree.ElementTree as ET\n>>> MP = musicxml.xmlToM21.MeasureParser()\n\n\n>>> mxBarline = ET.fromstring('<barline><bar-style>light-heavy</bar-style>' +\n...       '<repeat direction=\"backward\"/></barline>')\n>>> r = MP.xmlToRepeat(mxBarline)\n>>> r\n<music21.bar.Repeat direction=end>\n\n\nTest that the music21 type for a backwards repeat is called \u009cfinal\u009d\n(because it resembles a final barline) even though the musicxml style\nis called light-heavy.\n>>> r.type\n'final'\n>>> r.direction\n'end'\n\n\nTest that a forward repeat with times doesn't raise an exception, and\nthat the resulting Repeat doesn't have times set.\n>>> mxStartBarline = ET.fromstring('<barline><bar-style>light-heavy</bar-style>' +\n...       '<repeat direction=\"forward\" times=\"2\"/></barline>')\n>>> rs = MP.xmlToRepeat(mxStartBarline)\n>>> rs\n<music21.bar.Repeat direction=start>",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "xmlToRest",
        "type": "Title"
    },
    {
        "text": "mxRest",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Takes a <note> tag that has been shown to have a <rest> tag in it\nand return a rest.\n>>> from xml.etree.ElementTree import fromstring as EL\n>>> MP = musicxml.xmlToM21.MeasureParser()\n>>> MP.divisions = 10\n\n\n>>> mxr = EL('<note><rest/><duration>5</duration><type>eighth</type></note>')\n>>> r = MP.xmlToRest(mxr)\n>>> r\n<music21.note.Rest eighth>\n>>> r.duration.quarterLength\n0.5\n\n\n>>> mxr = EL('<note><rest><display-step>G</display-step>' +\n...              '<display-octave>4</display-octave>' +\n...              '</rest><duration>5</duration><type>eighth</type></note>')\n>>> r = MP.xmlToRest(mxr)\n>>> r\n<music21.note.Rest eighth>\n\n\nA rest normally lies at B4 in treble clef, but here we have put it at\nG4, so we'll shift it down two steps.\n>>> r.stepShift\n-2\n\n\nClef context matters, here we will set it for notes that don't specify a staff:\n>>> MP.lastClefs[musicxml.xmlToM21.NO_STAFF_ASSIGNED] = clef.BassClef()\n>>> r = MP.xmlToRest(mxr)\n\n\nNow this is a high rest:\n>>> r.stepShift\n10\n\n\nTest full measure rest defined with measure=\u009dyes\u009d and a duration indicating\nfour quarter notes:\n>>> mxr = EL('<note><rest measure=\"yes\"/><duration>40</duration></note>')\n>>> r = MP.xmlToRest(mxr)\n>>> MP.fullMeasureRest\nTrue\n\n\nNote that here set r's .fullMeasure to True or always because it has no type.\n>>> r.fullMeasure\nTrue\n\n\nSame goes for rests which define type of whole (or breve), regardless of duration:\n>>> mxr = EL('<note><rest measure=\"yes\"/><duration>40</duration><type>whole</type></note>')\n>>> r = MP.xmlToRest(mxr)\n>>> MP.fullMeasureRest\nTrue\n>>> r.fullMeasure\nTrue\n\n\nBut a rest that defines measure=\u009dyes\u009d but has a type other than whole or breve\nwill set MeasureParser to fullMeasureRest but not set fullMeasure = True\non the music21 Rest object itself because pickup measures often use\nmeasure=\u009dyes\u009d in Finale, but display as quarter rests, etc.\nSee https://github.com/w3c/musicxml/issues/478\n>>> mxr = EL('<note><rest measure=\"yes\"/><duration>10</duration>'\n...          + '<type>quarter</type></note>')\n>>> r = MP.xmlToRest(mxr)\n>>> MP.fullMeasureRest\nTrue\n>>> r.fullMeasure\n'auto'",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "xmlToSimpleNote",
        "type": "Title"
    },
    {
        "text": "mxNote",
        "type": "Title"
    },
    {
        "text": "freeSpanners",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "\u2192 Note | Unpitched",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Translate a MusicXML <note> (without <chord/>)\nto a Note.\nThe spannerBundle parameter can be a list or a Stream\nfor storing and processing Spanner objects.\nif freeSpanners is False then pending spanners will not be freed.\n>>> from xml.etree.ElementTree import fromstring as EL\n>>> MP = musicxml.xmlToM21.MeasureParser()\n\n\n>>> MP.divisions = 10080\n\n\n>>> mxNote = EL('<note pizzicato=\"yes\"><pitch><step>D</step>'\n...             + '<alter>-1</alter><octave>6</octave></pitch>'\n...             + '<duration>7560</duration>'\n...             + '<type>eighth</type><dot/></note>')\n\n\n>>> n = MP.xmlToSimpleNote(mxNote)\n>>> n\n<music21.note.Note D->\n>>> n.octave\n6\n>>> n.duration\n<music21.duration.Duration 0.75>\n>>> n.articulations\n[<music21.articulations.Pizzicato>]\n\n\n>>> beams = EL('<beam>begin</beam>')\n>>> mxNote.append(beams)\n>>> n = MP.xmlToSimpleNote(mxNote)\n>>> n.beams\n<music21.beam.Beams <music21.beam.Beam 1/start>>\n\n\n>>> stem = EL('<stem>up</stem>')\n>>> mxNote.append(stem)\n>>> n = MP.xmlToSimpleNote(mxNote)\n>>> n.stemDirection\n'up'\n\n\n# TODO: beams over rests?",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "xmlToTempoIndication",
        "type": "Title"
    },
    {
        "text": "mxMetronome",
        "type": "Title"
    },
    {
        "text": "mxWords",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Given an mxMetronome, convert to either a TempoIndication subclass,\neither a tempo.MetronomeMark or tempo.MetricModulation.\n>>> from xml.etree.ElementTree import fromstring as EL\n>>> MP = musicxml.xmlToM21.MeasureParser()\n\n\n>>> m = EL(r'<metronome><per-minute>125</per-minute>' +\n...         '<beat-unit>half</beat-unit></metronome>')\n>>> MP.xmlToTempoIndication(m)\n<music21.tempo.MetronomeMark Half=125>\n\n\nMetric modulation:\n>>> m = EL(r'<metronome><beat-unit>long</beat-unit><beat-unit>32nd</beat-unit>' +\n...         '<beat-unit-dot/></metronome>')\n>>> MP.xmlToTempoIndication(m)\n<music21.tempo.MetricModulation\n <music21.tempo.MetronomeMark Imperfect Longa=None>=<music21.tempo.MetronomeMark\n           Dotted 32nd=None>>",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "xmlToTextExpression",
        "type": "Title"
    },
    {
        "text": "mxWords",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Given an mxWords, create a TextExpression\nand set style attributes, fonts, position, etc.\nCalls setTextFormatting, which calls setPrintStyleAlign.\n>>> from xml.etree.ElementTree import fromstring as EL\n>>> MP = musicxml.xmlToM21.MeasureParser()\n>>> m = EL('<words default-y=\"17\" font-family=\"Courier\" ' +\n... 'font-style=\"italic\" relative-x=\"-6\">a tempo</words>')\n>>> te = MP.xmlToTextExpression(m)\n>>> te.content\n'a tempo'\n>>> te.style.relativeX\n-6\n>>> te.style.fontFamily\n['Courier']",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "xmlToTie",
        "type": "Title"
    },
    {
        "text": "mxNote",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Translate a MusicXML <note> with <tie> SubElements\nTie object\n>>> import xml.etree.ElementTree as ET\n>>> MP = musicxml.xmlToM21.MeasureParser()\n\n\nCreate the incomplete part of a Note.\n>>> mxNote = ET.fromstring('<note><tie type=\"start\" />'\n...            + '<notations>'\n...            + '<tied line-type=\"dotted\" placement=\"below\" type=\"start\" />'\n...            + '</notations></note>')\n>>> m21Tie = MP.xmlToTie(mxNote)\n>>> m21Tie.type\n'start'\n>>> m21Tie.style\n'dotted'\n>>> m21Tie.placement\n'below'\n\n\nSame thing but with orientation instead of placement, which both get mapped to\nplacement in Tie objects\n>>> mxNote = ET.fromstring('<note><tie type=\"start\" />'\n...            + '<notations>'\n...            + '<tied line-type=\"dotted\" orientation=\"over\" type=\"start\" />'\n...            + '</notations></note>')\n>>> tieObj = MP.xmlToTie(mxNote)\n>>> tieObj.placement\n'above'",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "xmlToTimeSignature",
        "type": "Title"
    },
    {
        "text": "mxTime",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Returns a TimeSignature or SenzaMisuraTimeSignature (for senza-misura)\nfrom a <time> block.\n>>> import xml.etree.ElementTree as ET\n>>> MP = musicxml.xmlToM21.MeasureParser()\n\n\n>>> mxTime = ET.fromstring('<time><beats>3</beats><beat-type>8</beat-type></time>')\n>>> MP.xmlToTimeSignature(mxTime)\n<music21.meter.TimeSignature 3/8>\n\n\n>>> mxTime = ET.fromstring('<time symbol=\"common\"><beats>4</beats>' +\n...                                              '<beat-type>4</beat-type></time>')\n>>> MP.xmlToTimeSignature(mxTime).symbol\n'common'\n\n\nMultiple times:\n>>> mxTime = ET.fromstring('<time><beats>3</beats><beat-type>8</beat-type>' +\n...                              '<beats>4</beats><beat-type>4</beat-type></time>')\n>>> MP.xmlToTimeSignature(mxTime)\n<music21.meter.TimeSignature 3/8+4/4>\n\n\n>>> mxTime = ET.fromstring('<time><beats>3+2</beats><beat-type>8</beat-type></time>')\n>>> ts32 = MP.xmlToTimeSignature(mxTime)\n>>> ts32\n<music21.meter.TimeSignature 3/8+2/8>\n\n\nSenza Misura\n>>> mxSenza = ET.fromstring('<time><senza-misura>0</senza-misura></time>')\n>>> MP.xmlToTimeSignature(mxSenza)\n<music21.meter.SenzaMisuraTimeSignature 0>\n\n\nSmall Duration Time Signatures\n>>> mxTime = ET.fromstring('<time><beats>3</beats><beat-type>32</beat-type></time>')\n>>> MP.xmlToTimeSignature(mxTime)\n<music21.meter.TimeSignature 3/32>\n\n\n>>> mxTime = ET.fromstring('<time><beats>3</beats><beat-type>64</beat-type></time>')\n>>> MP.xmlToTimeSignature(mxTime)\n<music21.meter.TimeSignature 3/64>\n\n\n>>> mxTime = ET.fromstring('<time><beats>3</beats><beat-type>128</beat-type></time>')\n>>> MP.xmlToTimeSignature(mxTime)\n<music21.meter.TimeSignature 3/128>",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "xmlToTremolo",
        "type": "Title"
    },
    {
        "text": "mxTremolo",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Converts an mxTremolo to either an expression to be added to n.expressions\nor to a spanner, returning either.",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "xmlToTuplets",
        "type": "Title"
    },
    {
        "text": "mxNote",
        "type": "Title"
    },
    {
        "text": "Element",
        "type": "Title"
    },
    {
        "text": "\u2192 list[music21.duration.Tuplet]",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Given an mxNote, based on mxTimeModification\nand mxTuplet objects, return a list of Tuplet objects\n>>> import xml.etree.ElementTree as ET\n>>> MP = musicxml.xmlToM21.MeasureParser()\n\n\n>>> mxNote = ET.fromstring('<note><type>16th</type>' +\n...    '<time-modification><actual-notes>5</actual-notes>' +\n...    '<normal-notes>4</normal-notes></time-modification></note>')\n>>> tups = MP.xmlToTuplets(mxNote)\n>>> tups\n[<music21.duration.Tuplet 5/4/16th>]\n\n\n>>> mxNote = ET.fromstring('<note><type>eighth</type>' +\n...    '<time-modification><actual-notes>5</actual-notes>' +\n...    '<normal-notes>3</normal-notes>' +\n...    '<normal-type>16th</normal-type><normal-dot /><normal-dot />' +\n...    '</time-modification></note>')\n>>> tup = MP.xmlToTuplets(mxNote)\n>>> tup\n[<music21.duration.Tuplet 5/3/16th>]\n>>> tup[0].durationNormal\nDurationTuple(type='16th', dots=2, quarterLength=0.4375)",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "xmlToUnpitched",
        "type": "NarrativeText"
    },
    {
        "text": "mxUnpitched",
        "type": "NarrativeText"
    },
    {
        "text": "Element",
        "type": "Title"
    },
    {
        "text": "inputM21",
        "type": "Title"
    },
    {
        "text": "Unpitched | None",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u2192 Unpitched",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Set displayStep and displayOctave from mxUnpitched.\n>>> from xml.etree.ElementTree import fromstring as EL\n>>> MP = musicxml.xmlToM21.MeasureParser()\n>>> MP.divisions = 10080\n\n\n>>> mxNote = EL('<note><duration>7560</duration><type>eighth</type></note>')\n>>> unpitched = EL('<unpitched>'\n...                + '<display-step>E</display-step>'\n...                + '<display-octave>5</display-octave>'\n...                + '</unpitched>')\n>>> mxNote.append(unpitched)\n>>> n = MP.xmlToSimpleNote(mxNote)\n>>> n.displayStep\n'E'\n>>> n.displayOctave\n5\n>>> n.displayPitch().midi\n76",
        "type": "ListItem"
    },
    {
        "text": "MeasureParser.",
        "type": "Title"
    },
    {
        "text": "xmlTransposeToInterval",
        "type": "Title"
    },
    {
        "text": "mxTranspose",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Convert a MusicXML Transpose object to a music21 Interval object.\n>>> import xml.etree.ElementTree as ET\n>>> MP = musicxml.xmlToM21.MeasureParser()\n\n\n>>> t = ET.fromstring('<transpose><diatonic>-1</diatonic>'\n...                   + '<chromatic>-2</chromatic></transpose>')\n>>> MP.xmlTransposeToInterval(t)\n<music21.interval.Interval M-2>\n\n\n>>> t = ET.fromstring('<transpose><diatonic>-5</diatonic>'\n...                   + '<chromatic>-9</chromatic></transpose>')\n>>> MP.xmlTransposeToInterval(t)\n<music21.interval.Interval M-6>\n\n\nNot mentioned in MusicXML XSD but supported in (Finale; MuseScore): octave-change\nrefers to both diatonic and chromatic, so we will deal\u2026\n>>> t = ET.fromstring('<transpose id=\"x\"><diatonic>-1</diatonic><chromatic>-2</chromatic>'\n...         + '<octave-change>-1</octave-change></transpose>')\n>>> inv = MP.xmlTransposeToInterval(t)\n>>> inv\n<music21.interval.Interval M-9>\n>>> inv.id\n'x'",
        "type": "ListItem"
    },
    {
        "text": "Methods inherited from XMLParserBase:",
        "type": "NarrativeText"
    },
    {
        "text": "setColor() setEditorial() setFont() setLineStyle() setPlacement() setPosition() setPrintObject() setPrintStyle() setPrintStyleAlign() setStyleAttributes() setTextFormatting() xmlPageLayoutToPageLayout() xmlPrintToPageLayout() xmlPrintToSystemLayout() xmlStaffLayoutToStaffLayout() xmlSystemLayoutToSystemLayout()",
        "type": "Table"
    },
    {
        "text": "MusicXMLImporter\u00c2\u00b6",
        "type": "Title"
    },
    {
        "text": "class",
        "type": "Title"
    },
    {
        "text": "music21.musicxml.xmlToM21.",
        "type": "Title"
    },
    {
        "text": "MusicXMLImporter",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Object for importing .xml, .mxl, .musicxml, MusicXML files into music21.",
        "type": "ListItem"
    },
    {
        "text": "MusicXMLImporter bases",
        "type": "Title"
    },
    {
        "text": "XMLParserBase",
        "type": "ListItem"
    },
    {
        "text": "MusicXMLImporter methods",
        "type": "Title"
    },
    {
        "text": "MusicXMLImporter.",
        "type": "Title"
    },
    {
        "text": "creatorToContributor",
        "type": "Title"
    },
    {
        "text": "creator",
        "type": "Title"
    },
    {
        "text": "Element",
        "type": "Title"
    },
    {
        "text": "inputM21",
        "type": "Title"
    },
    {
        "text": "Contributor | None",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Given a <creator> tag, fill the necessary parameters of a Contributor.\n>>> import xml.etree.ElementTree as ET\n>>> creator = ET.fromstring('<creator type=\"composer\">Beethoven, Ludwig van</creator>')\n\n\n>>> MI = musicxml.xmlToM21.MusicXMLImporter()\n>>> c = MI.creatorToContributor(creator)\n>>> c\n<music21.metadata.primitives.Contributor composer:Beethoven, Ludwig van>\n>>> c.role\n'composer'\n>>> c.name\n'Beethoven, Ludwig van'\n\n\nPass in a Contributor object and set it\u2026\n>>> c2 = metadata.Contributor()\n>>> MI.creatorToContributor(creator, c2)\n>>> c2.role\n'composer'",
        "type": "ListItem"
    },
    {
        "text": "MusicXMLImporter.",
        "type": "Title"
    },
    {
        "text": "identificationToMetadata",
        "type": "Title"
    },
    {
        "text": "identification",
        "type": "Title"
    },
    {
        "text": "Element",
        "type": "Title"
    },
    {
        "text": "inputM21",
        "type": "Title"
    },
    {
        "text": "Metadata | None",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Convert an <identification> tag, containing <creator> tags, <rights> tags, and\n<miscellaneous> tag.\nNot supported: source, relation\nOnly the first <rights> tag is supported\nEncoding only parses \u009csupports\u009d and that only has\nnew-system (definesExplicitSystemBreaks) and\nnew-page (definesExplicitPageBreaks)",
        "type": "ListItem"
    },
    {
        "text": "static",
        "type": "Title"
    },
    {
        "text": "MusicXMLImporter.",
        "type": "Title"
    },
    {
        "text": "isRecognizableMetadataKey",
        "type": "Title"
    },
    {
        "text": "miscFieldName",
        "type": "Title"
    },
    {
        "text": "str",
        "type": "Title"
    },
    {
        "text": "\u2192 bool",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Returns bool on whether miscFieldName is a one of the names\nthat is among the list of names we might see in <miscellaneous>,\nthat this parser will interpret as supported metadata keys.\nCurrently, this is all the uniqueName keys (e.g. \u0098dateCreated'),\nthe \u0098namespace:name' keys (e.g. \u0098dcterms:created'),\nand the pre-v8 music21 workIds (e.g. \u0098date').\n>>> MI = musicxml.xmlToM21.MusicXMLImporter()\n>>> MI.isRecognizableMetadataKey('dateCreated')\nTrue\n>>> MI.isRecognizableMetadataKey('dcterms:created')\nTrue\n>>> MI.isRecognizableMetadataKey('dateDestroyed')\nFalse",
        "type": "ListItem"
    },
    {
        "text": "MusicXMLImporter.",
        "type": "Title"
    },
    {
        "text": "parsePartList",
        "type": "Title"
    },
    {
        "text": "mxScore",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Parses the <part-list> tag and adds\n<score-part> entries into self.mxScorePartDict[partId]\nand adds them to any open <part-group> entries,\nstored as PartGroup objects in self.partGroupList",
        "type": "ListItem"
    },
    {
        "text": "MusicXMLImporter.",
        "type": "Title"
    },
    {
        "text": "parseXMLText",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "",
        "type": "ListItem"
    },
    {
        "text": "MusicXMLImporter.",
        "type": "Title"
    },
    {
        "text": "partGroups",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "set StaffGroup objects from the <part-group> tags.",
        "type": "ListItem"
    },
    {
        "text": "MusicXMLImporter.",
        "type": "Title"
    },
    {
        "text": "processEncoding",
        "type": "NarrativeText"
    },
    {
        "text": "encoding",
        "type": "NarrativeText"
    },
    {
        "text": "Element",
        "type": "Title"
    },
    {
        "text": "md",
        "type": "Title"
    },
    {
        "text": "Metadata",
        "type": "Title"
    },
    {
        "text": "\u2192 None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Process all information in the <encoding> element and put it into the\nMetadata object passed in as md.\nCurrently only processes \u0098software' and these supports attributes:\n\n\nnew-system = Metadata.definesExplicitSystemBreaks\nnew-page = Metadata.definesExplicitPageBreaks",
        "type": "ListItem"
    },
    {
        "text": "MusicXMLImporter.",
        "type": "Title"
    },
    {
        "text": "readFile",
        "type": "Title"
    },
    {
        "text": "filename",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "",
        "type": "ListItem"
    },
    {
        "text": "MusicXMLImporter.",
        "type": "Title"
    },
    {
        "text": "rightsToCopyright",
        "type": "Title"
    },
    {
        "text": "rights",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Given a <rights> tag, fill the necessary parameters of a\nCopyright object.\n>>> import xml.etree.ElementTree as ET\n>>> rights = ET.fromstring('<rights type=\"owner\">CC-SA-BY</rights>')\n\n\n>>> MI = musicxml.xmlToM21.MusicXMLImporter()\n>>> c = MI.rightsToCopyright(rights)\n>>> c\n<music21.metadata.primitives.Copyright CC-SA-BY>\n>>> c.role\n'owner'\n>>> str(c)\n'CC-SA-BY'",
        "type": "ListItem"
    },
    {
        "text": "MusicXMLImporter.",
        "type": "Title"
    },
    {
        "text": "scoreFromFile",
        "type": "Title"
    },
    {
        "text": "filename",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "main program: opens a file given by filename and returns a complete\nmusic21 Score from it.",
        "type": "ListItem"
    },
    {
        "text": "MusicXMLImporter.",
        "type": "Title"
    },
    {
        "text": "styleFromXmlDefaults",
        "type": "Title"
    },
    {
        "text": "mxDefaults",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Set the appearance and font information from mxDefault\n<appearance>, <music-font>, <word-font>, <lyric-font> (multiple),\nand <lyric-language> tags.\nHere the demo does not include the <appearance> tag since that is\ndocumented in xmlAppearanceToStyle\n>>> import xml.etree.ElementTree as ET\n>>> defaults = ET.fromstring('<defaults>'\n...          + '<music-font font-family=\"Maestro, Opus\" font-weight=\"bold\" />'\n...          + '<word-font font-family=\"Garamond\" font-style=\"italic\" />'\n...          + '<lyric-font name=\"verse\" font-size=\"12\" />'\n...          + '<lyric-font name=\"chorus\" font-size=\"14\" />'\n...          + '<lyric-language name=\"verse\" xml:lang=\"fr\" />'\n...          + '<lyric-language name=\"chorus\" xml:lang=\"en\" />'\n...          + '</defaults>')\n\n\n>>> MI = musicxml.xmlToM21.MusicXMLImporter()\n>>> MI.styleFromXmlDefaults(defaults)\n>>> st = MI.stream.style\n>>> st.musicFont\n<music21.style.TextStyle object at 0x10535c0f0>\n>>> st.musicFont.fontFamily\n['Maestro', 'Opus']\n>>> st.musicFont.fontWeight\n'bold'\n>>> st.wordFont.fontFamily\n['Garamond']\n>>> st.wordFont.fontStyle\n'italic'\n>>> len(st.lyricFonts)\n2\n>>> st.lyricFonts[0]\n('verse', <music21.style.TextStyle object at 0x10535d438>)\n>>> st.lyricFonts[0][1].fontSize\n12\n>>> st.lyricLanguages\n[('verse', 'fr'), ('chorus', 'en')]",
        "type": "ListItem"
    },
    {
        "text": "MusicXMLImporter.",
        "type": "Title"
    },
    {
        "text": "xmlAppearanceToStyle",
        "type": "Title"
    },
    {
        "text": "mxAppearance",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Parse the appearance tag for information about line widths and note sizes\n>>> import xml.etree.ElementTree as ET\n>>> appear = ET.fromstring('<appearance>'\n...          + '<line-width type=\"beam\">5</line-width>'\n...          + '<line-width type=\"ledger\">1.5625</line-width>'\n...          + '<note-size type=\"grace\">60</note-size>'\n...          + '<distance type=\"hyphen\">0.5</distance>'\n...          + '<other-appearance type=\"sharps\">dotted</other-appearance>'\n...          + '</appearance>')\n\n\n>>> MI = musicxml.xmlToM21.MusicXMLImporter()\n>>> MI.xmlAppearanceToStyle(appear)\n>>> st = MI.stream.style\n\n\n>>> st.lineWidths\n[('beam', 5), ('ledger', 1.5625)]\n\n\n>>> st.noteSizes\n[('grace', 60)]\n\n\n>>> st.distances\n[('hyphen', 0.5)]\n\n\n>>> st.otherAppearances\n[('sharps', 'dotted')]",
        "type": "ListItem"
    },
    {
        "text": "MusicXMLImporter.",
        "type": "Title"
    },
    {
        "text": "xmlCreditToTextBox",
        "type": "Title"
    },
    {
        "text": "mxCredit",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Convert a MusicXML credit to a music21 TextBox\n>>> import xml.etree.ElementTree as ET\n>>> credit = ET.fromstring(\n...               '<credit page=\"2\"><credit-words>Testing</credit-words></credit>')\n\n\n>>> MI = musicxml.xmlToM21.MusicXMLImporter()\n>>> tb = MI.xmlCreditToTextBox(credit)\n>>> tb.page\n2\n>>> tb.content\n'Testing'",
        "type": "ListItem"
    },
    {
        "text": "MusicXMLImporter.",
        "type": "Title"
    },
    {
        "text": "xmlDefaultsToScoreLayout",
        "type": "Title"
    },
    {
        "text": "mxDefaults",
        "type": "Title"
    },
    {
        "text": "inputM21",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Convert a <defaults> tag to a ScoreLayout\nobject",
        "type": "ListItem"
    },
    {
        "text": "MusicXMLImporter.",
        "type": "Title"
    },
    {
        "text": "xmlMetadata",
        "type": "Title"
    },
    {
        "text": "el",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "inputM21",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Converts part of the root element into a metadata object\nSupported: work-title, work-number, opus, movement-number,\nmovement-title, identification",
        "type": "ListItem"
    },
    {
        "text": "MusicXMLImporter.",
        "type": "Title"
    },
    {
        "text": "xmlPartToPart",
        "type": "Title"
    },
    {
        "text": "mxPart",
        "type": "Title"
    },
    {
        "text": "mxScorePart",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Given a <part> object and the <score-part> object, parse a complete part.",
        "type": "ListItem"
    },
    {
        "text": "MusicXMLImporter.",
        "type": "Title"
    },
    {
        "text": "xmlRootToScore",
        "type": "Title"
    },
    {
        "text": "mxScore",
        "type": "Title"
    },
    {
        "text": "inputM21",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "parse an xml file into a Score() object.",
        "type": "ListItem"
    },
    {
        "text": "Methods inherited from XMLParserBase:",
        "type": "NarrativeText"
    },
    {
        "text": "setColor() setEditorial() setFont() setLineStyle() setPlacement() setPosition() setPrintObject() setPrintStyle() setPrintStyleAlign() setStyleAttributes() setTextFormatting() xmlPageLayoutToPageLayout() xmlPrintToPageLayout() xmlPrintToSystemLayout() xmlStaffLayoutToStaffLayout() xmlSystemLayoutToSystemLayout()",
        "type": "Table"
    },
    {
        "text": "PartGroup\u00c2\u00b6",
        "type": "Title"
    },
    {
        "text": "class",
        "type": "Title"
    },
    {
        "text": "music21.musicxml.xmlToM21.",
        "type": "Title"
    },
    {
        "text": "PartGroup",
        "type": "Title"
    },
    {
        "text": "mxPartGroup",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Small helper class for keeping track of part-groups from XML since they\nare converted to StaffGroup spanners much later.",
        "type": "ListItem"
    },
    {
        "text": "PartGroup methods",
        "type": "Title"
    },
    {
        "text": "PartGroup.",
        "type": "Title"
    },
    {
        "text": "add",
        "type": "NarrativeText"
    },
    {
        "text": "partGroupId",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Add a partGroupId to self.partGroupIds",
        "type": "ListItem"
    },
    {
        "text": "PartParser\u00c2\u00b6",
        "type": "Title"
    },
    {
        "text": "class",
        "type": "Title"
    },
    {
        "text": "music21.musicxml.xmlToM21.",
        "type": "Title"
    },
    {
        "text": "PartParser",
        "type": "Title"
    },
    {
        "text": "mxPart",
        "type": "Title"
    },
    {
        "text": "Element | None",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "mxScorePart",
        "type": "Title"
    },
    {
        "text": "Element | None",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "parent",
        "type": "Title"
    },
    {
        "text": "MusicXMLImporter | None",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "parser to work with a single <part> tag.\ncalled out for multiprocessing potential in future",
        "type": "ListItem"
    },
    {
        "text": "PartParser bases",
        "type": "Title"
    },
    {
        "text": "XMLParserBase",
        "type": "ListItem"
    },
    {
        "text": "PartParser methods",
        "type": "Title"
    },
    {
        "text": "PartParser.",
        "type": "Title"
    },
    {
        "text": "adjustTimeAttributesFromMeasure",
        "type": "Title"
    },
    {
        "text": "Measure",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Adds padAsAnacrusis to pickup measures and other measures that\ndo not fill the whole tile, if the first measure of the piece, or\nimmediately follows an incomplete measure (such as a repeat sign mid-measure\nin a piece where each phrase begins with a pickup and ends with an\nincomplete measure).\nFills an empty measure with a measure of rest (bug in PDFtoMusic and\nother MusicXML writers).\nSets self.lastMeasureWasShort to True or False if it is an incomplete measure\nthat is not a pickup and sets paddingRight.\n>>> m = stream.Measure([meter.TimeSignature('4/4'), harmony.ChordSymbol('C7')])\n>>> m.highestTime\n0.0\n>>> PP = musicxml.xmlToM21.PartParser()\n>>> PP.setLastMeasureInfo(m)\n>>> PP.adjustTimeAttributesFromMeasure(m)\n>>> m.highestTime\n4.0\n>>> PP.lastMeasureWasShort\nFalse\n\n\nIncomplete final measure:\n>>> m = stream.Measure([meter.TimeSignature('6/8'), note.Note(), note.Note()])\n>>> m.offset = 24.0\n>>> PP = musicxml.xmlToM21.PartParser()\n>>> PP.lastMeasureOffset = 21.0\n>>> PP.setLastMeasureInfo(m)\n>>> PP.adjustTimeAttributesFromMeasure(m)\n>>> m.paddingRight\n1.0",
        "type": "ListItem"
    },
    {
        "text": "PartParser.",
        "type": "Title"
    },
    {
        "text": "applyMultiMeasureRest",
        "type": "Title"
    },
    {
        "text": "Rest",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "If there is an active MultiMeasureRestSpanner, add the Rest, r, to it:\n>>> PP = musicxml.xmlToM21.PartParser()\n>>> mmrSpanner = spanner.MultiMeasureRest()\n>>> mmrSpanner\n<music21.spanner.MultiMeasureRest 0 measures>\n\n\n>>> PP.activeMultiMeasureRestSpanner = mmrSpanner\n>>> PP.multiMeasureRestsToCapture = 2\n>>> r1 = note.Rest(type='whole', id='r1')\n>>> PP.applyMultiMeasureRest(r1)\n>>> PP.multiMeasureRestsToCapture\n1\n>>> PP.activeMultiMeasureRestSpanner\n<music21.spanner.MultiMeasureRest 1 measure>\n\n\n>>> PP.activeMultiMeasureRestSpanner is mmrSpanner\nTrue\n>>> PP.stream.show('text')  # Nothing...\n\n\n>>> r2 = note.Rest(type='whole', id='r2')\n>>> PP.applyMultiMeasureRest(r2)\n>>> PP.multiMeasureRestsToCapture\n0\n>>> PP.activeMultiMeasureRestSpanner is None\nTrue\n\n\n# spanner added to stream\n>>> PP.stream.show('text')\n{0.0} <music21.spanner.MultiMeasureRest 2 measures>\n\n\n>>> r3 = note.Rest(type='whole', id='r3')\n>>> PP.applyMultiMeasureRest(r3)\n>>> PP.stream.show('text')\n{0.0} <music21.spanner.MultiMeasureRest 2 measures>",
        "type": "ListItem"
    },
    {
        "text": "PartParser.",
        "type": "Title"
    },
    {
        "text": "getDefaultInstrument",
        "type": "Title"
    },
    {
        "text": "mxScorePart",
        "type": "Title"
    },
    {
        "text": "Element | None",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u2192 Instrument",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Get a default instrument from the mxScorePart tag.\n>>> scorePart = ('<score-part id=\"P4\"><part-name>Bass</part-name>'\n...     + '<part-abbreviation>B.</part-abbreviation>'\n...     + '<score-instrument id=\"P4-I4\">'\n...     + '    <instrument-name>Instrument 4</instrument-name>'\n...     + '</score-instrument>'\n...     + '<midi-instrument id=\"P4-I4\">'\n...     + '   <midi-channel>4</midi-channel>'\n...     + '<midi-program>1</midi-program>'\n...     + '</midi-instrument>'\n...     + '</score-part>')\n>>> from xml.etree.ElementTree import fromstring as EL\n>>> PP = musicxml.xmlToM21.PartParser()\n\n\n>>> mxScorePart = EL(scorePart)\n>>> i = PP.getDefaultInstrument(mxScorePart)\n>>> i\n<music21.instrument.Instrument ': Instrument 4'>\n>>> i.instrumentName\n'Instrument 4'\n\n\nNon-default transpositions captured as of v7.3:\n>>> scorePart = ('<score-part id=\"P5\"><part-name>C Trumpet</part-name>'\n...     + '<part-abbreviation>C Tpt.</part-abbreviation>'\n...     + '<score-instrument id=\"P5-I5\">'\n...     + '    <instrument-name>C Trumpet</instrument-name>'\n...     + '</score-instrument>'\n...     + '<midi-instrument id=\"P5-I5\">'\n...     + '   <midi-channel>2</midi-channel>'\n...     + '<midi-program>57</midi-program>'\n...     + '</midi-instrument>'\n...     + '</score-part>')\n>>> from xml.etree.ElementTree import fromstring as EL\n>>> PP = musicxml.xmlToM21.PartParser()\n\n\n>>> mxScorePart = EL(scorePart)\n>>> i = PP.getDefaultInstrument(mxScorePart)\n>>> i\n<music21.instrument.Trumpet ': C Trumpet'>\n>>> i.instrumentName\n'C Trumpet'\n>>> i.transposition\n<music21.interval.Interval P1>",
        "type": "ListItem"
    },
    {
        "text": "PartParser.",
        "type": "Title"
    },
    {
        "text": "parse",
        "type": "Title"
    },
    {
        "text": "\u2192 None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Run the parser on a single part",
        "type": "ListItem"
    },
    {
        "text": "PartParser.",
        "type": "Title"
    },
    {
        "text": "parseMeasures",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Parse each <measure> tag using self.xmlMeasureToMeasure",
        "type": "ListItem"
    },
    {
        "text": "PartParser.",
        "type": "Title"
    },
    {
        "text": "parseXmlScorePart",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "The <score-part> tag contains a lot of information about the\nPart itself.  It was found in the <part-list> in the ScoreParser but\nwas not parsed and instead passed into the PartParser as .mxScorePart.\nSets the stream.partName, stream.partAbbreviation, self.activeInstrument,\nand inserts an instrument at the beginning of the stream.\nThe instrumentObj being configured comes from self.getDefaultInstrument.",
        "type": "ListItem"
    },
    {
        "text": "static",
        "type": "Title"
    },
    {
        "text": "PartParser.",
        "type": "Title"
    },
    {
        "text": "reclassifyInstrumentFromName",
        "type": "Title"
    },
    {
        "text": "Instrument",
        "type": "Title"
    },
    {
        "text": "mxScoreInstrument",
        "type": "Title"
    },
    {
        "text": "Element",
        "type": "Title"
    },
    {
        "text": "\u2192 Instrument",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "",
        "type": "ListItem"
    },
    {
        "text": "PartParser.",
        "type": "Title"
    },
    {
        "text": "removeEndForwardRest",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "If the last measure ended with a forward tag, as happens\nin some pieces that end with incomplete measures,\nand voices are not involved,\nremove the rest there (for backwards compatibility, esp.\nsince bwv66.6 uses it)\n\nNew in v7.",
        "type": "ListItem"
    },
    {
        "text": "PartParser.",
        "type": "Title"
    },
    {
        "text": "separateOutPartStaves",
        "type": "Title"
    },
    {
        "text": "\u2192 list[music21.stream.base.PartStaff]",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Take a Part with multiple staves and make them a set of PartStaff objects.\nThere must be more than one staff to do this.",
        "type": "ListItem"
    },
    {
        "text": "PartParser.",
        "type": "Title"
    },
    {
        "text": "setLastMeasureInfo",
        "type": "Title"
    },
    {
        "text": "Measure",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Sets self.lastMeasureNumber and self.lastMeasureSuffix from the measure,\nwhich is used in fixing Finale unnumbered measure issues.\nAlso sets self.lastTimeSignature from the timeSignature found in\nthe measure, if any.\n>>> PP = musicxml.xmlToM21.PartParser()\n\n\nHere are the defaults:\n>>> PP.lastMeasureNumber\n0\n>>> PP.lastNumberSuffix is None\nTrue\n>>> PP.lastTimeSignature is None\nTrue\n\n\nAfter setLastMeasureInfo:\n>>> m = stream.Measure(number=4)\n>>> m.numberSuffix = 'b'\n>>> ts38 = meter.TimeSignature('3/8')\n>>> m.timeSignature = ts38\n>>> PP.setLastMeasureInfo(m)\n\n\n>>> PP.lastMeasureNumber\n4\n>>> PP.lastNumberSuffix\n'b'\n>>> PP.lastTimeSignature\n<music21.meter.TimeSignature 3/8>\n>>> PP.lastTimeSignature is ts38\nTrue\n\n\nNote that if there was no timeSignature defined in m,\nand no lastTimeSignature exists,\nthe PartParser gets a default of 4/4, because\nafter the first measure there's going to be routines\nthat need some sort of time signature:\n>>> PP2 = musicxml.xmlToM21.PartParser()\n>>> m2 = stream.Measure(number=2)\n>>> PP2.setLastMeasureInfo(m2)\n>>> PP2.lastTimeSignature\n<music21.meter.TimeSignature 4/4>\n\n\nFor obscure reasons relating to how Finale gives suffixes\nto unnumbered measures, if a measure has the same number\nas the lastMeasureNumber, the lastNumberSuffix is not updated:\n>>> PP3 = musicxml.xmlToM21.PartParser()\n>>> PP3.lastMeasureNumber = 10\n>>> PP3.lastNumberSuffix = 'X1'\n\n\n>>> m10 = stream.Measure(number=10)\n>>> m10.numberSuffix = 'X2'\n>>> PP3.setLastMeasureInfo(m10)\n>>> PP3.lastNumberSuffix\n'X1'",
        "type": "ListItem"
    },
    {
        "text": "PartParser.",
        "type": "Title"
    },
    {
        "text": "updateTransposition",
        "type": "Title"
    },
    {
        "text": "newTransposition",
        "type": "Title"
    },
    {
        "text": "Interval",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "As one might expect, a measureParser that reveals a change\nin transposition is going to have an effect on the\nPart's instrument list.  This (totally undocumented) method\ndeals with it.\nIf measureParser.transposition is None, does nothing.\nNOTE: Need to test a change of instrument w/o a change of\ntransposition such as: Bb clarinet to Bb Soprano Sax to Eb clarinet?",
        "type": "ListItem"
    },
    {
        "text": "PartParser.",
        "type": "Title"
    },
    {
        "text": "xmlMeasureToMeasure",
        "type": "Title"
    },
    {
        "text": "mxMeasure",
        "type": "Title"
    },
    {
        "text": "Element",
        "type": "Title"
    },
    {
        "text": "\u2192 Measure",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Convert a measure element to a Measure, using\nMeasureParser\n>>> from xml.etree.ElementTree import fromstring as EL\n\n\nFull-measure rests get auto-assigned to match the time signature if they\ndo not have a type, or have a type of \u009cwhole\u009d.\nHere is a measure with a rest that lasts 4 beats, but we will put it in a 3/4 context.\n>>> scoreMeasure = '<measure><note><rest/><duration>40320</duration></note></measure>'\n>>> mxMeasure = EL(scoreMeasure)\n>>> pp = musicxml.xmlToM21.PartParser()\n>>> pp.lastDivisions\n10080\n>>> 40320 / 10080\n4.0\n>>> pp.lastTimeSignature = meter.TimeSignature('3/4')\n>>> m = pp.xmlMeasureToMeasure(mxMeasure)\n\n\nTest that the rest lasts three, not four beats:\n>>> measureRest = m.notesAndRests[0]\n>>> measureRest\n<music21.note.Rest dotted-half>\n>>> measureRest.duration.type\n'half'\n>>> measureRest.duration.quarterLength\n3.0",
        "type": "ListItem"
    },
    {
        "text": "Methods inherited from XMLParserBase:",
        "type": "NarrativeText"
    },
    {
        "text": "setColor() setEditorial() setFont() setLineStyle() setPlacement() setPosition() setPrintObject() setPrintStyle() setPrintStyleAlign() setStyleAttributes() setTextFormatting() xmlPageLayoutToPageLayout() xmlPrintToPageLayout() xmlPrintToSystemLayout() xmlStaffLayoutToStaffLayout() xmlSystemLayoutToSystemLayout()",
        "type": "Table"
    },
    {
        "text": "XMLParserBase\u00c2\u00b6",
        "type": "Title"
    },
    {
        "text": "class",
        "type": "Title"
    },
    {
        "text": "music21.musicxml.xmlToM21.",
        "type": "Title"
    },
    {
        "text": "XMLParserBase",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "contains functions that could be called\nat multiple levels of parsing (Score, Part, Measure).",
        "type": "ListItem"
    },
    {
        "text": "XMLParserBase methods",
        "type": "Title"
    },
    {
        "text": "XMLParserBase.",
        "type": "Title"
    },
    {
        "text": "setColor",
        "type": "Title"
    },
    {
        "text": "mxObject",
        "type": "Title"
    },
    {
        "text": "m21Object",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Sets m21Object.style.color to be the same as color\u2026",
        "type": "ListItem"
    },
    {
        "text": "XMLParserBase.",
        "type": "Title"
    },
    {
        "text": "setEditorial",
        "type": "Title"
    },
    {
        "text": "mxObj",
        "type": "Title"
    },
    {
        "text": "m21Obj",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Set editorial information from an mxObj\n>>> from xml.etree.ElementTree import fromstring as El\n>>> XP = musicxml.xmlToM21.XMLParserBase()\n>>> mxObj = El('<a/>')\n>>> n = note.Note('C#4')\n\n\nMost common case:\n>>> XP.setEditorial(mxObj, n)\n>>> n.hasEditorialInformation\nFalse\n\n\n>>> mxObj = El('<note><footnote>Sharp is conjectural</footnote>'\n...            + '<level reference=\"yes\">2</level></note>')\n>>> XP.setEditorial(mxObj, n)\n>>> n.hasEditorialInformation\nTrue\n>>> len(n.editorial.footnotes)\n1\n>>> fn = n.editorial.footnotes[0]\n>>> fn\n<music21.editorial.Comment 'Sharp is conjectu...'>\n>>> fn.isFootnote\nTrue\n>>> fn.levelInformation\n'2'\n>>> fn.isReference\nTrue\n\n\nIf no <footnote> tag exists, the editorial information will be found in\ncomments:\n>>> mxObj = El('<note><level reference=\"no\">ed</level></note>')\n>>> n = note.Note('C#4')\n>>> XP.setEditorial(mxObj, n)\n>>> len(n.editorial.footnotes)\n0\n>>> len(n.editorial.comments)\n1\n>>> com = n.editorial.comments[0]\n>>> com.isReference\nFalse\n>>> com.text is None\nTrue\n>>> com.levelInformation\n'ed'",
        "type": "ListItem"
    },
    {
        "text": "XMLParserBase.",
        "type": "Title"
    },
    {
        "text": "setFont",
        "type": "Title"
    },
    {
        "text": "mxObject",
        "type": "Title"
    },
    {
        "text": "m21Object",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "sets font-family, font-style, font-size, and font-weight as\nfontFamily (list), fontStyle, fontSize and fontWeight from\nan object into a TextStyle object\nconforms to attr-group %font in the MusicXML DTD\n>>> from xml.etree.ElementTree import fromstring as El\n>>> XP = musicxml.xmlToM21.XMLParserBase()\n>>> mxObj = El('<text font-family=\"Courier,monospaced\" font-style=\"italic\" '\n...            + 'font-size=\"24\" font-weight=\"bold\" />')\n\n\n>>> te = expressions.TextExpression('hi!')\n>>> XP.setFont(mxObj, te)\n>>> te.style.fontFamily\n['Courier', 'monospaced']\n>>> te.style.fontStyle\n'italic'\n>>> te.style.fontSize\n24\n>>> te.style.fontWeight\n'bold'",
        "type": "ListItem"
    },
    {
        "text": "XMLParserBase.",
        "type": "Title"
    },
    {
        "text": "setLineStyle",
        "type": "Title"
    },
    {
        "text": "mxObject",
        "type": "Title"
    },
    {
        "text": "m21Object",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Sets four additional elements for line elements, conforms to entity\n%line-shape, %line-type, %dashed-formatting (dash-length and space-length)",
        "type": "ListItem"
    },
    {
        "text": "XMLParserBase.",
        "type": "Title"
    },
    {
        "text": "setPlacement",
        "type": "Title"
    },
    {
        "text": "mxObject",
        "type": "Title"
    },
    {
        "text": "m21Object",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Sets the placement for objects that have a .placement attribute\n(most but not all spanners) and sets the style.placement for those\nthat don't.",
        "type": "ListItem"
    },
    {
        "text": "XMLParserBase.",
        "type": "Title"
    },
    {
        "text": "setPosition",
        "type": "Title"
    },
    {
        "text": "mxObject",
        "type": "Title"
    },
    {
        "text": "m21Object",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "get positioning information for an object from\ndefault-x, default-y, relative-x, relative-y into\nthe .style attribute's absoluteX, relativeX, etc. attributes'\nconforms to attr-group %position in the MusicXML DTD",
        "type": "ListItem"
    },
    {
        "text": "XMLParserBase.",
        "type": "Title"
    },
    {
        "text": "setPrintObject",
        "type": "Title"
    },
    {
        "text": "mxObject",
        "type": "Title"
    },
    {
        "text": "m21Object",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "convert \u0098print-object=\u009dno\u009d' to m21Object.style.hideObjectOnPrint = True",
        "type": "ListItem"
    },
    {
        "text": "XMLParserBase.",
        "type": "Title"
    },
    {
        "text": "setPrintStyle",
        "type": "Title"
    },
    {
        "text": "mxObject",
        "type": "Title"
    },
    {
        "text": "m21Object",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "get position, font, and color information from the mxObject\ninto the m21Object, which must have style.TextStyle as its Style class.\nconforms to attr-group %print-style in the MusicXML DTD",
        "type": "ListItem"
    },
    {
        "text": "XMLParserBase.",
        "type": "Title"
    },
    {
        "text": "setPrintStyleAlign",
        "type": "Title"
    },
    {
        "text": "mxObject",
        "type": "Title"
    },
    {
        "text": "m21Object",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "runs setPrintStyle and then sets horizontalAlign and verticalAlign, on an\nm21Object, which must have style.TextStyle as its Style class.\nconforms to attr-group %print-style-align in the MusicXML DTD",
        "type": "ListItem"
    },
    {
        "text": "XMLParserBase.",
        "type": "Title"
    },
    {
        "text": "setStyleAttributes",
        "type": "Title"
    },
    {
        "text": "mxObject",
        "type": "Title"
    },
    {
        "text": "m21Object",
        "type": "Title"
    },
    {
        "text": "musicXMLNames",
        "type": "Title"
    },
    {
        "text": "m21Names",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Takes an mxObject, a music21Object, and a list/tuple of musicXML names and\na list/tuple of m21Names, and assigns each of the mxObject's attributes\nthat fits this style name to the corresponding style object's m21Name attribute.\n>>> from xml.etree.ElementTree import fromstring as El\n>>> XP = musicxml.xmlToM21.XMLParserBase()\n>>> mxObj = El('<a x=\"20.1\" y=\"10.0\" z=\"yes\" />')\n>>> m21Obj = base.Music21Object()\n>>> musicXMLNames = ('w', 'x', 'y', 'z')\n>>> m21Names = ('justify', 'absoluteX', 'absoluteY', 'hideObjectOnPrint')\n\n\n>>> XP.setStyleAttributes(mxObj, m21Obj, musicXMLNames, m21Names)\n\n\n.justify requires a TextStyle object.\n>>> m21Obj.style.justify\nTraceback (most recent call last):\nAttributeError: 'Style' object has no attribute 'justify'\n\n\n>>> m21Obj.style.absoluteX\n20.1\n>>> m21Obj.style.absoluteY\n10\n>>> m21Obj.style.hideObjectOnPrint\nTrue",
        "type": "ListItem"
    },
    {
        "text": "XMLParserBase.",
        "type": "Title"
    },
    {
        "text": "setTextFormatting",
        "type": "NarrativeText"
    },
    {
        "text": "mxObject",
        "type": "Title"
    },
    {
        "text": "m21Object",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "sets the justification, print-style-align group, and\ntext-decoration, text-rotation,\nletter-spacing, line-height, lang, text-direction, and\nenclosure, on an\nm21Object, which must have style.TextStyle as its Style class,\nand then calls setPrintStyleAlign\nconforms to attr-group %text-formatting in the MusicXML DTD",
        "type": "ListItem"
    },
    {
        "text": "XMLParserBase.",
        "type": "Title"
    },
    {
        "text": "xmlPageLayoutToPageLayout",
        "type": "Title"
    },
    {
        "text": "mxPageLayout",
        "type": "Title"
    },
    {
        "text": "inputM21",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "get a PageLayout object from an mxPageLayout\nCalled out from mxPrintToPageLayout because it\nis also used in the <defaults> tag",
        "type": "ListItem"
    },
    {
        "text": "XMLParserBase.",
        "type": "Title"
    },
    {
        "text": "xmlPrintToPageLayout",
        "type": "Title"
    },
    {
        "text": "mxPrint",
        "type": "Title"
    },
    {
        "text": "inputM21",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Given an mxPrint object, set object data for\nthe print section of a layout.PageLayout object\n>>> from xml.etree.ElementTree import fromstring as El\n>>> MP = musicxml.xmlToM21.MeasureParser()\n\n\n>>> mxPrint = El('<print new-page=\"yes\" page-number=\"5\">'\n...    + '    <page-layout><page-height>4000</page-height>'\n...    + '        <page-margins><left-margin>20</left-margin>'\n...    + '                 <right-margin>30.25</right-margin></page-margins>'\n...    + '</page-layout></print>')\n\n\n>>> pl = MP.xmlPrintToPageLayout(mxPrint)\n>>> pl.isNew\nTrue\n>>> pl.rightMargin\n30.25\n>>> pl.leftMargin\n20\n>>> pl.pageNumber\n5\n>>> pl.pageHeight\n4000",
        "type": "ListItem"
    },
    {
        "text": "XMLParserBase.",
        "type": "Title"
    },
    {
        "text": "xmlPrintToSystemLayout",
        "type": "Title"
    },
    {
        "text": "mxPrint",
        "type": "Title"
    },
    {
        "text": "inputM21",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Given an mxPrint object, set object data\n>>> from xml.etree.ElementTree import fromstring as El\n>>> MP = musicxml.xmlToM21.MeasureParser()\n\n\n>>> mxPrint = El('<print new-system=\"yes\">'\n...    + '    <system-layout><system-distance>55</system-distance>'\n...    + '        <system-margins><left-margin>20</left-margin>'\n...    + '                 <right-margin>30.25</right-margin></system-margins>'\n...    + '</system-layout></print>')\n>>> sl = MP.xmlPrintToSystemLayout(mxPrint)\n>>> sl.isNew\nTrue\n>>> sl.rightMargin\n30.25\n>>> sl.leftMargin\n20\n>>> sl.distance\n55",
        "type": "ListItem"
    },
    {
        "text": "XMLParserBase.",
        "type": "Title"
    },
    {
        "text": "xmlStaffLayoutToStaffLayout",
        "type": "Title"
    },
    {
        "text": "mxStaffLayout",
        "type": "Title"
    },
    {
        "text": "inputM21",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "get a StaffLayout object from an <staff-layout> tag\nIn music21, the <staff-layout> and <staff-details> are\nintertwined in a StaffLayout object.",
        "type": "ListItem"
    },
    {
        "text": "XMLParserBase.",
        "type": "Title"
    },
    {
        "text": "xmlSystemLayoutToSystemLayout",
        "type": "Title"
    },
    {
        "text": "mxSystemLayout",
        "type": "Title"
    },
    {
        "text": "inputM21",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "get a SystemLayout object from an <system-layout> element\nCalled out from xmlPrintToSystemLayout because it\nis also used in the <defaults> tag",
        "type": "ListItem"
    },
    {
        "text": "Functions\u00c2\u00b6",
        "type": "Title"
    },
    {
        "text": "music21.musicxml.xmlToM21.",
        "type": "Title"
    },
    {
        "text": "musicXMLTypeToType",
        "type": "Title"
    },
    {
        "text": "value",
        "type": "Title"
    },
    {
        "text": "str",
        "type": "Title"
    },
    {
        "text": "\u2192 str",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Utility function to convert a MusicXML duration type to a music21 duration type.\nChanges \u0098long' to \u0098longa' and deals with a Guitar Pro 5.2 bug in MusicXML\nexport, that exports a 32nd note with the type \u009832th'.\n>>> musicxml.xmlToM21.musicXMLTypeToType('long')\n'longa'\n>>> musicxml.xmlToM21.musicXMLTypeToType('32th')\n'32nd'\n>>> musicxml.xmlToM21.musicXMLTypeToType('quarter')\n'quarter'\n>>> musicxml.xmlToM21.musicXMLTypeToType(None)\nTraceback (most recent call last):\nmusic21.musicxml.xmlObjects.MusicXMLImportException:\n    found unknown MusicXML type: None",
        "type": "ListItem"
    },
    {
        "text": "music21.musicxml.xmlToM21.",
        "type": "Title"
    },
    {
        "text": "strippedText",
        "type": "Title"
    },
    {
        "text": "mxObj",
        "type": "Title"
    },
    {
        "text": "Element | None",
        "type": "Title"
    },
    {
        "text": "\u2192 str",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Returns the mxObj.text.strip() from an Element (or None)\ntaking into account that .text might be None, or the\nElement might be undefined.\nReplacement for the older textStripValid()\n>>> from xml.etree.ElementTree import Element\n>>> e = Element('an-element')\n>>> musicxml.xmlToM21.strippedText(e)\n''\n>>> e.text = '    '\n>>> musicxml.xmlToM21.strippedText(e)\n''\n>>> e.text = '  hello  '\n>>> musicxml.xmlToM21.strippedText(e)\n'hello'\n\n\n>>> musicxml.xmlToM21.strippedText(None)\n''\n>>> musicxml.xmlToM21.strippedText(440.0)\n''\n\n\nNew in v9.",
        "type": "ListItem"
    },
    {
        "text": "Navigation",
        "type": "Title"
    },
    {
        "text": "index",
        "type": "ListItem"
    },
    {
        "text": "modules |",
        "type": "ListItem"
    },
    {
        "text": "next |",
        "type": "ListItem"
    },
    {
        "text": "previous |",
        "type": "ListItem"
    },
    {
        "text": "music21 \u00bb",
        "type": "ListItem"
    },
    {
        "text": "Module Reference \u00bb",
        "type": "ListItem"
    },
    {
        "text": "music21.musicxml.xmlToM21",
        "type": "ListItem"
    },
    {
        "text": "\u00a9 Copyright 2006-2023 Michael Scott Asato Cuthbert.\n      Last updated on Jun 12, 2023.",
        "type": "NarrativeText"
    }
]