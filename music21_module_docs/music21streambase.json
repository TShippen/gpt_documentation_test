[
    {
        "text": "Navigation",
        "type": "Title"
    },
    {
        "text": "index",
        "type": "ListItem"
    },
    {
        "text": "modules |",
        "type": "ListItem"
    },
    {
        "text": "next |",
        "type": "ListItem"
    },
    {
        "text": "previous |",
        "type": "ListItem"
    },
    {
        "text": "music21 \u00bb",
        "type": "ListItem"
    },
    {
        "text": "Module Reference \u00bb",
        "type": "ListItem"
    },
    {
        "text": "music21.stream.base",
        "type": "ListItem"
    },
    {
        "text": "Previous topic",
        "type": "Title"
    },
    {
        "text": "music21.spanner",
        "type": "Title"
    },
    {
        "text": "Next topic",
        "type": "Title"
    },
    {
        "text": "music21.stream.core",
        "type": "Title"
    },
    {
        "text": "Table of Contents",
        "type": "Title"
    },
    {
        "text": "music21.stream.base\nStream\nStream\nStream.beat\nStream.beatDuration\nStream.beatStr\nStream.beatStrength\nStream.flat\nStream.highestOffset\nStream.highestTime\nStream.isGapless\nStream.lowestOffset\nStream.notes\nStream.notesAndRests\nStream.pitches\nStream.secondsMap\nStream.spanners\nStream.voices\nStream.atSoundingPitch\nStream.clef\nStream.duration\nStream.elements\nStream.finalBarline\nStream.keySignature\nStream.metadata\nStream.seconds\nStream.staffLines\nStream.timeSignature\nStream.__eq__()\nStream.__getitem__()\nStream.activateVariants()\nStream.addGroupForElements()\nStream.allPlayingWhileSounding()\nStream.analyze()\nStream.append()\nStream.attachIntervalsBetweenStreams()\nStream.attachMelodicIntervals()\nStream.augmentOrDiminish()\nStream.beatAndMeasureFromOffset()\nStream.chordify()\nStream.clear()\nStream.cloneEmpty()\nStream.containerInHierarchy()\nStream.elementOffset()\nStream.expandRepeats()\nStream.explode()\nStream.extendDuration()\nStream.extendTies()\nStream.extractContext()\nStream.findConsecutiveNotes()\nStream.findGaps()\nStream.first()\nStream.flatten()\nStream.flattenUnnecessaryVoices()\nStream.getElementAfterElement()\nStream.getElementAtOrBefore()\nStream.getElementBeforeOffset()\nStream.getElementById()\nStream.getElementsByClass()\nStream.getElementsByGroup()\nStream.getElementsByOffset()\nStream.getElementsNotOfClass()\nStream.getInstrument()\nStream.getInstruments()\nStream.getOverlaps()\nStream.getTimeSignatures()\nStream.hasElement()\nStream.hasElementOfClass()\nStream.hasMeasures()\nStream.hasPartLikeStreams()\nStream.hasVoices()\nStream.haveAccidentalsBeenMade()\nStream.index()\nStream.insert()\nStream.insertAndShift()\nStream.insertIntoNoteOrChord()\nStream.invertDiatonic()\nStream.isSequence()\nStream.isTwelveTone()\nStream.isWellFormedNotation()\nStream.iter()\nStream.last()\nStream.lyrics()\nStream.makeAccidentals()\nStream.makeBeams()\nStream.makeImmutable()\nStream.makeMeasures()\nStream.makeMutable()\nStream.makeNotation()\nStream.makeRests()\nStream.makeTies()\nStream.makeVoices()\nStream.measure()\nStream.measureOffsetMap()\nStream.measures()\nStream.melodicIntervals()\nStream.mergeAttributes()\nStream.mergeElements()\nStream.metronomeMarkBoundaries()\nStream.offsetMap()\nStream.playingWhenAttacked()\nStream.plot()\nStream.pop()\nStream.quantize()\nStream.recurse()\nStream.recurseRepr()\nStream.remove()\nStream.removeByClass()\nStream.removeByNotOfClass()\nStream.repeatAppend()\nStream.repeatInsert()\nStream.replace()\nStream.scaleDurations()\nStream.scaleOffsets()\nStream.setDerivationMethod()\nStream.setElementOffset()\nStream.shiftElements()\nStream.show()\nStream.showVariantAsOssialikePart()\nStream.simultaneousAttacks()\nStream.sliceAtOffsets()\nStream.sliceByBeat()\nStream.sliceByGreatestDivisor()\nStream.sliceByQuarterLengths()\nStream.sort()\nStream.sorted()\nStream.splitAtDurations()\nStream.splitAtQuarterLength()\nStream.splitByClass()\nStream.storeAtEnd()\nStream.stripTies()\nStream.template()\nStream.toSoundingPitch()\nStream.toWrittenPitch()\nStream.transferOffsetToElements()\nStream.transpose()\nStream.voicesToParts()\nStream.write()\nStream.autoSort\nStream.definesExplicitPageBreaks\nStream.definesExplicitSystemBreaks\nStream.isFlat\nStream.isSorted\nStream.recursionType\n\n\n\n\nMeasure\nMeasure\nMeasure.barDuration\nMeasure.leftBarline\nMeasure.rightBarline\nMeasure.barDurationProportion()\nMeasure.bestTimeSignature()\nMeasure.makeNotation()\nMeasure.measureNumberWithSuffix()\nMeasure.mergeAttributes()\nMeasure.padAsAnacrusis()\nMeasure.clefIsNew\nMeasure.keyIsNew\nMeasure.layoutWidth\nMeasure.number\nMeasure.numberSuffix\nMeasure.paddingLeft\nMeasure.paddingRight\nMeasure.showNumber\nMeasure.timeSignatureIsNew\n\n\n\n\nPart\nPart\nPart.partAbbreviation\nPart.partName\nPart.makeAccidentals()\nPart.mergeAttributes()\n\n\n\n\nScore\nScore\nScore.parts\nScore.expandRepeats()\nScore.implode()\nScore.makeNotation()\nScore.measure()\nScore.measureOffsetMap()\nScore.measures()\nScore.partsToVoices()\nScore.sliceByGreatestDivisor()\n\n\n\n\nOpus\nOpus\nOpus.scores\nOpus.getNumbers()\nOpus.getScoreByNumber()\nOpus.getScoreByTitle()\nOpus.mergeScores()\nOpus.show()\nOpus.write()\n\n\n\n\nVoice\nVoice\n\n\nSpannerStorage\nSpannerStorage\nSpannerStorage.coreSelfActiveSite()\nSpannerStorage.coreStoreAtEnd()\nSpannerStorage.replace()\n\n\n\n\nVariantStorage\nVariantStorage\n\n\nOffsetMap\nOffsetMap\n\n\nBestQuantizationMatch\nBestQuantizationMatch\n\n\nPartStaff\nPartStaff\n\n\nSystem\nSystem",
        "type": "ListItem"
    },
    {
        "text": "Table of Contents",
        "type": "Title"
    },
    {
        "text": "About music21",
        "type": "ListItem"
    },
    {
        "text": "User's Guide",
        "type": "ListItem"
    },
    {
        "text": "Module Reference",
        "type": "ListItem"
    },
    {
        "text": "Installation",
        "type": "ListItem"
    },
    {
        "text": "Developer Reference",
        "type": "ListItem"
    },
    {
        "text": "Documentation and tests in progress",
        "type": "ListItem"
    },
    {
        "text": "Quick search",
        "type": "Title"
    },
    {
        "text": "This Page",
        "type": "Title"
    },
    {
        "text": "Show Source",
        "type": "ListItem"
    },
    {
        "text": "music21.stream.base\u00c2\u00b6",
        "type": "Title"
    },
    {
        "text": "The Stream and its subclasses\n(which are themselves subclasses of the Music21Object)\nare the fundamental containers of offset-positioned notation and\nmusical elements in music21. Common Stream subclasses, such\nas the Measure, Part\nand Score objects, are also in this module.",
        "type": "NarrativeText"
    },
    {
        "text": "Stream\u00c2\u00b6",
        "type": "Title"
    },
    {
        "text": "class",
        "type": "Title"
    },
    {
        "text": "music21.stream.base.",
        "type": "Title"
    },
    {
        "text": "Stream",
        "type": "Title"
    },
    {
        "text": "givenElements",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "Music21Object",
        "type": "Title"
    },
    {
        "text": "Sequence",
        "type": "Title"
    },
    {
        "text": "Music21Object",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "givenElementsBehavior",
        "type": "Title"
    },
    {
        "text": "GivenElementsBehavior",
        "type": "Title"
    },
    {
        "text": "GivenElementsBehavior.OFFSETS",
        "type": "Title"
    },
    {
        "text": "**",
        "type": "UncategorizedText"
    },
    {
        "text": "keywords",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "This is the fundamental container for Music21Objects;\nobjects may be ordered and/or placed in time based on\noffsets from the start of this container.\nAs a subclass of Music21Object, Streams have offsets,\npriority, id, and groups.\nStreams may be embedded within other Streams. As each\nStream can have its own offset, when Streams are\nembedded the offset of an element is relatively only\nto its parent Stream. The flatten()\nand method provides access to a flat version of all\nembedded Streams, with offsets relative to the\ntop-level Stream.\nThe Stream elements attribute\nreturns the contents of the Stream as a list. Direct access\nto, and manipulation of, the elements list is not recommended.\nInstead, use the host of high-level methods available.\nThe Stream, like all Music21Objects, has a\nmusic21.duration.Duration that is usually the\n\u009crelease\u009d time of the chronologically last element in the Stream\n(that is, the highest onset plus the duration of\nany element in the Stream).\nThe duration, however, can be \u009cunlinked\u009d and explicitly\nset independent of the Stream's contents.\nThe first element passed to the Stream is an optional single\nMusic21Object or a list, tuple, or other Stream of Music21Objects\nwhich is used to populate the Stream by inserting each object at\nits offset\nproperty. One special case is when every such object, such as a newly created\none, has no offset. Then, so long as the entire list is not composed of\nnon-Measure Stream subclasses representing synchrony like Parts or Voices,\neach element is appended, creating a sequence of elements in time,\nrather than synchrony.\nOther arguments and keywords are ignored, but are\nallowed so that subclassing the Stream is easier.\n>>> s1 = stream.Stream()\n>>> s1.append(note.Note('C#4', type='half'))\n>>> s1.append(note.Note('D5', type='quarter'))\n>>> s1.duration.quarterLength\n3.0\n>>> for thisNote in s1.notes:\n...     print(thisNote.octave)\n...\n4\n5\n\n\nThis is a demonstration of creating a Stream with other elements,\nincluding embedded Streams (in this case, music21.stream.Part,\na Stream subclass):\n>>> c1 = clef.TrebleClef()\n>>> c1.offset = 0.0\n>>> c1.priority = -1\n>>> n1 = note.Note('E-6', type='eighth')\n>>> n1.offset = 1.0\n>>> p1 = stream.Part()\n>>> p1.offset = 0.0\n>>> p1.id = 'embeddedPart'\n>>> p1.append(note.Rest())  # quarter rest\n>>> s2 = stream.Stream([c1, n1, p1])\n>>> s2.duration.quarterLength\n1.5\n>>> s2.show('text')\n{0.0} <music21.clef.TrebleClef>\n{0.0} <music21.stream.Part embeddedPart>\n    {0.0} <music21.note.Rest quarter>\n{1.0} <music21.note.Note E->\n\n\n\nNew in v7: providing a single element now works:\n\n>>> s = stream.Stream(meter.TimeSignature())\n>>> s.first()\n<music21.meter.TimeSignature 4/4>\n\n\nProviding a list of objects or Measures or Scores (but not other Stream\nsubclasses such as Parts or Voices) positions sequentially, i.e. appends, if they\nall have offset 0.0 currently:\n>>> s2 = stream.Measure([note.Note(), note.Note(), bar.Barline()])\n>>> s2.show('text')\n{0.0} <music21.note.Note C>\n{1.0} <music21.note.Note C>\n{2.0} <music21.bar.Barline type=regular>\n\n\nA list of measures will thus each be appended:\n>>> m1 = stream.Measure(n1, number=1)\n>>> m2 = stream.Measure(note.Rest(), number=2)\n>>> s3 = stream.Part([m1, m2])\n>>> s3.show('text')\n{0.0} <music21.stream.Measure 1 offset=0.0>\n    {1.0} <music21.note.Note E->\n{1.5} <music21.stream.Measure 2 offset=1.5>\n    {0.0} <music21.note.Rest quarter>\n\n\nHere, every element is a Stream that's not a Measure (or Score), so it\nwill be inserted at 0.0, rather than appending:\n>>> s4 = stream.Score([stream.PartStaff(n1), stream.PartStaff(note.Rest())])\n>>> s4.show('text')\n{0.0} <music21.stream.PartStaff 0x...>\n    {1.0} <music21.note.Note E->\n{0.0} <music21.stream.PartStaff 0x...>\n    {0.0} <music21.note.Rest quarter>\n\n\nCreate nested streams in one fell swoop:\n>>> s5 = stream.Score(stream.Part(stream.Measure(chord.Chord('C2 A2'))))\n>>> s5.show('text')\n{0.0} <music21.stream.Part 0x...>\n    {0.0} <music21.stream.Measure 0 offset=0.0>\n        {0.0} <music21.chord.Chord C2 A2>\n\n\nThis behavior can be modified by the givenElementsBehavior keyword to go against the norm\nof \u0098OFFSETS':\n>>> from music21.stream.enums import GivenElementsBehavior\n>>> s6 = stream.Stream([note.Note('C'), note.Note('D')],\n...                    givenElementsBehavior=GivenElementsBehavior.INSERT)\n>>> s6.show('text')  # all notes at offset 0.0\n{0.0} <music21.note.Note C>\n{0.0} <music21.note.Note D>\n\n\n>>> p1 = stream.Part(stream.Measure(note.Note('C')), id='p1')\n>>> p2 = stream.Part(stream.Measure(note.Note('D')), id='p2')\n>>> s7 = stream.Score([p1, p2],\n...                   givenElementsBehavior=GivenElementsBehavior.APPEND)\n>>> s7.show('text')  # parts following each other (not recommended)\n{0.0} <music21.stream.Part p1>\n    {0.0} <music21.stream.Measure 0 offset=0.0>\n        {0.0} <music21.note.Note C>\n{1.0} <music21.stream.Part p2>\n    {0.0} <music21.stream.Measure 0 offset=0.0>\n        {0.0} <music21.note.Note D>\n\n\nFor developers of subclasses, please note that because of how Streams\nare copied, there cannot be\nrequired parameters (i.e., without defaults) in initialization.\nFor instance, this would not\nbe allowed, because craziness and givenElements are required:\nclass CrazyStream(Stream):\n    def __init__(self, givenElements, craziness, **keywords):\n        ...\n\n\n\nNew in v7: smart appending\nNew in v8: givenElementsBehavior keyword configures the smart appending.",
        "type": "ListItem"
    },
    {
        "text": "Stream bases",
        "type": "Title"
    },
    {
        "text": "StreamCore",
        "type": "ListItem"
    },
    {
        "text": "Music21Object",
        "type": "ListItem"
    },
    {
        "text": "ProtoM21Object",
        "type": "ListItem"
    },
    {
        "text": "Stream read-only properties",
        "type": "Title"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "beat",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "beat returns None for a Stream.",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "beatDuration",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "unlike other Music21Objects, streams always have beatDuration of None",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "beatStr",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "unlike other Music21Objects, streams always have beatStr (beat string) of None\nMay change to \u0098' soon.",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "beatStrength",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "unlike other Music21Objects, streams always have beatStrength of None",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "flat",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Deprecated: use .flatten() instead\nA property that returns the same flattened representation as .flatten()\nas of music21 v7.\nSee flatten() for documentation.",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "highestOffset",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Get start time of element with the highest offset in the Stream.\nNote the difference between this property and highestTime\nwhich gets the end time of the highestOffset\n>>> stream1 = stream.Stream()\n>>> for offset in [0, 4, 8]:\n...     n = note.Note('G#', type='whole')\n...     stream1.insert(offset, n)\n>>> stream1.highestOffset\n8.0\n>>> stream1.highestTime\n12.0",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "highestTime",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Returns the maximum of all Element offsets plus their Duration\nin quarter lengths. This value usually represents the last\n\u009crelease\u009d in the Stream.\nStream.duration is normally equal to the highestTime\nexpressed as a Duration object, but it can be set separately\nfor advanced operations.\nExample: Insert a dotted half note at position 0 and see where\nit cuts off:\n>>> p1 = stream.Stream()\n>>> p1.highestTime\n0.0\n\n\n>>> n = note.Note('A-')\n>>> n.quarterLength = 3\n>>> p1.insert(0, n)\n>>> p1.highestTime\n3.0\n\n\nNow insert in the same stream, the dotted half note\nat positions 1, 2, 3, 4 and see when the final note cuts off:\n>>> p1.repeatInsert(n, [1, 2, 3, 4])\n>>> p1.highestTime\n7.0\n\n\nAnother example.\n>>> n = note.Note('C#')\n>>> n.quarterLength = 3\n\n\n>>> q = stream.Stream()\n>>> for i in [20, 0, 10, 30, 40]:\n...    p = stream.Stream()\n...    p.repeatInsert(n, [0, 1, 2, 3, 4])\n...    q.insert(i, p)  # insert out of order\n>>> len(q.flatten())\n25\n>>> q.highestTime  # this works b/c the component Stream has a duration\n47.0\n>>> r = q.flatten()\n\n\n\nChanged in v6.5: highestTime can return a Fraction.",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "isGapless",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Returns True if there are no gaps between the lowest offset and the highest time.\nOtherwise returns False\n>>> s = stream.Stream()\n>>> s.append(note.Note('C'))\n>>> s.append(note.Note('D'))\n>>> s.isGapless\nTrue\n>>> s.insert(10.0, note.Note('E'))\n>>> s.isGapless\nFalse",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "lowestOffset",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Get the start time of the Element with the lowest offset in the Stream.\n>>> stream1 = stream.Stream()\n>>> for x in range(3, 5):\n...     n = note.Note('G#')\n...     stream1.insert(x, n)\n...\n>>> stream1.lowestOffset\n3.0\n\n\nIf the Stream is empty, then the lowest offset is 0.0:\n>>> stream2 = stream.Stream()\n>>> stream2.lowestOffset\n0.0\n\n\n>>> p = stream.Stream()\n>>> p.repeatInsert(note.Note('D5'), [0, 1, 2, 3, 4])\n>>> q = stream.Stream()\n>>> q.repeatInsert(p, list(range(0, 50, 10)))\n>>> len(q.flatten())\n25\n>>> q.lowestOffset\n0.0\n>>> r = stream.Stream()\n>>> r.repeatInsert(q, list(range(97, 500, 100)))\n>>> len(r.flatten())\n125\n>>> r.lowestOffset\n97.0",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "notes",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "The .notes property of a Stream returns an iterator\nthat consists only of the notes (that is,\nNote,\nChord, etc.) found\nin the stream. This excludes Rest objects.\n>>> p1 = stream.Part()\n>>> k1 = key.KeySignature(0)  # key of C\n>>> n1 = note.Note('B')\n>>> r1 = note.Rest()\n>>> c1 = chord.Chord(['A', 'B-'])\n>>> p1.append([k1, n1, r1, c1])\n>>> p1.show('text')\n{0.0} <music21.key.KeySignature of no sharps or flats>\n{0.0} <music21.note.Note B>\n{1.0} <music21.note.Rest quarter>\n{2.0} <music21.chord.Chord A B->\n\n\n>>> noteStream = p1.notes.stream()\n>>> noteStream.show('text')\n{0.0} <music21.note.Note B>\n{2.0} <music21.chord.Chord A B->\n\n\nNotice that .notes returns a StreamIterator object\n>>> p1.notes\n<music21.stream.iterator.StreamIterator for Part:0x105b56128 @:0>\n\n\nLet's add a measure to p1:\n>>> m1 = stream.Measure()\n>>> n2 = note.Note('D')\n>>> m1.insert(0, n2)\n>>> p1.append(m1)\n\n\nNow note that n2 is not found in p1.notes\n>>> p1.notes.stream().show('text')\n{0.0} <music21.note.Note B>\n{2.0} <music21.chord.Chord A B->\n\n\nWe need to call p1.flatten().notes to find it:\n>>> p1.flatten().notes.stream().show('text')\n{0.0} <music21.note.Note B>\n{2.0} <music21.chord.Chord A B->\n{3.0} <music21.note.Note D>\n\n\n(Technical note: All elements of class NotRest are being found\nright now.  This will eventually change to also filter out\nUnpitched objects, so that all elements returned by\n.notes have a .pitches attribute.",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "notesAndRests",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "The notesAndRests property of a Stream returns a StreamIterator\nthat consists only of the GeneralNote objects found in\nthe stream.  The new Stream will contain\nmostly notes and rests (including\nNote,\nChord,\nRest) but also their subclasses, such as\nHarmony objects (ChordSymbols, FiguredBass), etc.\n>>> s1 = stream.Stream()\n>>> k1 = key.KeySignature(0)  # key of C\n>>> n1 = note.Note('B')\n>>> r1 = note.Rest()\n>>> c1 = chord.Chord(['A', 'B-'])\n>>> s1.append([k1, n1, r1, c1])\n>>> s1.show('text')\n{0.0} <music21.key.KeySignature of no sharps or flats>\n{0.0} <music21.note.Note B>\n{1.0} <music21.note.Rest quarter>\n{2.0} <music21.chord.Chord A B->\n\n\n.notesAndRests removes the KeySignature object but keeps the Rest.\n>>> notes1 = s1.notesAndRests.stream()\n>>> notes1.show('text')\n{0.0} <music21.note.Note B>\n{1.0} <music21.note.Rest quarter>\n{2.0} <music21.chord.Chord A B->\n\n\nThe same caveats about Stream classes and .flatten() in .notes apply here.",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "pitches",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Returns all Pitch objects found in any\nelement in the Stream as a Python List. Elements such as\nStreams, and Chords will have their Pitch objects accumulated as\nwell. For that reason, a flat representation is not required.\nNote that this does not include any ornamental pitches implied\nby any ornaments on those Notes and Chords.  To get those, use\nthe makeNotation.ornamentalPitches(s) method.\nPitch objects are returned in a List, not a Stream.  This usage\ndiffers from the .notes property, but makes sense since Pitch\nobjects usually have by default a Duration of zero. This is an important difference\nbetween them and music21.note.Note objects.\nkey.Key objects are subclasses of Scales, which DO have a .pitches list, but\nthey are specifically exempt from looking for pitches, since that is unlikely\nwhat someone wants here.\nN.B., TODO: This may turn to an Iterator soon.\n>>> a = corpus.parse('bach/bwv324.xml')\n>>> partOnePitches = a.parts[0].pitches\n>>> len(partOnePitches)\n25\n>>> partOnePitches[0]\n<music21.pitch.Pitch B4>\n>>> [str(p) for p in partOnePitches[0:10]]\n['B4', 'D5', 'B4', 'B4', 'B4', 'B4', 'C5', 'B4', 'A4', 'A4']\n\n\nNote that the pitches returned above are\nobjects, not text:\n>>> partOnePitches[0].octave\n4\n\n\nSince all elements with a .pitches list are returned and streams themselves have\n.pitches properties (the docs you are reading now), pitches from embedded streams\nare also returned.  Flattening a stream is not necessary.  Whether this is a\nfeature or a bug is in the eye of the beholder.\n>>> len(a.pitches)\n104\n\n\nChords get their pitches found as well:\n>>> c = chord.Chord(['C4', 'E4', 'G4'])\n>>> n = note.Note('F#4')\n>>> m = stream.Measure()\n>>> m.append(n)\n>>> m.append(c)\n>>> m.pitches\n[<music21.pitch.Pitch F#4>, <music21.pitch.Pitch C4>,\n <music21.pitch.Pitch E4>, <music21.pitch.Pitch G4>]",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "secondsMap",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Returns a list where each element is a dictionary\nconsisting of the \u0098offsetSeconds' in seconds of each element in a Stream,\nthe \u0098duration' in seconds, the \u0098endTimeSeconds' in seconds (that is, the offset\nplus the duration), and the \u0098element' itself. Also contains a \u0098voiceIndex' entry which\ncontains the voice number of the element, or None if there\nare no voices.\n>>> mm1 = tempo.MetronomeMark(number=120)\n>>> n1 = note.Note(type='quarter')\n>>> c1 = clef.AltoClef()\n>>> n2 = note.Note(type='half')\n>>> s1 = stream.Stream()\n>>> s1.append([mm1, n1, c1, n2])\n>>> om = s1.secondsMap\n>>> om[3]['offsetSeconds']\n0.5\n>>> om[3]['endTimeSeconds']\n1.5\n>>> om[3]['element'] is n2\nTrue\n>>> om[3]['voiceIndex']",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "spanners",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Return all Spanner objects\n(things such as Slurs, long trills, or anything that\nconnects many objects)\nin an Iterator\n>>> s = stream.Stream()\n>>> s.insert(0, spanner.Slur())\n>>> s.insert(0, spanner.Slur())\n>>> len(s.spanners)\n2",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "voices",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Return all Voices objects\nin an iterator\n>>> s = stream.Stream()\n>>> s.insert(0, stream.Voice())\n>>> s.insert(0, stream.Voice())\n>>> len(s.voices)\n2",
        "type": "ListItem"
    },
    {
        "text": "Read-only properties inherited from StreamCore:",
        "type": "NarrativeText"
    },
    {
        "text": "spannerBundle",
        "type": "Table"
    },
    {
        "text": "Read-only properties inherited from Music21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "hasEditorialInformation hasStyleInformation measureNumber",
        "type": "Table"
    },
    {
        "text": "Read-only properties inherited from ProtoM21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "classSet classes",
        "type": "Table"
    },
    {
        "text": "Stream read/write properties",
        "type": "Title"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "atSoundingPitch",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Get or set the atSoundingPitch status, that is whether the\nscore is at concert pitch or may have transposing instruments\nthat will not sound as notated.\nValid values are True, False, and \u0098unknown'.\nNote that setting \u009catSoundingPitch\u009d does not actually transpose the notes. See\ntoSoundingPitch() for that information.\n>>> s = stream.Stream()\n>>> s.atSoundingPitch = True\n>>> s.atSoundingPitch = False\n>>> s.atSoundingPitch = 'unknown'\n>>> s.atSoundingPitch\n'unknown'\n>>> s.atSoundingPitch = 'junk'\nTraceback (most recent call last):\nmusic21.exceptions21.StreamException: not a valid at sounding pitch value: junk",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "clef",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Finds or sets a Clef at offset 0.0 in the Stream\n(generally a Measure):\n>>> m = stream.Measure()\n>>> m.number = 10\n>>> m.clef = clef.TrebleClef()\n>>> thisTrebleClef = m.clef\n>>> thisTrebleClef.sign\n'G'\n>>> thisTrebleClef.getOffsetBySite(m)\n0.0\n\n\nSetting the clef for the measure a second time removes the previous clef\nfrom the measure and replaces it with the new one:\n>>> m.clef = clef.BassClef()\n>>> m.clef.sign\n'F'\n\n\nAnd the TrebleClef is no longer in the measure:\n>>> thisTrebleClef.getOffsetBySite(m)\nTraceback (most recent call last):\nmusic21.sites.SitesException: an entry for this object <music21.clef.TrebleClef> is not\n      stored in stream <music21.stream.Measure 10 offset=0.0>\n\n\nThe .clef appears in a .show() or other call\njust like any other element\n>>> m.append(note.Note('D#', type='whole'))\n>>> m.show('text')\n{0.0} <music21.clef.BassClef>\n{0.0} <music21.note.Note D#>",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "duration",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Returns the total duration of the Stream, from the beginning of the\nstream until the end of the final element.\nMay be set independently by supplying a Duration object.\n>>> a = stream.Stream()\n>>> q = note.Note(type='quarter')\n>>> a.repeatInsert(q, [0, 1, 2, 3])\n>>> a.highestOffset\n3.0\n>>> a.highestTime\n4.0\n>>> a.duration\n<music21.duration.Duration 4.0>\n>>> a.duration.quarterLength\n4.0\n\n\nAdvanced usage: override the duration from what is set:\n>>> newDuration = duration.Duration('half')\n>>> newDuration.quarterLength\n2.0\n\n\n>>> a.duration = newDuration\n>>> a.duration.quarterLength\n2.0\n\n\nRestore normal behavior by setting duration to None:\n>>> a.duration = None\n>>> a.duration\n<music21.duration.Duration 4.0>\n\n\nNote that the highestTime for the stream is the same\nwhether duration is overridden or not:\n>>> a.highestTime\n4.0",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "elements",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": ".elements is a Tuple representing the elements contained in the Stream.\nDirectly getting, setting, and manipulating this Tuple is\nreserved for advanced usage. Instead, use the\nprovided high-level methods.  The elements retrieved here may not\nhave this stream as an activeSite, therefore they might not be properly ordered.\nIn other words:  Don't use unless you really know what you're doing.\nTreat a Stream like a list!\nSee how these are equivalent:\n>>> m = stream.Measure([note.Note('F4'), note.Note('G4')])\n>>> m.elements\n(<music21.note.Note F>, <music21.note.Note G>)\n>>> tuple(m)\n(<music21.note.Note F>, <music21.note.Note G>)\n\n\nWhen setting .elements, a list of Music21Objects can be provided, or a complete Stream.\nIf a complete Stream is provided, elements are extracted\nfrom that Stream. This has the advantage of transferring\noffset correctly and getting elements stored at the end.\n>>> a = stream.Stream()\n>>> a.repeatInsert(note.Note('C'), list(range(10)))\n>>> b = stream.Stream()\n>>> b.repeatInsert(note.Note('D'), list(range(10)))\n>>> b.offset = 6\n>>> c = stream.Stream()\n>>> c.repeatInsert(note.Note('E'), list(range(10)))\n>>> c.offset = 12\n>>> b.insert(c)\n>>> b.isFlat\nFalse\n\n\n>>> a.isFlat\nTrue\n\n\nAssigning from a Stream works well, and is actually much safer than assigning\nfrom .elements of the other Stream, since the active sites may have changed\nof that stream's elements in the meantime.\n>>> a.elements = b\n>>> a.isFlat\nFalse\n\n\n>>> len(a.recurse().notes) == len(b.recurse().notes) == 20\nTrue\n\n\nThere is one good use for .elements as opposed to treating a Stream like a list,\nand that is that in for Streams compares on object identity, i.e.,\nid(a) == id(b) [this is for historical reasons], while since .elements\nis a tuple.  Recall our measure with the notes F4 and G4 above.\n>>> other_g = note.Note('G4')\n\n\nThis new G can't be found in m, because it is not physically in the Measure\n>>> other_g in m\nFalse\n\n\nBut it is equal to something in the Measure:\n>>> other_g in m.elements\nTrue\n\n\nBut again, this could be done simply with:\n>>> other_g in tuple(m)\nTrue\n\n\nOne reason to use .elements is to iterate quickly without setting\nactiveSite:\n>>> n = note.Note()\n>>> m1 = stream.Measure([n])\n>>> m2 = stream.Measure([n])\n>>> n.activeSite is m2\nTrue\n>>> for el in m1.elements:\n...     pass\n>>> n.activeSite is m2\nTrue\n>>> for el in m1:\n...     pass\n>>> n.activeSite is m1\nTrue",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "finalBarline",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Get or set the final barline of this Stream's Measures,\nif and only if there are Measures defined as elements in this Stream.\nThis method will not create Measures if none exist.\n>>> p = stream.Part()\n>>> m1 = stream.Measure()\n>>> m1.rightBarline = bar.Barline('double')\n>>> p.append(m1)\n>>> p.finalBarline\n<music21.bar.Barline type=double>\n>>> m2 = stream.Measure()\n>>> m2.rightBarline = bar.Barline('final')\n>>> p.append(m2)\n>>> p.finalBarline\n<music21.bar.Barline type=final>\n\n\nThis property also works on Scores that contain one or more Parts.\nIn that case a list of barlines can be used to set the final barline.\n>>> s = corpus.parse('bwv66.6')\n>>> s.finalBarline\n[<music21.bar.Barline type=final>,\n <music21.bar.Barline type=final>,\n <music21.bar.Barline type=final>,\n <music21.bar.Barline type=final>]\n\n\n>>> s.finalBarline = 'none'\n>>> s.finalBarline\n[<music21.bar.Barline type=none>,\n <music21.bar.Barline type=none>,\n <music21.bar.Barline type=none>,\n <music21.bar.Barline type=none>]\n\n\nGetting or setting a final barline on a Measure (or another Stream\nwith a rightBarline attribute) is the same as getting or setting the rightBarline.\n>>> m = stream.Measure()\n>>> m.finalBarline is None\nTrue\n>>> m.finalBarline = 'final'\n>>> m.finalBarline\n<music21.bar.Barline type=final>\n>>> m.rightBarline\n<music21.bar.Barline type=final>\n\n\nGetting on a generic Stream, Voice, or Opus always returns a barline of None,\nand setting on a generic Stream, Voice, or Opus always returns None:\n>>> s = stream.Stream()\n>>> s.finalBarline is None\nTrue\n>>> s.finalBarline = 'final'\n>>> s.finalBarline is None\nTrue\n\n\n\nChanged in v6.3: does not raise an exception if queried or set on a measure-less stream.\nPreviously raised a StreamException",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "keySignature",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Find or set a Key or KeySignature at offset 0.0 of a stream.\n>>> a = stream.Measure()\n>>> a.keySignature = key.KeySignature(-2)\n>>> ks = a.keySignature\n>>> ks.sharps\n-2\n>>> a.show('text')\n{0.0} <music21.key.KeySignature of 2 flats>\n\n\nA key.Key object can be used instead of key.KeySignature,\nsince the former derives from the latter.\n>>> a.keySignature = key.Key('E', 'major')\n>>> for k in a:\n...     print(k.offset, repr(k))\n0.0 <music21.key.Key of E major>\n\n\nNotice that setting a new key signature replaces any previous ones:\n>>> len(a.getElementsByClass(key.KeySignature))\n1\n\n\n.keySignature can be set to None:\n>>> a.keySignature = None\n>>> a.keySignature is None\nTrue",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "metadata",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Get or set the Metadata object\nfound at the beginning (offset 0) of this Stream.\n>>> s = stream.Stream()\n>>> s.metadata = metadata.Metadata()\n>>> s.metadata.composer = 'frank'\n>>> s.metadata.composer\n'frank'\n\n\nMay also return None if nothing is there.",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "seconds",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Get or set the duration of this Stream in seconds, assuming that\nthis object contains a MetronomeMark or\nMetricModulation.\n>>> s = corpus.parse('bwv66.6')  # piece without a tempo\n>>> sFlat = s.flatten()\n>>> t = tempo.MetronomeMark('adagio')\n>>> sFlat.insert(0, t)\n>>> sFlat.seconds\n38.57142857...\n>>> tFast = tempo.MetronomeMark('allegro')\n>>> sFlat.replace(t, tFast)\n>>> sFlat.seconds\n16.363...\n\n\nSetting seconds on streams is not supported.  Ideally it would instead\nscale all elements to fit, but this is a long way off.\nIf a stream does not have a tempo-indication in it then the property\nreturns 0.0 if an empty Stream (or self.highestTime is 0.0) or \u0098nan'\nif there are non-zero duration objects in the stream:\n>>> s = stream.Stream()\n>>> s.seconds\n0.0\n>>> s.insert(0, clef.TrebleClef())\n>>> s.seconds\n0.0\n>>> s.append(note.Note(type='half'))\n>>> s.seconds\nnan\n>>> import math\n>>> math.isnan(s.seconds)\nTrue\n\n\n\nChanged in v6.3: return nan rather than raising an exception.  Do not\nattempt to change seconds on a stream, as it did not do what you would expect.",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "staffLines",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Returns the number of staffLines for the Stream, as defined by\nthe first StaffLayout object found at offset 0 that defines staffLines\n>>> m = stream.Measure()\n>>> m.staffLines\n5\n>>> m.staffLines = 4\n>>> m.staffLines\n4\n>>> m.show('text')\n{0.0} <music21.layout.StaffLayout distance None, staffNumber None,\n          staffSize None, staffLines 4>\n\n\n>>> staffLayout = m.getElementsByClass(layout.StaffLayout).first()\n>>> staffLayout.staffLines = 1\n>>> m.staffLines\n1\n\n\n>>> p = stream.Part()\n>>> p.insert(0, m)\n>>> p.staffLines\n1\n\n\n>>> p2 = stream.Part()\n>>> m0 = stream.Measure()\n>>> m0.insert(0, note.Note(type='whole'))\n>>> p2.append(m0)\n>>> p2.append(m)\n>>> p2.staffLines\n5",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "timeSignature",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Gets or sets the timeSignature at offset 0.0 of the Stream (generally a Measure)\n>>> m1 = stream.Measure(number=1)\n>>> m1.timeSignature = meter.TimeSignature('2/4')\n>>> m1.timeSignature.numerator, m1.timeSignature.denominator\n(2, 4)\n>>> m1.show('text')\n{0.0} <music21.meter.TimeSignature 2/4>\n\n\nSetting timeSignature to None removes any TimeSignature at offset 0.0:\n>>> m1.timeSignature = None\n>>> m1.elements\n()\n\n\nOnly the time signature at offset 0 is found:\n>>> m2 = stream.Measure(number=2)\n>>> m2.insert(0.0, meter.TimeSignature('5/4'))\n>>> m2.insert(2.0, meter.TimeSignature('7/4'))\n>>> ts = m2.timeSignature\n>>> ts.numerator, ts.denominator\n(5, 4)\n\n\n>>> m2.timeSignature = meter.TimeSignature('2/8')\n>>> m2.timeSignature\n<music21.meter.TimeSignature 2/8>\n\n\nAfter setting a new .timeSignature, the old one is no longer in the Stream:\n>>> ts in m2\nFalse\n\n\nThis property is not recursive, so a Part will not have the time signature of\nthe measure within it:\n>>> p = stream.Part()\n>>> p.append(m2)\n>>> p.timeSignature is None\nTrue",
        "type": "ListItem"
    },
    {
        "text": "Read/write properties inherited from Music21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "activeSite derivation editorial id offset priority quarterLength style",
        "type": "Table"
    },
    {
        "text": "Stream methods",
        "type": "Title"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "__eq__",
        "type": "UncategorizedText"
    },
    {
        "text": "other",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "No two streams are ever equal unless they are the same Stream",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "__getitem__",
        "type": "Title"
    },
    {
        "text": "str",
        "type": "Title"
    },
    {
        "text": "\u2192 RecursiveIterator[M21ObjType]",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "__getitem__",
        "type": "Title"
    },
    {
        "text": "int",
        "type": "Title"
    },
    {
        "text": "\u2192 M21ObjType",
        "type": "Title"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "__getitem__",
        "type": "Title"
    },
    {
        "text": "slice",
        "type": "Title"
    },
    {
        "text": "\u2192 list[M21ObjType]",
        "type": "Title"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "__getitem__",
        "type": "Title"
    },
    {
        "text": "type[ChangedM21ObjType]",
        "type": "Title"
    },
    {
        "text": "\u2192 RecursiveIterator[ChangedM21ObjType]",
        "type": "Title"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "__getitem__",
        "type": "Title"
    },
    {
        "text": "type",
        "type": "Title"
    },
    {
        "text": "\u2192 RecursiveIterator[M21ObjType]",
        "type": "Title"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "__getitem__",
        "type": "Title"
    },
    {
        "text": "Collection[type]",
        "type": "Title"
    },
    {
        "text": "\u2192 RecursiveIterator[M21ObjType]",
        "type": "Title"
    },
    {
        "text": "Get a Music21Object from the Stream using a variety of keys or indices.\nIf an int is given, the Music21Object at the index is returned, as if it were a list\nor tuple:\n>>> c = note.Note('C')\n>>> d = note.Note('D')\n>>> e = note.Note('E')\n>>> r1 = note.Rest()\n>>> f = note.Note('F')\n>>> g = note.Note('G')\n>>> r2 = note.Rest()\n>>> a = note.Note('A')\n>>> s = stream.Stream([c, d, e, r1, f, g, r2, a])\n\n\n>>> s[0]\n<music21.note.Note C>\n>>> s[-1]\n<music21.note.Note A>\n\n\nOut of range notes raise an IndexError:\n>>> s[99]\nTraceback (most recent call last):\nIndexError: attempting to access index 99 while elements is of size 8\n\n\nIf a slice of indices is given, a list of elements is returned, as if the Stream\nwere a list or Tuple.\n>>> subslice = s[2:5]\n>>> subslice\n[<music21.note.Note E>, <music21.note.Rest quarter>, <music21.note.Note F>]\n>>> len(subslice)\n3\n>>> s[1].offset\n1.0\n>>> subslice[1].offset\n3.0\n\n\nIf a class is given, then a RecursiveIterator\nof elements matching the requested class is returned, similar\nto Stream().recurse().getElementsByClass().\n>>> len(s)\n8\n>>> len(s[note.Rest])\n2\n>>> len(s[note.Note])\n6\n\n\n>>> for n in s[note.Note]:\n...     print(n.name, end=' ')\nC D E F G A\n\n\nNote that this iterator is recursive: it will find elements inside of streams\nwithin this stream:\n>>> c_sharp = note.Note('C#')\n>>> v = stream.Voice()\n>>> v.insert(0, c_sharp)\n>>> s.insert(0.5, v)\n>>> len(s[note.Note])\n7\n\n\nWhen using a single Music21 class in this way, your type checker will\nbe able to infer that the only objects in any loop are in fact note.Note\nobjects, and catch programming errors before running.\nMultiple classes can be provided, separated by commas. Any element matching\nany of the requested classes will be matched.\n>>> len(s[note.Note, note.Rest])\n9\n\n\n>>> for note_or_rest in s[note.Note, note.Rest]:\n...     if isinstance(note_or_rest, note.Note):\n...         print(note_or_rest.name, end=' ')\n...     else:\n...         print('Rest', end=' ')\nC C# D E Rest F G Rest A\n\n\nThe actual object returned by s[module.Class] is a\nRecursiveIterator and has all the functions\navailable on it:\n>>> s[note.Note]\n<...>\n\n\nIf no elements of the class are found, no error is raised in version 7:\n>>> list(s[layout.StaffLayout])\n[]\n\n\nIf the key is a string, it is treated as a querySelector as defined in\ngetElementsByQuerySelector(), namely that bare strings\nare treated as class names, strings beginning with # are id-queries, and strings\nbeginning with . are group queries.\nWe can set some ids and groups for demonstrating.\n>>> a.id = 'last_a'\n>>> c.groups.append('ghost')\n>>> e.groups.append('ghost')\n\n\n\u0098.ghost', because it begins with ., is treated as a class name and\nreturns a RecursiveIterator:\n>>> for n in s['.ghost']:\n...     print(n.name, end=' ')\nC E\n\n\nA query selector with a # returns the single element matching that\nelement or returns None if there is no match:\n>>> s['#last_a']\n<music21.note.Note A>\n\n\n>>> s['#nothing'] is None\nTrue\n\n\nAny other query raises a TypeError:\n>>> s[0.5]\nTraceback (most recent call last):\nTypeError: Streams can get items by int, slice, class, class iterable, or string query;\n   got <class 'float'>\n\n\n\nChanged in v7:\n- out of range indexes now raise an IndexError, not StreamException\n- strings (\u0098music21.note.Note', \u0098#id', \u0098.group') are now treated like a query selector.\n- slices with negative indices now supported\n- Unsupported types now raise TypeError\n- Class and Group searches now return a recursive StreamIterator rather than a Stream\n- Slice searches now return a list of elements rather than a Stream\nChanged in v8:\n- for strings: only fully-qualified names such as \u009cmusic21.note.Note\u009d or\npartially-qualified names such as \u009cnote.Note\u009d are\nsupported as class names.  Better to use a literal type or explicitly call\n.recurse().getElementsByClass to get the earlier behavior.  Old behavior\nstill works until v9.  This is an attempt to unify __getitem__ behavior in\nStreamIterators and Streams.\n- allowed iterables of qualified class names, e.g. [note.Note, note.Rest]",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "activateVariants",
        "type": "Title"
    },
    {
        "text": "group",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "matchBySpan",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "inPlace",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "For any Variant objects defined in this Stream\n(or selected by matching the group parameter),\nreplace elements defined in the Variant with those in the calling Stream.\nElements replaced will be gathered into a new Variant\ngiven the group \u0098default'. If a variant is activated with\n.replacementDuration different from its length, the appropriate elements\nin the stream will have their offsets shifted, and measure numbering\nwill be fixed. If matchBySpan is True, variants with lengthType\n\u0098replacement' will replace all the elements in the\nreplacement region of comparable class. If matchBySpan is False,\nelements will be swapped in when a match is found between an element\nin the variant and an element in the replacement region of the string.\n>>> sStr   = 'd4 e4 f4 g4   a2 b-4 a4    g4 a8 g8 f4 e4    d2 a2              '\n>>> v1Str  = '              a2. b-8 a8 '\n>>> v2Str1 = '                                             d4 f4 a2 '\n>>> v2Str2 = '                                                      d4 f4 AA2 '\n\n\n>>> sStr += \"d4 e4 f4 g4    a2 b-4 a4    g4 a8 b-8 c'4 c4    f1\"\n\n\n>>> s = converter.parse('tinynotation: 4/4 ' + sStr, makeNotation=False)\n>>> s.makeMeasures(inPlace=True)  # maybe not necessary?\n>>> v1stream = converter.parse('tinynotation: 4/4 ' + v1Str, makeNotation=False)\n>>> v2stream1 = converter.parse('tinynotation: 4/4 ' + v2Str1, makeNotation=False)\n>>> v2stream2 = converter.parse('tinynotation: 4/4 ' + v2Str2, makeNotation=False)\n\n\n>>> v1 = variant.Variant()\n>>> v1measure = stream.Measure()\n>>> v1.insert(0.0, v1measure)\n>>> for e in v1stream.notesAndRests:\n...    v1measure.insert(e.offset, e)\n\n\n>>> v2 = variant.Variant()\n>>> v2.replacementDuration = 4.0\n>>> v2measure1 = stream.Measure()\n>>> v2measure2 = stream.Measure()\n>>> v2.insert(0.0, v2measure1)\n>>> v2.insert(4.0, v2measure2)\n>>> for e in v2stream1.notesAndRests:\n...    v2measure1.insert(e.offset, e)\n>>> for e in v2stream2.notesAndRests:\n...    v2measure2.insert(e.offset, e)\n\n\n>>> v3 = variant.Variant()\n>>> v3.replacementDuration = 4.0\n>>> v1.groups = ['docVariants']\n>>> v2.groups = ['docVariants']\n>>> v3.groups = ['docVariants']\n\n\n>>> s.insert(4.0, v1)   # replacement variant\n>>> s.insert(12.0, v2)  # insertion variant (2 bars replace 1 bar)\n>>> s.insert(20.0, v3)  # deletion variant (0 bars replace 1 bar)\n>>> s.show('text')\n{0.0} <music21.stream.Measure 1 offset=0.0>\n    {0.0} <music21.clef.TrebleClef>\n    {0.0} <music21.meter.TimeSignature 4/4>\n    {0.0} <music21.note.Note D>\n    {1.0} <music21.note.Note E>\n    {2.0} <music21.note.Note F>\n    {3.0} <music21.note.Note G>\n{4.0} <music21.variant.Variant object of length 4.0>\n{4.0} <music21.stream.Measure 2 offset=4.0>\n    {0.0} <music21.note.Note A>\n    {2.0} <music21.note.Note B->\n    {3.0} <music21.note.Note A>\n{8.0} <music21.stream.Measure 3 offset=8.0>\n    {0.0} <music21.note.Note G>\n    {1.0} <music21.note.Note A>\n    {1.5} <music21.note.Note G>\n    {2.0} <music21.note.Note F>\n    {3.0} <music21.note.Note E>\n{12.0} <music21.variant.Variant object of length 8.0>\n{12.0} <music21.stream.Measure 4 offset=12.0>\n    {0.0} <music21.note.Note D>\n    {2.0} <music21.note.Note A>\n{16.0} <music21.stream.Measure 5 offset=16.0>\n    {0.0} <music21.note.Note D>\n    {1.0} <music21.note.Note E>\n    {2.0} <music21.note.Note F>\n    {3.0} <music21.note.Note G>\n{20.0} <music21.variant.Variant object of length 0.0>\n{20.0} <music21.stream.Measure 6 offset=20.0>\n    {0.0} <music21.note.Note A>\n    {2.0} <music21.note.Note B->\n    {3.0} <music21.note.Note A>\n{24.0} <music21.stream.Measure 7 offset=24.0>\n    {0.0} <music21.note.Note G>\n    {1.0} <music21.note.Note A>\n    {1.5} <music21.note.Note B->\n    {2.0} <music21.note.Note C>\n    {3.0} <music21.note.Note C>\n{28.0} <music21.stream.Measure 8 offset=28.0>\n    {0.0} <music21.note.Note F>\n    {4.0} <music21.bar.Barline type=final>\n\n\n>>> docVariant = s.activateVariants('docVariants')\n\n\n>>> s.show()\n\n\n\n>>> docVariant.show()\n\n\n\n>>> docVariant.show('text')\n{0.0} <music21.stream.Measure 1 offset=0.0>\n    {0.0} <music21.clef.TrebleClef>\n    {0.0} <music21.meter.TimeSignature 4/4>\n    {0.0} <music21.note.Note D>\n    {1.0} <music21.note.Note E>\n    {2.0} <music21.note.Note F>\n    {3.0} <music21.note.Note G>\n{4.0} <music21.variant.Variant object of length 4.0>\n{4.0} <music21.stream.Measure 2 offset=4.0>\n    {0.0} <music21.note.Note A>\n    {3.0} <music21.note.Note B->\n    {3.5} <music21.note.Note A>\n{8.0} <music21.stream.Measure 3 offset=8.0>\n    {0.0} <music21.note.Note G>\n    {1.0} <music21.note.Note A>\n    {1.5} <music21.note.Note G>\n    {2.0} <music21.note.Note F>\n    {3.0} <music21.note.Note E>\n{12.0} <music21.variant.Variant object of length 4.0>\n{12.0} <music21.stream.Measure 4 offset=12.0>\n    {0.0} <music21.note.Note D>\n    {1.0} <music21.note.Note F>\n    {2.0} <music21.note.Note A>\n{16.0} <music21.stream.Measure 5 offset=16.0>\n    {0.0} <music21.note.Note D>\n    {1.0} <music21.note.Note F>\n    {2.0} <music21.note.Note A>\n{20.0} <music21.stream.Measure 6 offset=20.0>\n    {0.0} <music21.note.Note D>\n    {1.0} <music21.note.Note E>\n    {2.0} <music21.note.Note F>\n    {3.0} <music21.note.Note G>\n{24.0} <music21.variant.Variant object of length 4.0>\n{24.0} <music21.stream.Measure 7 offset=24.0>\n    {0.0} <music21.note.Note G>\n    {1.0} <music21.note.Note A>\n    {1.5} <music21.note.Note B->\n    {2.0} <music21.note.Note C>\n    {3.0} <music21.note.Note C>\n{28.0} <music21.stream.Measure 8 offset=28.0>\n    {0.0} <music21.note.Note F>\n    {4.0} <music21.bar.Barline type=final>\n\n\nAfter a variant group has been activated, the regions it replaced are\nstored as variants with the group \u0098default'.\nIt should be noted that this means .activateVariants should rarely if\never be used on a stream which is returned\nby activateVariants because the group information is lost.\n>>> defaultVariant = docVariant.activateVariants('default')\n>>> defaultVariant.show()\n\n\n\n>>> defaultVariant.show('text')\n{0.0} <music21.stream.Measure 1 offset=0.0>\n    {0.0} <music21.clef.TrebleClef>\n    {0.0} <music21.meter.TimeSignature 4/4>\n    {0.0} <music21.note.Note D>\n    {1.0} <music21.note.Note E>\n    {2.0} <music21.note.Note F>\n    {3.0} <music21.note.Note G>\n{4.0} <music21.variant.Variant object of length 4.0>\n{4.0} <music21.stream.Measure 2 offset=4.0>\n    {0.0} <music21.note.Note A>\n    {2.0} <music21.note.Note B->\n    {3.0} <music21.note.Note A>\n{8.0} <music21.stream.Measure 3 offset=8.0>\n    {0.0} <music21.note.Note G>\n    {1.0} <music21.note.Note A>\n    {1.5} <music21.note.Note G>\n    {2.0} <music21.note.Note F>\n    {3.0} <music21.note.Note E>\n{12.0} <music21.variant.Variant object of length 8.0>\n{12.0} <music21.stream.Measure 4 offset=12.0>\n    {0.0} <music21.note.Note D>\n    {2.0} <music21.note.Note A>\n{16.0} <music21.stream.Measure 5 offset=16.0>\n    {0.0} <music21.note.Note D>\n    {1.0} <music21.note.Note E>\n    {2.0} <music21.note.Note F>\n    {3.0} <music21.note.Note G>\n{20.0} <music21.variant.Variant object of length 0.0>\n{20.0} <music21.stream.Measure 6 offset=20.0>\n    {0.0} <music21.note.Note A>\n    {2.0} <music21.note.Note B->\n    {3.0} <music21.note.Note A>\n{24.0} <music21.stream.Measure 7 offset=24.0>\n    {0.0} <music21.note.Note G>\n    {1.0} <music21.note.Note A>\n    {1.5} <music21.note.Note B->\n    {2.0} <music21.note.Note C>\n    {3.0} <music21.note.Note C>\n{28.0} <music21.stream.Measure 8 offset=28.0>\n    {0.0} <music21.note.Note F>\n    {4.0} <music21.bar.Barline type=final>",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "addGroupForElements",
        "type": "Title"
    },
    {
        "text": "group",
        "type": "Title"
    },
    {
        "text": "str",
        "type": "Title"
    },
    {
        "text": "classFilter",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "recurse",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "setActiveSite",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Add the group to the groups attribute of all elements.\nif classFilter is set then only those elements whose objects\nbelong to a certain class (or for Streams which are themselves of\na certain class) are set.\n>>> a = stream.Stream()\n>>> a.repeatAppend(note.Note('A-'), 30)\n>>> a.repeatAppend(note.Rest(), 30)\n>>> a.addGroupForElements('flute')\n>>> a[0].groups\n['flute']\n>>> a.addGroupForElements('quietTime', note.Rest)\n>>> a[0].groups\n['flute']\n>>> a[50].groups\n['flute', 'quietTime']\n>>> a[1].groups.append('quietTime')  # set one note to it\n>>> a[1].step = 'B'\n>>> b = a.getElementsByGroup('quietTime')\n>>> len(b)\n31\n>>> c = b.getElementsByClass(note.Note)\n>>> len(c)\n1\n>>> c[0].name\n'B-'\n\n\nIf recurse is True then all sub-elements will get the group:\n>>> s = converter.parse('tinyNotation: 4/4 c4 d e f g a b- b')\n>>> s.addGroupForElements('scaleNote', 'Note')\n>>> s.recurse().notes[3].groups\n[]\n>>> s.addGroupForElements('scaleNote', 'Note', recurse=True)\n>>> s.recurse().notes[3].groups\n['scaleNote']\n\n\nNo group will be added more than once:\n>>> s.addGroupForElements('scaleNote', 'Note', recurse=True)\n>>> s.recurse().notes[3].groups\n['scaleNote']\n\n\n\nNew in v6.7.1: recurse",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "allPlayingWhileSounding",
        "type": "NarrativeText"
    },
    {
        "text": "el",
        "type": "Title"
    },
    {
        "text": "elStream",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Returns a new Stream of elements in this stream that sound\nat the same time as el, an element presumably in another Stream.\nThe offset of this new Stream is set to el's offset, while the\noffset of elements within the Stream are adjusted relative to\ntheir position with respect to the start of el.  Thus, a note\nthat is sounding already when el begins would have a negative\noffset.  The duration of otherStream is forced\nto be the length of el \u2014 thus a note sustained after el ends\nmay have a release time beyond that of the duration of the Stream.\nAs above, elStream is an optional Stream to look up el's offset in.  Use\nthis to work on an element in another part.\nThe method always returns a Stream, but it might be an empty Stream.",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "analyze",
        "type": "Title"
    },
    {
        "text": "method",
        "type": "Title"
    },
    {
        "text": "str",
        "type": "Title"
    },
    {
        "text": "**",
        "type": "UncategorizedText"
    },
    {
        "text": "keywords",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Runs a particular analytical method on the contents of the\nstream to find its ambitus (range) or key.\n\nambitus \u2014 runs Ambitus\nkey \u2014 runs KrumhanslSchmuckler\n\nSome of these methods can take additional arguments.  For details on\nthese arguments, see\nanalyzeStream().\nExample:\n>>> s = corpus.parse('bach/bwv66.6')\n>>> s.analyze('ambitus')\n<music21.interval.Interval m21>\n>>> s.analyze('key')\n<music21.key.Key of f# minor>\n\n\nExample: music21 allows you to automatically run an\nanalysis to get the key of a piece or excerpt not\nbased on the key signature but instead on the\nfrequency with which some notes are used as opposed\nto others (first described by Carol Krumhansl).  For\ninstance, a piece with mostly Cs and Gs, some Fs,\nand Ds, but fewer G#s, C#s, etc. is more likely to\nbe in the key of C major than in D-flat major\n(or A minor, etc.).  You can easily get this analysis\nfrom a stream by running:\n>>> myStream = corpus.parse('luca/gloria')\n>>> analyzedKey = myStream.analyze('key')\n>>> analyzedKey\n<music21.key.Key of F major>\n\n\nanalyzedKey is a Key\nobject with a few extra parameters.\ncorrelationCoefficient shows how well this key fits the\nprofile of a piece in that key:\n>>> analyzedKey.correlationCoefficient\n0.86715...\n\n\nalternateInterpretations is a list of the other\npossible interpretations sorted from most likely to least:\n>>> analyzedKey.alternateInterpretations\n[<music21.key.Key of d minor>,\n <music21.key.Key of C major>,\n <music21.key.Key of g minor>,\n ...]\n\n\nEach of these can be examined in turn to see its correlation coefficient:\n>>> analyzedKey.alternateInterpretations[1].correlationCoefficient\n0.788528...\n>>> analyzedKey.alternateInterpretations[22].correlationCoefficient\n-0.86728...",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "append",
        "type": "Title"
    },
    {
        "text": "others",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Add a Music21Object (including another Stream) to the end of the current Stream.\nIf given a list, will append each element in order after the previous one.\nThe \u009cend\u009d of the stream is determined by the highestTime property\n(that is the latest \u009crelease\u009d of an object, or directly after the last\nelement ends).\nRuns fast for multiple addition and will preserve isSorted if True\n>>> a = stream.Stream()\n>>> notes = []\n>>> for x in range(3):\n...     n = note.Note('G#')\n...     n.duration.quarterLength = 3\n...     notes.append(n)\n>>> a.append(notes[0])\n>>> a.highestOffset, a.highestTime\n(0.0, 3.0)\n>>> a.append(notes[1])\n>>> a.highestOffset, a.highestTime\n(3.0, 6.0)\n>>> a.append(notes[2])\n>>> a.highestOffset, a.highestTime\n(6.0, 9.0)\n>>> notes2 = []\n\n\nNotes' naive offsets will\nchange when they are added to a stream.\n>>> for x in range(3):\n...     n = note.Note('A-')\n...     n.duration.quarterLength = 3\n...     n.offset = 0\n...     notes2.append(n)\n>>> a.append(notes2)  # add em all again\n>>> a.highestOffset, a.highestTime\n(15.0, 18.0)\n>>> a.isSequence()\nTrue\n\n\nAdding a note that already has an offset set does nothing different\nfrom above! That is, it is still added to the end of the Stream:\n>>> n3 = note.Note('B-')\n>>> n3.offset = 1\n>>> n3.duration.quarterLength = 3\n>>> a.append(n3)\n>>> a.highestOffset, a.highestTime\n(18.0, 21.0)\n>>> n3.getOffsetBySite(a)\n18.0\n\n\nPrior to v5.7 there was a bug where appending a Clef after a KeySignature\nor a Measure after a KeySignature, etc. would not cause sorting to be re-run.\nThis bug is now fixed.\n>>> s = stream.Stream()\n>>> s.append([meter.TimeSignature('4/4'),\n...           clef.TrebleClef()])\n>>> s.elements[0]\n<music21.clef.TrebleClef>\n>>> s.show('text')\n{0.0} <music21.clef.TrebleClef>\n{0.0} <music21.meter.TimeSignature 4/4>\n\n\n>>> s.append(metadata.Metadata(composer='Cage'))\n>>> s.show('text')\n{0.0} <music21.metadata.Metadata object at 0x11ca356a0>\n{0.0} <music21.clef.TrebleClef>\n{0.0} <music21.meter.TimeSignature 4/4>",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "attachIntervalsBetweenStreams",
        "type": "Title"
    },
    {
        "text": "cmpStream",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "For each element in self, creates an interval.Interval object in the element's\neditorial that is the interval between it and the element in cmpStream that\nis sounding at the moment the element in srcStream is attacked.\nRemember that if you are comparing two streams with measures, etc.,\nyou'll need to flatten each stream as follows:\n>>> stream1.flatten().attachIntervalsBetweenStreams(stream2.flatten())\n\n\nExample usage:\n>>> s1 = converter.parse('tinynotation: 7/4 C4 d8 e f# g A2 d2', makeNotation=False)\n>>> s2 = converter.parse('tinynotation: 7/4 g4 e8 d c4   a2 r2', makeNotation=False)\n>>> s1.attachIntervalsBetweenStreams(s2)\n>>> for n in s1.notes:\n...     if n.editorial.harmonicInterval is None:\n...         print('None')  # if other voice had a rest...\n...     else:\n...         print(n.editorial.harmonicInterval.directedName)\nP12\nM2\nM-2\nA-4\nP-5\nP8\nNone",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "attachMelodicIntervals",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "For each element in self, creates an interval.Interval object in the element's\neditorial that is the interval between it and the previous element in the stream. Thus,\nthe first element will have a value of None.\nDEPRECATED sometime soon.  A replacement to come presently.\n>>> s1 = converter.parse('tinyNotation: 7/4 C4 d8 e f# g A2 d2', makeNotation=False)\n>>> s1.attachMelodicIntervals()\n>>> for n in s1.notes:\n...     if n.editorial.melodicInterval is None:\n...         print('None')\n...     else:\n...         print(n.editorial.melodicInterval.directedName)\nNone\nM9\nM2\nM2\nm2\nm-7\nP4\n\n\n>>> s = stream.Stream()\n>>> s.append(note.Note('C'))\n>>> s.append(note.Note('D'))\n>>> s.append(note.Rest(quarterLength=4.0))\n>>> s.append(note.Note('D'))\n>>> s.attachMelodicIntervals()\n>>> for n in s.notes:\n...     if n.editorial.melodicInterval is None:\n...         print('None')  # if other voice had a rest...\n...     else:\n...         print(n.editorial.melodicInterval.directedName)\nNone\nM2\nP1",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "augmentOrDiminish",
        "type": "Title"
    },
    {
        "text": "amountToScale",
        "type": "Title"
    },
    {
        "text": "inPlace",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Given a number greater than zero,\nmultiplies the current quarterLength of the\nduration of each element by this number\nas well as their offset and returns a new Stream.\nOr if inPlace is\nset to True, modifies the durations of each\nelement within the stream.\nA number of 0.5 will halve the durations and relative\noffset positions; a number of 2 will double the\ndurations and relative offset positions.\nNote that the default for inPlace is the opposite\nof what it is for augmentOrDiminish on a Duration.\nThis is done purposely to reflect the most common\nusage.\n>>> s = stream.Stream()\n>>> n = note.Note()\n>>> s.repeatAppend(n, 10)\n>>> s.highestOffset, s.highestTime\n(9.0, 10.0)\n>>> s1 = s.augmentOrDiminish(2)\n>>> s1.highestOffset, s1.highestTime\n(18.0, 20.0)\n>>> s1 = s.augmentOrDiminish(0.5)\n>>> s1.highestOffset, s1.highestTime\n(4.5, 5.0)",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "beatAndMeasureFromOffset",
        "type": "Title"
    },
    {
        "text": "searchOffset",
        "type": "Title"
    },
    {
        "text": "fixZeros",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Returns a two-element tuple of the beat and the Measure object (or the first one\nif there are several at the same offset; unlikely but possible) for a given\noffset from the start of this Stream (that contains measures).\nRecursively searches for measures.  Note that this method assumes that all parts\nhave measures of consistent length.  If that's not the case, this\nmethod can be called on the relevant part.\nThis algorithm should work even for weird time signatures such as 2+3+2/8.\n>>> bach = corpus.parse('bach/bwv1.6')\n>>> bach.parts[0].measure(2).getContextByClass(meter.TimeSignature)\n<music21.meter.TimeSignature 4/4>\n>>> returnTuples = []\n>>> for offset in [0.0, 1.0, 2.0, 5.0, 5.5]:\n...     returnTuples.append(bach.beatAndMeasureFromOffset(offset))\n>>> returnTuples\n[(4.0, <music21.stream.Measure 0 offset=0.0>),\n (1.0, <music21.stream.Measure 1 offset=1.0>),\n (2.0, <music21.stream.Measure 1 offset=1.0>),\n (1.0, <music21.stream.Measure 2 offset=5.0>),\n (1.5, <music21.stream.Measure 2 offset=5.0>)]\n\n\nTo get just the measureNumber and beat, use a transformation like this:\n>>> [(beat, measureObj.number) for beat, measureObj in returnTuples]\n[(4.0, 0), (1.0, 1), (2.0, 1), (1.0, 2), (1.5, 2)]\nAdapted from contributed code by Dmitri Tymoczko.  With thanks to DT.",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "chordify",
        "type": "Title"
    },
    {
        "text": "addTies",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "addPartIdAsGroup",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "removeRedundantPitches",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "toSoundingPitch",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "copyPitches",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Create a chordal reduction of polyphonic music, where each\nchange to a new pitch results in a new chord. If a Score or\nPart of Measures is provided, a Stream of Measures will be\nreturned. If a flat Stream of notes, or a Score of such\nStreams is provided, no Measures will be returned.\nIf using chordify with chord symbols, ensure that the ChordSymbol objects\nhave durations (by default, the duration of a ChordSymbol object is 0, unlike\na Chord object). If Harmony objects are not provided a duration, they\nwill not be included in the chordified output pitches but may appear as chord symbols\nin notation on the score. To realize the chord symbol durations on a score, call\nmusic21.harmony.realizeChordSymbolDurations() and pass in the score.\nThis functionality works by splitting all Durations in\nall parts, or if there are multiple parts by all unique offsets. All\nsimultaneous durations are then gathered into single chords.\nIf addPartIdAsGroup is True, all elements found in the\nStream will have their source Part id added to the\nelement's pitches' Group.  These groups names are useful\nfor partially \u009cde-chordifying\u009d the output.  If the element chordifies to\na Chord object, then the group will be found in each\nPitch element's .groups in Chord.pitches.  If the\nelement chordifies to a single Note then .pitch.groups\nwill hold the group name.\nThe addTies parameter currently does not work for pitches in Chords.\nIf toSoundingPitch is True, all parts that define one or\nmore transpositions will be transposed to sounding pitch before chordification.\nTrue by default.\n>>> s = stream.Score()\n>>> p1 = stream.Part()\n>>> p1.id = 'part1'\n>>> p1.insert(4, note.Note('C#4'))\n>>> p1.insert(5.3, note.Rest())\n>>> p2 = stream.Part()\n>>> p2.id = 'part2'\n>>> p2.insert(2.12, note.Note('D-4', type='half'))\n>>> p2.insert(5.5, note.Rest())\n>>> s.insert(0, p1)\n>>> s.insert(0, p2)\n>>> s.show('text', addEndTimes=True)\n{0.0 - 6.3} <music21.stream.Part part1>\n    {4.0 - 5.0} <music21.note.Note C#>\n    {5.3 - 6.3} <music21.note.Rest quarter>\n{0.0 - 6.5} <music21.stream.Part part2>\n    {2.12 - 4.12} <music21.note.Note D->\n    {5.5 - 6.5} <music21.note.Rest quarter>\n\n\n>>> cc = s.chordify()\n\n\n>>> cc[3]\n<music21.chord.Chord C#4>\n>>> cc[3].duration.quarterLength\nFraction(22, 25)\n\n\n>>> cc.show('text', addEndTimes=True)\n{0.0 - 2.12} <music21.note.Rest 53/25ql>\n{2.12 - 4.0} <music21.chord.Chord D-4>\n{4.0 - 4.12} <music21.chord.Chord C#4 D-4>\n{4.12 - 5.0} <music21.chord.Chord C#4>\n{5.0 - 6.5} <music21.note.Rest dotted-quarter>\n\n\nHere's how addPartIdAsGroup works:\n>>> cc2 = s.chordify(addPartIdAsGroup=True)\n>>> cSharpDFlatChord = cc2[2]\n>>> for p in cSharpDFlatChord.pitches:\n...     (str(p), p.groups)\n('C#4', ['part1'])\n('D-4', ['part2'])\n\n\n>>> s = stream.Stream()\n>>> p1 = stream.Part()\n>>> p1.insert(0, harmony.ChordSymbol('Cm', quarterLength=4.0))\n>>> p1.insert(2, note.Note('C2'))\n>>> p1.insert(4, harmony.ChordSymbol('D', quarterLength=4.0))\n>>> p1.insert(7, note.Note('A2'))\n>>> s.insert(0, p1)\n>>> s.chordify().show('text')\n{0.0} <music21.chord.Chord C3 E-3 G3>\n{2.0} <music21.chord.Chord C2 C3 E-3 G3>\n{3.0} <music21.chord.Chord C3 E-3 G3>\n{4.0} <music21.chord.Chord D3 F#3 A3>\n{7.0} <music21.chord.Chord A2 D3 F#3 A3>\n\n\nNote that ChordSymbol objects can also be chordified:\n>>> s = stream.Stream()\n>>> p2 = stream.Part()\n>>> p1 = stream.Part()\n>>> p2.insert(0, harmony.ChordSymbol('Cm', quarterLength=4.0))\n>>> p1.insert(2, note.Note('C2'))\n>>> p2.insert(4, harmony.ChordSymbol('D', quarterLength=4.0))\n>>> p1.insert(7, note.Note('A2'))\n>>> s.insert(0, p1)\n>>> s.insert(0, p2)\n>>> s.chordify().show('text')\n{0.0} <music21.chord.Chord C3 E-3 G3>\n{2.0} <music21.chord.Chord C2 C3 E-3 G3>\n{3.0} <music21.chord.Chord C3 E-3 G3>\n{4.0} <music21.chord.Chord D3 F#3 A3>\n{7.0} <music21.chord.Chord A2 D3 F#3 A3>\n\n\nIf addPartIdAsGroup is True, and there are redundant pitches,\nensure that the merged pitch has both groups\n>>> s = stream.Score()\n>>> p0 = stream.Part(id='p0')\n>>> p0.insert(0, note.Note('C4'))\n>>> p1 = stream.Part(id='p1')\n>>> p1.insert(0, note.Note('C4'))\n>>> s.insert(0, p0)\n>>> s.insert(0, p1)\n>>> s1 = s.chordify(addPartIdAsGroup=True)\n>>> c = s1.recurse().notes[0]\n>>> c\n<music21.chord.Chord C4>\n>>> c.pitches[0].groups\n['p0', 'p1']\n\n\nWith copyPitches = False, then the original pitches are retained, which\ntogether with removeRedundantPitches=False can be a powerful tool for\nworking back to the original score:\n>>> n00 = note.Note('C4')\n>>> n01 = note.Note('E4')\n>>> n10 = note.Note('E4', type='half')\n>>> p0 = stream.Part(id='p0')\n>>> p1 = stream.Part(id='p1')\n>>> p0.append([n00, n01])\n>>> p1.append(n10)\n>>> s = stream.Score()\n>>> s.insert(0, p0)\n>>> s.insert(0, p1)\n>>> ss = s.chordify(removeRedundantPitches=False, copyPitches=False, addPartIdAsGroup=True)\n>>> ss.show('text')\n{0.0} <music21.chord.Chord C4 E4>\n{1.0} <music21.chord.Chord E4 E4>\n\n\n>>> c1 = ss.recurse().notes[1]\n>>> for p in c1.pitches:\n...     if 'p0' in p.groups:\n...         p.step = 'G'  # make a complete triad\n>>> n01\n<music21.note.Note G>\n\n\n\nChanged in v5:\n- Runs a little faster for small scores and run a TON faster for big scores\nrunning in O(n) time not O(n^2)\n- no longer supported: displayTiedAccidentals=False,\nChanged in v6.3: Added copyPitches",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "clear",
        "type": "Title"
    },
    {
        "text": "\u2192 None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Remove all elements in a stream.\n>>> m = stream.Measure(number=3)\n>>> m.append(note.Note('C'))\n>>> m.storeAtEnd(bar.Barline('final'))\n>>> len(m)\n2\n>>> m.clear()\n>>> len(m)\n0\n\n\nDoes not remove any other attributes\n>>> m.number\n3",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "cloneEmpty",
        "type": "Title"
    },
    {
        "text": "derivationMethod",
        "type": "Title"
    },
    {
        "text": "str | None",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u2192 StreamType",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Create a Stream that is identical to this one except that the elements are empty\nand set derivation.\n>>> p = stream.Part()\n>>> p.autoSort = False\n>>> p.id = 'hi'\n>>> p.insert(0, note.Note())\n>>> q = p.cloneEmpty(derivationMethod='demo')\n>>> q.autoSort\nFalse\n>>> q\n<music21.stream.Part hi>\n>>> q.derivation.origin is p\nTrue\n>>> q.derivation.method\n'demo'\n>>> len(q)\n0",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "containerInHierarchy",
        "type": "Title"
    },
    {
        "text": "el",
        "type": "Title"
    },
    {
        "text": "Music21Object",
        "type": "Title"
    },
    {
        "text": "setActiveSite",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "\u2192 Stream | None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Returns the container in a hierarchy that this element belongs to.\nFor instance, assume a Note (n) is in a Measure (m1) which is in a Part, in a Score (s1),\nand the Note is also in another hierarchy (say, a chordified version of a Score, s2).\nif s1.containerInHierarchy(n) is called, it will return m1,\nthe Measure that contains the note.\nUnless setActiveSite is False, n's activeSite will be set to m1, and\nits .offset will be the offset in m1.\n>>> s1 = stream.Score(id='s1')\n>>> p1 = stream.Part()\n>>> m1 = stream.Measure(id='m1')\n>>> n = note.Note('D')\n>>> m1.append(n)\n>>> p1.append(m1)\n>>> s1.insert(0, p1)\n>>> s2 = stream.Stream(id='s2')\n>>> s2.append(n)\n>>> n.activeSite.id\n's2'\n>>> s1.containerInHierarchy(n).id\n'm1'\n>>> n.activeSite.id\n'm1'\n>>> n.activeSite = s2\n>>> s1.containerInHierarchy(n, setActiveSite=False).id\n'm1'\n>>> n.activeSite.id\n's2'\n\n\nIf the element cannot be found in the hierarchy then None is returned.\n>>> s3 = stream.Stream()\n>>> s3.containerInHierarchy(n) is None\nTrue",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "elementOffset",
        "type": "Title"
    },
    {
        "text": "element",
        "type": "Title"
    },
    {
        "text": "returnSpecial",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Return the offset as an opFrac (float or Fraction) from the offsetMap.\nhighly optimized for speed.\n>>> m = stream.Measure(number=1)\n>>> m.append(note.Note('C'))\n>>> d = note.Note('D')\n>>> m.append(d)\n>>> m.elementOffset(d)\n1.0\n\n\nIf returnSpecial is True then returns like OffsetSpecial.AT_END are allowed.\n>>> b = bar.Barline()\n>>> m.storeAtEnd(b)\n>>> m.elementOffset(b)\n2.0\n>>> m.elementOffset(b, returnSpecial=True)\n<OffsetSpecial.AT_END>\n\n\nUnlike element.getOffsetBySite(self), this method will NOT follow derivation chains\nand in fact will raise a sites.SitesException\n>>> import copy\n>>> p = stream.Part(id='sPart')\n>>> p.insert(20, m)\n>>> m.getOffsetBySite(p)\n20.0\n>>> p.elementOffset(m)\n20.0\n\n\n>>> mCopy = copy.deepcopy(m)\n>>> mCopy.number = 10\n>>> mCopy.derivation\n<Derivation of <music21.stream.Measure 10 offset=0.0> from\n    <music21.stream.Measure 1 offset=20.0> via '__deepcopy__'>\n>>> mCopy.getOffsetBySite(p)\n20.0\n>>> p.elementOffset(mCopy)\nTraceback (most recent call last):\nmusic21.sites.SitesException: an entry for this object 0x... is not stored in\n    stream <music21.stream.Part sPart>\n\n\nPerformance note: because it will not follow derivation chains, and does\nnot need to unwrap a weakref, this method\nshould usually be about 3x faster than element.getOffsetBySite(self) \u2014\ncurrently 600ns instead of 1.5 microseconds.",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "expandRepeats",
        "type": "Title"
    },
    {
        "text": "copySpanners",
        "type": "Title"
    },
    {
        "text": "bool",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "\u2192 StreamType",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Expand this Stream with repeats. Nested repeats\ngiven with Repeat objects, or\nrepeats and sections designated with\nRepeatExpression objects, are all expanded.\nThis method always returns a new Stream, with\ndeepcopies of all contained elements at all levels.\nUses the Expander object in the repeat module.",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "explode",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Create a multiple Part representation from a single polyphonic Part.\nCurrently just runs voicesToParts()\nbut that will change as part explosion develops, and this\nmethod will use our best available quick method for part\nextraction.",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "extendDuration",
        "type": "Title"
    },
    {
        "text": "objClass",
        "type": "Title"
    },
    {
        "text": "inPlace",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Given a Stream and an object class name, go through the Stream\nand find each instance of the desired object. The time between\nadjacent objects is then assigned to the duration of each object.\nThe last duration of the last object is assigned to extend to the\nend of the Stream.\nIf inPlace is True, this is done in-place; if inPlace is\nFalse, this returns a modified deep copy.\n>>> stream1 = stream.Stream()\n>>> n = note.Note(type='quarter')\n>>> n.duration.quarterLength\n1.0\n>>> stream1.repeatInsert(n, [0, 10, 20, 30, 40])\n\n\n>>> dyn = dynamics.Dynamic('ff')\n>>> stream1.insert(15, dyn)\n>>> stream1[-1].offset  # offset of last element\n40.0\n>>> stream1.duration.quarterLength  # total duration\n41.0\n>>> len(stream1)\n6\n\n\n>>> stream2 = stream1.flatten().extendDuration(note.GeneralNote, inPlace=False)\n>>> len(stream2)\n6\n>>> stream2[0].duration.quarterLength\n10.0\n\n\nThe Dynamic does not affect the second note:\n>>> stream2[1].offset\n10.0\n>>> stream2[1].duration.quarterLength\n10.0\n\n\n>>> stream2[-1].duration.quarterLength  # or extend to end of stream\n1.0\n>>> stream2.duration.quarterLength\n41.0\n>>> stream2[-1].offset\n40.0",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "extendTies",
        "type": "Title"
    },
    {
        "text": "ignoreRests",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "pitchAttr",
        "type": "Title"
    },
    {
        "text": "'nameWithOctave'",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Connect any adjacent pitch space values that are the\nsame with a Tie. Adjacent pitches can be Chords, Notes, or Voices.\nIf ignoreRests is True, rests that occur between events will not be\nconsidered in matching pitches.\nThe pitchAttr determines the pitch attribute that is\nused for comparison. Any valid pitch attribute name can be used.",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "extractContext",
        "type": "Title"
    },
    {
        "text": "searchElement",
        "type": "Title"
    },
    {
        "text": "before",
        "type": "Title"
    },
    {
        "text": "4.0",
        "type": "UncategorizedText"
    },
    {
        "text": "after",
        "type": "Title"
    },
    {
        "text": "4.0",
        "type": "UncategorizedText"
    },
    {
        "text": "maxBefore",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "maxAfter",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Extracts elements around the given element within (before)\nquarter notes and (after) quarter notes (default 4), and\nreturns a new Stream.\n>>> qn = note.Note(type='quarter')\n>>> qtrStream = stream.Stream()\n>>> qtrStream.repeatInsert(qn, [0, 1, 2, 3, 4, 5])\n>>> hn = note.Note(type='half')\n>>> hn.name = 'B-'\n>>> qtrStream.append(hn)\n>>> qtrStream.repeatInsert(qn, [8, 9, 10, 11])\n>>> hnStream = qtrStream.extractContext(hn, 1.0, 1.0)\n>>> hnStream.show('text')\n{5.0} <music21.note.Note C>\n{6.0} <music21.note.Note B->\n{8.0} <music21.note.Note C>\n\n\n\nChanged in v7: forceOutputClass removed.",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "findConsecutiveNotes",
        "type": "Title"
    },
    {
        "text": "skipRests",
        "type": "Title"
    },
    {
        "text": "bool",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "skipChords",
        "type": "Title"
    },
    {
        "text": "Literal[False]",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "skipUnisons",
        "type": "Title"
    },
    {
        "text": "bool",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "skipOctaves",
        "type": "Title"
    },
    {
        "text": "bool",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "skipGaps",
        "type": "Title"
    },
    {
        "text": "bool",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "getOverlaps",
        "type": "Title"
    },
    {
        "text": "bool",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "noNone",
        "type": "Title"
    },
    {
        "text": "Literal[True]",
        "type": "Title"
    },
    {
        "text": "**",
        "type": "UncategorizedText"
    },
    {
        "text": "keywords",
        "type": "Title"
    },
    {
        "text": "\u2192 list[music21.note.NotRest]",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "findConsecutiveNotes",
        "type": "Title"
    },
    {
        "text": "skipRests",
        "type": "Title"
    },
    {
        "text": "bool",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "skipChords",
        "type": "Title"
    },
    {
        "text": "Literal[True]",
        "type": "Title"
    },
    {
        "text": "skipUnisons",
        "type": "Title"
    },
    {
        "text": "bool",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "skipOctaves",
        "type": "Title"
    },
    {
        "text": "bool",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "skipGaps",
        "type": "Title"
    },
    {
        "text": "bool",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "getOverlaps",
        "type": "Title"
    },
    {
        "text": "bool",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "noNone",
        "type": "Title"
    },
    {
        "text": "Literal[True]",
        "type": "Title"
    },
    {
        "text": "**",
        "type": "UncategorizedText"
    },
    {
        "text": "keywords",
        "type": "Title"
    },
    {
        "text": "\u2192 list[music21.note.Note]",
        "type": "Title"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "findConsecutiveNotes",
        "type": "Title"
    },
    {
        "text": "skipRests",
        "type": "Title"
    },
    {
        "text": "bool",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "skipChords",
        "type": "Title"
    },
    {
        "text": "bool",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "skipUnisons",
        "type": "Title"
    },
    {
        "text": "bool",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "skipOctaves",
        "type": "Title"
    },
    {
        "text": "bool",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "skipGaps",
        "type": "Title"
    },
    {
        "text": "bool",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "getOverlaps",
        "type": "Title"
    },
    {
        "text": "bool",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "noNone",
        "type": "Title"
    },
    {
        "text": "Literal[False]",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "**",
        "type": "UncategorizedText"
    },
    {
        "text": "keywords",
        "type": "Title"
    },
    {
        "text": "\u2192 list[music21.note.NotRest | None]",
        "type": "Title"
    },
    {
        "text": "Returns a list of consecutive pitched Notes in a Stream.\nA single \u009cNone\u009d is placed in the list\nat any point there is a discontinuity (such as if there is a\nrest between two pitches), unless the noNone parameter is True.\nHow to determine consecutive pitches is a little tricky and there are many options:\n\nThe skipUnisons parameter uses the midi-note value (.ps) to determine unisons,\nso enharmonic transitions (F# -> Gb) are\nalso skipped if skipUnisons is true.  We believe that this is the most common usage.\nHowever, because\nof this, you cannot completely be sure that the\nx.findConsecutiveNotes() - x.findConsecutiveNotes(skipUnisons=True)\nwill give you the number of P1s in the piece, because there could be\nd2's in there as well.\n\nSee test.TestStream.testFindConsecutiveNotes() for usage details.\nThis example is adapted from the tutorials/Examples page.\n>>> s = converter.parse(\"tinynotation: 4/4 f8 d'8~ d'8 d'8~ d'4 b'-8 a'-8 a-8\")\n>>> m = s.measure(1)\n>>> m.findConsecutiveNotes(skipUnisons=True, skipOctaves=True,\n...                        skipRests=True, noNone=True)\n[<music21.note.Note F>, <music21.note.Note D>,\n <music21.note.Note B->, <music21.note.Note A->]\n\n\n>>> m.findConsecutiveNotes(skipUnisons=False,\n...                        skipRests=True, noNone=True)\n[<music21.note.Note F>, <music21.note.Note D>,\n <music21.note.Note D>, <music21.note.Note D>, <music21.note.Note D>,\n <music21.note.Note B->, <music21.note.Note A->]\n\n\n\nChanged in v7:\n\nnow finds notes in Voices without requiring getOverlaps=True\nand iterates over Parts rather than flattening.\nIf noNone=False, inserts None\nwhen backing up to scan a subsequent voice or part.\n\n\nChanged in v8: all parameters are keyword only.",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "findGaps",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Returns either (1) a Stream containing empty Music21Objects\nwhose offsets and durations\nare the length of gaps in the Stream\nor (2) None if there are no gaps.\nN.B. there may be gaps in the flattened representation of the stream\nbut not in the unflattened.  Hence why \u009cisSequence\u009d calls self.flatten().isGapless\n>>> s = stream.Stream()\n>>> s.insert(1.0, note.Note('E', type='half'))\n>>> s.insert(5.0, note.Note('F', type='whole'))\n>>> s.storeAtEnd(bar.Barline('final'))\n>>> gapStream = s.findGaps()\n>>> gapStream.show('text', addEndTimes=True)\n{0.0 - 1.0} <music21.note.Rest quarter>\n{3.0 - 5.0} <music21.note.Rest half>\n\n\nReturns None if not gaps:\n>>> s2 = stream.Stream()\n>>> s2.append(note.Note('G'))\n>>> s2.findGaps() is None\nTrue\n\n\n\nChanged in v7: gapStream is filled with rests instead of Music21Objects",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "first",
        "type": "Title"
    },
    {
        "text": "\u2192 M21ObjType | None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Return the first element of a Stream.  (Added for compatibility with StreamIterator)\nOr None if the Stream is empty.\nUnlike s.iter().first(), which is a significant performance gain, s.first() is the\nsame speed as s[0], except for not raising an IndexError.\n>>> nC = note.Note('C4')\n>>> nD = note.Note('D4')\n>>> s = stream.Stream()\n>>> s.append([nC, nD])\n>>> s.first()\n<music21.note.Note C>\n\n\n>>> empty = stream.Stream()\n>>> print(empty.first())\nNone\n\n\n\nNew in v7.",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "flatten",
        "type": "Title"
    },
    {
        "text": "retainContainers",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "\u2192 StreamType",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "A very important method that returns a new Stream\nthat has all sub-containers \u009cflattened\u009d within it,\nthat is, it returns a new Stream where no elements nest within\nother elements.\nHere is a simple example of the usefulness of .flatten().  We\nwill create a Score with two Parts in it, each with two Notes:\n>>> sc = stream.Score()\n>>> p1 = stream.Part()\n>>> p1.id = 'part1'\n>>> n1 = note.Note('C4')\n>>> n2 = note.Note('D4')\n>>> p1.append(n1)\n>>> p1.append(n2)\n\n\n>>> p2 = stream.Part()\n>>> p2.id = 'part2'\n>>> n3 = note.Note('E4')\n>>> n4 = note.Note('F4')\n>>> p2.append(n3)\n>>> p2.append(n4)\n\n\n>>> sc.insert(0, p1)\n>>> sc.insert(0, p2)\n\n\nWhen we look at sc, we will see only the two parts:\n>>> sc.elements\n(<music21.stream.Part part1>, <music21.stream.Part part2>)\n\n\nWe can get at the notes by using the indices of the\nstream to get the parts and then looking at the .elements\nthere:\n>>> sc[0].elements\n(<music21.note.Note C>, <music21.note.Note D>)\n\n\n>>> sc.getElementById('part2').elements\n(<music21.note.Note E>, <music21.note.Note F>)\n\n\n\u2026but if we want to get all the notes, storing their\noffsets related to the beginning of the containing stream,\none way\nis via calling .flatten() on sc and looking at the elements\nthere:\n>>> sc.flatten().elements\n(<music21.note.Note C>, <music21.note.Note E>,\n <music21.note.Note D>, <music21.note.Note F>)\n\n\nFlattening a stream is a great way to get at all the notes in\na larger piece.  For instance if we load a four-part\nBach chorale into music21 from the integrated corpus, it\nwill appear at first that there are no notes in the piece:\n>>> bwv66 = corpus.parse('bach/bwv66.6')\n>>> len(bwv66.notes)\n0\n\n\nThis is because all the notes in the piece lie within music21.stream.Measure\nobjects and those measures lie within music21.stream.Part\nobjects.  It'd be a pain to navigate all the way through all those\nobjects just to count notes.  Fortunately we can get a Stream of\nall the notes in the piece with .flatten().notes and then use the\nlength of that Stream to count notes:\n>>> bwv66flat = bwv66.flatten()\n>>> len(bwv66flat.notes)\n165\n\n\nWhen, as is commonly the case, we want to find all the notes,\nbut do not care to have offsets related to the origin of the stream,\nthen .recurse() is a more efficient way of working:\n>>> len(bwv66.recurse().notes)\n165\n\n\nIf retainContainers=True then a \u009csemiFlat\u009d version of the stream\nis returned where Streams are also included in the output stream.\nIn general, you will not need to use this because .recurse() is\nmore efficient and does not lead to problems of the same\nobject appearing in the hierarchy more than once.\n>>> n1 = note.Note('C5')\n>>> m1 = stream.Measure([n1], number='1a')\n>>> p1 = stream.Part([m1])\n>>> p1.id = 'part1'\n\n\n>>> n2 = note.Note('D5')\n>>> m2 = stream.Measure([n2], number='1b')\n>>> p2 = stream.Part([m2])\n>>> p2.id = 'part2'\n\n\n>>> sc = stream.Score([p1, p2])\n\n\nsf will be the \u009csemi-flattened\u009d version of the score.\n>>> sf = sc.flatten(retainContainers=True)\n>>> sf.elements\n(<music21.stream.Part part1>,\n <music21.stream.Measure 1a offset=0.0>,\n <music21.stream.Part part2>,\n <music21.stream.Measure 1b offset=0.0>,\n <music21.note.Note C>,\n <music21.note.Note D>)\n>>> sf[0]\n<music21.stream.Part part1>\n\n\nNotice that these all return the same object:\n>>> sf[0][0][0]\n<music21.note.Note C>\n>>> sf[1][0]\n<music21.note.Note C>\n>>> sf[4]\n<music21.note.Note C>\n\n\nUnless it is important to get iterate in order from\nfront of score to back of the score, you are generally better off using recurse\ninstead of .flatten(retainContainers=True), with .getOffsetInHierarchy()\nto figure out where in the score each element lies.\nFor instance, this is how we can iterate using recurse():\n>>> for el in sc.recurse():\n...     print(el)\n<music21.stream.Part part1>\n<music21.stream.Measure 1a offset=0.0>\n<music21.note.Note C>\n<music21.stream.Part part2>\n<music21.stream.Measure 1b offset=0.0>\n<music21.note.Note D>\n\n\nIf you look back to our simple example of four notes above,\nyou can see that the E (the first note in part2) comes before the D\n(the second note of part1).  This is because the flat stream\nis automatically sorted like all streams are by default.  The\nnext example shows how to change this behavior.\n>>> s = stream.Stream()\n>>> s.autoSort = False\n>>> s.repeatInsert(note.Note('C#'), [0, 2, 4])\n>>> s.repeatInsert(note.Note('D-'), [1, 3, 5])\n>>> s.isSorted\nFalse\n\n\n>>> g = ''\n>>> for myElement in s:\n...    g += '%s: %s; ' % (myElement.offset, myElement.name)\n...\n\n\n>>> g\n'0.0: C#; 2.0: C#; 4.0: C#; 1.0: D-; 3.0: D-; 5.0: D-; '\n\n\n>>> y = s.sorted()\n>>> y.isSorted\nTrue\n\n\n>>> g = ''\n>>> for myElement in y:\n...    g += '%s: %s; ' % (myElement.offset, myElement.name)\n...\n\n\n>>> g\n'0.0: C#; 1.0: D-; 2.0: C#; 3.0: D-; 4.0: C#; 5.0: D-; '\n\n\n>>> q = stream.Stream()\n>>> for i in range(5):\n...     p = stream.Stream()\n...     p.repeatInsert(base.Music21Object(), [0, 1, 2, 3, 4])\n...     q.insert(i * 10, p)\n...\n\n\n>>> len(q)\n5\n\n\n>>> qf = q.flatten()\n>>> len(qf)\n25\n>>> qf[24].offset\n44.0\n\n\nNote that combining .flatten(retainContainers=True) with pure .flatten()\ncan lead to unstable Streams where the same object appears more than once,\nin violation of a music21 lookup rule.\n>>> sc.flatten(retainContainers=True).flatten().elements\n(<music21.note.Note C>,\n <music21.note.Note C>,\n <music21.note.Note C>,\n <music21.note.Note D>,\n <music21.note.Note D>,\n <music21.note.Note D>)",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "flattenUnnecessaryVoices",
        "type": "Title"
    },
    {
        "text": "force",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "inPlace",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "If this Stream defines one or more internal voices, do the following:\n\nIf there is more than one voice, and a voice has no elements,\nremove that voice.\nIf there is only one voice left that has elements, place those\nelements in the parent Stream.\nIf force is True, even if there is more than one Voice left,\nall voices will be flattened.\n\nThis leaves a stream where all voices appear when another appears in\nthe same measure.\nMore demonstrations of recurse=True:\n>>> s = stream.Stream(note.Note())\n>>> s.insert(0, note.Note())\n>>> s.insert(0, note.Note())\n>>> s.makeVoices(inPlace=True)\n>>> len(s.voices)\n3\n\n\n>>> s.remove(s.voices[1].notes[0], recurse=True)\n>>> s.remove(s.voices[2].notes[0], recurse=True)\n>>> voicesFlattened = s.flattenUnnecessaryVoices()\n>>> len(voicesFlattened.voices)\n0\n\n\n\nChanged in v5: inPlace is default False and a keyword only arg.",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "getElementAfterElement",
        "type": "Title"
    },
    {
        "text": "element",
        "type": "Title"
    },
    {
        "text": "classList",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Given an element, get the next element.  If classList is specified,\ncheck to make sure that the element is an instance of the class list\n>>> st1 = stream.Stream()\n>>> n1 = note.Note('C4')\n>>> n2 = note.Note('D4')\n>>> r3 = note.Rest()\n>>> st1.append([n1, n2, r3])\n>>> t2 = st1.getElementAfterElement(n1)\n>>> t2 is n2\nTrue\n>>> t3 = st1.getElementAfterElement(t2)\n>>> t3 is r3\nTrue\n>>> t4 = st1.getElementAfterElement(t3)\n>>> t4\n\n\n>>> t5 = st1.getElementAfterElement(n1, [note.Rest])\n>>> t5\n<music21.note.Rest quarter>\n>>> t5 is r3\nTrue\n>>> t6 = st1.getElementAfterElement(n1, [note.Rest, note.Note])\n>>> t6 is n2\nTrue\n\n\n>>> t7 = st1.getElementAfterElement(r3)\n>>> t7 is None\nTrue\n\n\nIf the element is not in the stream, it will raise a StreamException:\n>>> st1.getElementAfterElement(note.Note('C#'))\nTraceback (most recent call last):\nmusic21.exceptions21.StreamException:\n    cannot find object (<music21.note.Note C#>) in Stream",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "getElementAtOrBefore",
        "type": "Title"
    },
    {
        "text": "offset",
        "type": "Title"
    },
    {
        "text": "classList",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u2192 Music21Object | None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Given an offset, find the element at this offset,\nor with the offset less than and nearest to.\nReturn one element or None if no elements are at or preceded by this\noffset.\nIf the classList parameter is used, it should be a\nlist of class names or strings, and only objects that\nare instances of\nthese classes or subclasses of these classes will be returned.\n>>> stream1 = stream.Stream()\n>>> x = note.Note('D4')\n>>> x.id = 'x'\n>>> y = note.Note('E4')\n>>> y.id = 'y'\n>>> z = note.Rest()\n>>> z.id = 'z'\n\n\n>>> stream1.insert(20, x)\n>>> stream1.insert(10, y)\n>>> stream1.insert( 0, z)\n\n\n>>> b = stream1.getElementAtOrBefore(21)\n>>> b.offset, b.id\n(20.0, 'x')\n\n\n>>> b = stream1.getElementAtOrBefore(19)\n>>> b.offset, b.id\n(10.0, 'y')\n\n\n>>> b = stream1.getElementAtOrBefore(0)\n>>> b.offset, b.id\n(0.0, 'z')\n>>> b = stream1.getElementAtOrBefore(0.1)\n>>> b.offset, b.id\n(0.0, 'z')\n\n\nYou can give a list of acceptable classes to return, and non-matching\nelements will be ignored\n>>> c = stream1.getElementAtOrBefore(100, [clef.TrebleClef, note.Rest])\n>>> c.offset, c.id\n(0.0, 'z')\n\n\nGetting an object via getElementAtOrBefore sets the activeSite\nfor that object to the Stream, and thus sets its offset\n>>> stream2 = stream.Stream()\n>>> stream2.insert(100.5, x)\n>>> x.offset\n100.5\n>>> d = stream1.getElementAtOrBefore(20)\n>>> d is x\nTrue\n>>> x.activeSite is stream1\nTrue\n>>> x.offset\n20.0\n\n\nIf no element is before the offset, returns None\n>>> s = stream.Stream()\n>>> s.insert(10, note.Note('E'))\n>>> print(s.getElementAtOrBefore(9))\nNone\n\n\nThe sort order of returned items is the reverse\nof the normal sort order, so that, for instance,\nif there's a clef and a note at offset 20,\ngetting the object before offset 21 will give\nyou the note, and not the clef, since clefs\nsort before notes:\n>>> clef1 = clef.BassClef()\n>>> stream1.insert(20, clef1)\n>>> e = stream1.getElementAtOrBefore(21)\n>>> e\n<music21.note.Note D>",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "getElementBeforeOffset",
        "type": "Title"
    },
    {
        "text": "offset",
        "type": "Title"
    },
    {
        "text": "classList",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u2192 Music21Object | None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Get element before (and not at) a provided offset.\nIf the classList parameter is used, it should be a\nlist of class names or strings, and only objects that\nare instances of\nthese classes or subclasses of these classes will be returned.\n>>> stream1 = stream.Stream()\n>>> x = note.Note('D4')\n>>> x.id = 'x'\n>>> y = note.Note('E4')\n>>> y.id = 'y'\n>>> z = note.Rest()\n>>> z.id = 'z'\n>>> stream1.insert(20, x)\n>>> stream1.insert(10, y)\n>>> stream1.insert( 0, z)\n\n\n>>> b = stream1.getElementBeforeOffset(21)\n>>> b.offset, b.id\n(20.0, 'x')\n>>> b = stream1.getElementBeforeOffset(20)\n>>> b.offset, b.id\n(10.0, 'y')\n\n\n>>> b = stream1.getElementBeforeOffset(10)\n>>> b.offset, b.id\n(0.0, 'z')\n\n\n>>> b = stream1.getElementBeforeOffset(0)\n>>> b is None\nTrue\n>>> b = stream1.getElementBeforeOffset(0.1)\n>>> b.offset, b.id\n(0.0, 'z')\n\n\n>>> w = note.Note('F4')\n>>> w.id = 'w'\n>>> stream1.insert( 0, w)\n\n\nThis should get w because it was inserted last.\n>>> b = stream1.getElementBeforeOffset(0.1)\n>>> b.offset, b.id\n(0.0, 'w')\n\n\nBut if we give it a lower priority than z then z will appear first.\n>>> w.priority = z.priority - 1\n>>> b = stream1.getElementBeforeOffset(0.1)\n>>> b.offset, b.id\n(0.0, 'z')",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "getElementById",
        "type": "Title"
    },
    {
        "text": "elementId",
        "type": "Title"
    },
    {
        "text": "\u2192 Music21Object | None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Returns the first encountered element for a given id. Return None\nif no match. Note: this uses the id attribute stored on elements,\nwhich may not be the same as id(e).\n>>> a = stream.Stream()\n>>> ew = note.Note()\n>>> a.insert(0, ew)\n>>> a[0].id = 'green'\n>>> None == a.getElementById(3)\nTrue\n>>> a.getElementById('green').id\n'green'\n>>> a.getElementById('Green').id  # case does not matter\n'green'\n\n\nGetting an element by getElementById changes its activeSite\n>>> b = stream.Stream()\n>>> b.append(ew)\n>>> ew.activeSite is b\nTrue\n>>> ew2 = a.getElementById('green')\n>>> ew2 is ew\nTrue\n>>> ew2.activeSite is a\nTrue\n>>> ew.activeSite is a\nTrue\n\n\n\nChanged in v7: remove classFilter.",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "getElementsByClass",
        "type": "Title"
    },
    {
        "text": "classFilterList",
        "type": "Title"
    },
    {
        "text": "str",
        "type": "Title"
    },
    {
        "text": "Iterable",
        "type": "Title"
    },
    {
        "text": "str",
        "type": "Title"
    },
    {
        "text": "\u2192 StreamIterator[M21ObjType]",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "getElementsByClass",
        "type": "Title"
    },
    {
        "text": "classFilterList",
        "type": "Title"
    },
    {
        "text": "type[ChangedM21ObjType]",
        "type": "Title"
    },
    {
        "text": "\u2192 StreamIterator[ChangedM21ObjType]",
        "type": "Title"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "getElementsByClass",
        "type": "Title"
    },
    {
        "text": "classFilterList",
        "type": "Title"
    },
    {
        "text": "Iterable",
        "type": "Title"
    },
    {
        "text": "type",
        "type": "Title"
    },
    {
        "text": "ChangedM21ObjType",
        "type": "Title"
    },
    {
        "text": "\u2192 StreamIterator[M21ObjType]",
        "type": "Title"
    },
    {
        "text": "Return a StreamIterator that will iterate over Elements that match one\nor more classes in the classFilterList. A single class\ncan also be used for the classFilterList parameter instead of a List.\n>>> a = stream.Score()\n>>> a.repeatInsert(note.Rest(), list(range(10)))\n>>> for x in range(4):\n...     n = note.Note('G#')\n...     n.offset = x * 3\n...     a.insert(n)\n>>> found = a.getElementsByClass(note.Note)\n>>> found\n<music21.stream.iterator.StreamIterator for Score:0x118d20710 @:0>\n\n\n>>> len(found)\n4\n>>> found[0].pitch.accidental.name\n'sharp'\n\n\n>>> foundStream = found.stream()\n>>> isinstance(foundStream, stream.Score)\nTrue\n\n\nNotice that we do not find elements that are in\nsub-streams of the main Stream.  We'll add 15 more rests\nin a sub-stream, and they won't be found:\n>>> b = stream.Stream()\n>>> b.repeatInsert(note.Rest(), list(range(15)))\n>>> a.insert(b)\n>>> found = a.getElementsByClass(note.Rest)\n>>> len(found)\n10\n\n\nTo find them either (1) use .flatten() to get at everything:\n>>> found = a.flatten().getElementsByClass(note.Rest)\n>>> len(found)\n25\n\n\nOr, (2) recurse over the main stream and call .getElementsByClass\non each one.  Notice that the first subStream is actually the outermost\nStream:\n>>> totalFound = 0\n>>> for subStream in a.recurse(streamsOnly=True, includeSelf=True):\n...     found = subStream.getElementsByClass(note.Rest)\n...     totalFound += len(found)\n>>> totalFound\n25\n\n\nThe class name of the Stream created is the same as the original:\n>>> found = a.getElementsByClass(note.Note).stream()\n>>> found.__class__.__name__\n'Score'\n\n\n\u2026except if returnStreamSubClass is False, which makes the method\nreturn a generic Stream:\n>>> found = a.getElementsByClass(note.Rest).stream(returnStreamSubClass=False)\n>>> found.__class__.__name__\n'Stream'\n\n\nMake a list from a StreamIterator:\n>>> foundList = list(a.recurse().getElementsByClass(note.Rest))\n>>> len(foundList)\n25",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "getElementsByGroup",
        "type": "Title"
    },
    {
        "text": "groupFilterList",
        "type": "Title"
    },
    {
        "text": "\u2192 StreamIterator",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": ">>> n1 = note.Note('C')\n>>> n1.groups.append('trombone')\n>>> n2 = note.Note('D')\n>>> n2.groups.append('trombone')\n>>> n2.groups.append('tuba')\n>>> n3 = note.Note('E')\n>>> n3.groups.append('tuba')\n>>> s1 = stream.Stream()\n>>> s1.append(n1)\n>>> s1.append(n2)\n>>> s1.append(n3)\n>>> tboneSubStream = s1.getElementsByGroup('trombone')\n>>> for thisNote in tboneSubStream:\n...     print(thisNote.name)\nC\nD\n>>> tubaSubStream = s1.getElementsByGroup('tuba')\n>>> for thisNote in tubaSubStream:\n...     print(thisNote.name)\nD\nE",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "getElementsByOffset",
        "type": "Title"
    },
    {
        "text": "offsetStart",
        "type": "Title"
    },
    {
        "text": "offsetEnd",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "includeEndBoundary",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "mustFinishInSpan",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "mustBeginInSpan",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "includeElementsThatEndAtStart",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "classList",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u2192 StreamIterator",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Returns a StreamIterator containing all Music21Objects that\nare found at a certain offset or within a certain\noffset time range (given the offsetStart and (optional) offsetEnd values).\nThere are several attributes that govern how this range is\ndetermined:\nIf mustFinishInSpan is True then an event that begins\nbetween offsetStart and offsetEnd but which ends after offsetEnd\nwill not be included.  The default is False.\nFor instance, a half note at offset 2.0 will be found in\ngetElementsByOffset(1.5, 2.5) or getElementsByOffset(1.5, 2.5,\nmustFinishInSpan=False) but not by getElementsByOffset(1.5, 2.5,\nmustFinishInSpan=True).\nThe includeEndBoundary option determines if an element\nbegun just at the offsetEnd should be included.  For instance,\nthe half note at offset 2.0 above would be found by\ngetElementsByOffset(0, 2.0) or by getElementsByOffset(0, 2.0,\nincludeEndBoundary=True) but not by getElementsByOffset(0, 2.0,\nincludeEndBoundary=False).\nSetting includeEndBoundary to False at the same time as\nmustFinishInSpan is set to True is probably NOT what you want to do\nunless you want to find things like clefs at the end of the region\nto display as courtesy clefs.\nThe mustBeginInSpan option determines whether notes or other\nobjects that do not begin in the region but are still sounding\nat the beginning of the region are excluded.  The default is\nTrue \u2014 that is, these notes will not be included.\nFor instance the half note at offset 2.0 from above would not be found by\ngetElementsByOffset(3.0, 3.5) or getElementsByOffset(3.0, 3.5,\nmustBeginInSpan=True) but it would be found by\ngetElementsByOffset(3.0, 3.5, mustBeginInSpan=False)\nSetting includeElementsThatEndAtStart to False is useful for zeroLength\nsearches that set mustBeginInSpan == False to not catch notes that were\nplaying before the search but that end just before the end of the search type.\nThis setting is ignored for zero-length searches.\nSee the code for allPlayingWhileSounding for a demonstration.\nThis chart and the examples below demonstrate the various\nfeatures of getElementsByOffset.  It is one of the most complex\nmethods of music21 but also one of the most powerful, so it\nis worth learning at least the basics.\n\n\n\n>>> st1 = stream.Stream()\n>>> n0 = note.Note('C')\n>>> n0.duration.type = 'half'\n>>> n0.offset = 0\n>>> st1.insert(n0)\n>>> n2 = note.Note('D')\n>>> n2.duration.type = 'half'\n>>> n2.offset = 2\n>>> st1.insert(n2)\n>>> out1 = st1.getElementsByOffset(2)\n>>> len(out1)\n1\n>>> out1[0].step\n'D'\n\n\n>>> out2 = st1.getElementsByOffset(1, 3)\n>>> len(out2)\n1\n>>> out2[0].step\n'D'\n>>> out3 = st1.getElementsByOffset(1, 3, mustFinishInSpan=True)\n>>> len(out3)\n0\n>>> out4 = st1.getElementsByOffset(1, 2)\n>>> len(out4)\n1\n>>> out4[0].step\n'D'\n>>> out5 = st1.getElementsByOffset(1, 2, includeEndBoundary=False)\n>>> len(out5)\n0\n>>> out6 = st1.getElementsByOffset(1, 2, includeEndBoundary=False, mustBeginInSpan=False)\n>>> len(out6)\n1\n>>> out6[0].step\n'C'\n>>> out7 = st1.getElementsByOffset(1, 3, mustBeginInSpan=False)\n>>> len(out7)\n2\n>>> [el.step for el in out7]\n['C', 'D']\n\n\nNote, that elements that end at the start offset are included if mustBeginInSpan is False\n>>> out8 = st1.getElementsByOffset(2, 4, mustBeginInSpan=False)\n>>> len(out8)\n2\n>>> [el.step for el in out8]\n['C', 'D']\n\n\nTo change this behavior set includeElementsThatEndAtStart=False\n>>> out9 = st1.getElementsByOffset(2, 4,\n...                     mustBeginInSpan=False, includeElementsThatEndAtStart=False)\n>>> len(out9)\n1\n>>> [el.step for el in out9]\n['D']\n\n\nNote how zeroLengthSearches implicitly set includeElementsThatEndAtStart=False.\nThese two are the same:\n>>> out1 = st1.getElementsByOffset(2, mustBeginInSpan=False)\n>>> out2 = st1.getElementsByOffset(2, 2, mustBeginInSpan=False)\n>>> len(out1) == len(out2) == 1\nTrue\n>>> out1[0] is out2[0] is n2\nTrue\n\n\nBut this is different:\n>>> out3 = st1.getElementsByOffset(2, 2.1, mustBeginInSpan=False)\n>>> len(out3)\n2\n>>> out3[0] is n0\nTrue\n\n\nExplicitly setting includeElementsThatEndAtStart=False does not get the\nfirst note:\n>>> out4 = st1.getElementsByOffset(2, 2.1, mustBeginInSpan=False,\n...                                includeElementsThatEndAtStart=False)\n>>> len(out4)\n1\n>>> out4[0] is n2\nTrue\n\n\nTesting multiple zero-length elements with mustBeginInSpan:\n>>> tc = clef.TrebleClef()\n>>> ts = meter.TimeSignature('4/4')\n>>> ks = key.KeySignature(2)\n>>> s = stream.Stream()\n>>> s.insert(0.0, tc)\n>>> s.insert(0.0, ts)\n>>> s.insert(0.0, ks)\n>>> len(s.getElementsByOffset(0.0, mustBeginInSpan=True))\n3\n>>> len(s.getElementsByOffset(0.0, mustBeginInSpan=False))\n3",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "getElementsNotOfClass",
        "type": "Title"
    },
    {
        "text": "classFilterList",
        "type": "Title"
    },
    {
        "text": "\u2192 StreamIterator",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Return a list of all Elements that do not\nmatch the one or more classes in the classFilterList.\nIn lieu of a list, a single class can be used as the classFilterList parameter.\n>>> a = stream.Stream()\n>>> a.repeatInsert(note.Rest(), list(range(10)))\n>>> for x in range(4):\n...     n = note.Note('G#')\n...     n.offset = x * 3\n...     a.insert(n)\n>>> found = a.getElementsNotOfClass(note.Note)\n>>> len(found)\n10\n\n\n>>> b = stream.Stream()\n>>> b.repeatInsert(note.Rest(), list(range(15)))\n>>> a.insert(b)\n\n\nHere, it gets elements from within a stream\nthis probably should not do this, as it is one layer lower\n>>> found = a.flatten().getElementsNotOfClass(note.Rest)\n>>> len(found)\n4\n>>> found = a.flatten().getElementsNotOfClass(note.Note)\n>>> len(found)\n25",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "getInstrument",
        "type": "Title"
    },
    {
        "text": "searchActiveSite",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "returnDefault",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "recurse",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "\u2192 Instrument | None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Return the first Instrument found in this Stream, or None.\n>>> s = stream.Score()\n>>> p1 = stream.Part()\n>>> p1.insert(instrument.Violin())\n>>> m1p1 = stream.Measure()\n>>> m1p1.append(note.Note('g'))\n>>> p1.append(m1p1)\n\n\n>>> p2 = stream.Part()\n>>> p2.insert(instrument.Viola())\n>>> m1p2 = stream.Measure()\n>>> m1p2.append(note.Note('f#'))\n>>> p2.append(m1p2)\n\n\n>>> s.insert(0, p1)\n>>> s.insert(0, p2)\n>>> p1.getInstrument(returnDefault=False).instrumentName\n'Violin'\n>>> p2.getInstrument(returnDefault=False).instrumentName\n'Viola'\n\n\n\nChanged in v7: added recurse (default False)",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "getInstruments",
        "type": "Title"
    },
    {
        "text": "searchActiveSite",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "returnDefault",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "recurse",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "\u2192 Stream[Instrument]",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Search this stream (and, by default, its subStreams) or activeSite streams for\nInstrument objects, and return a new stream\ncontaining them.\n>>> m1 = stream.Measure([meter.TimeSignature('4/4'),\n...                      instrument.Clarinet(),\n...                      note.Note('C5', type='whole')])\n>>> m2 = stream.Measure([instrument.BassClarinet(),\n...                      note.Note('C3', type='whole')])\n>>> p = stream.Part([m1, m2])\n>>> instruments = p.getInstruments()\n>>> instruments\n<music21.stream.Part 0x112ac26e0>\n\n\n>>> instruments.show('text')\n{0.0} <music21.instrument.Clarinet 'Clarinet'>\n{4.0} <music21.instrument.BassClarinet 'Bass clarinet'>\n\n\nIf there are no instruments, returns a Stream containing a single default Instrument,\nunless returnDefault is False.\n>>> p = stream.Part()\n>>> m = stream.Measure([note.Note()])\n>>> p.insert(0, m)\n>>> instrumentStream = p.getInstruments(returnDefault=True)\n>>> defaultInst = instrumentStream.first()\n>>> defaultInst\n<music21.instrument.Instrument ': '>\n\n\nInsert an instrument into the Part (not the Measure):\n>>> p.insert(0, instrument.Koto())\n\n\nSearching the measure will find this instrument only if the measure's activeSite is\nsearched, as it is by default:\n>>> searchedActiveSite = p.measure(1).getInstruments()\n>>> searchedActiveSite.first()\n<music21.instrument.Koto 'Koto'>\n\n\n>>> searchedNaive = p.measure(1).getInstruments(searchActiveSite=False, returnDefault=False)\n>>> len(searchedNaive)\n0\n\n\n\nChanged in v8: recurse is True by default.",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "getOverlaps",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Find any elements that overlap. Overlapping might include elements\nthat have zero-length duration simultaneous.\nThis method returns a dictionary, where keys\nare the start time of the first overlap and\nvalue are a list of all objects included in\nthat overlap group.\nThis example demonstrates that end-joining overlaps do not count.\n>>> a = stream.Stream()\n>>> for x in range(4):\n...     n = note.Note('G#')\n...     n.duration = duration.Duration('quarter')\n...     n.offset = x * 1\n...     a.insert(n)\n...\n>>> d = a.getOverlaps()\n>>> len(d)\n0\n\n\nNotes starting at the same time overlap:\n>>> a = stream.Stream()\n>>> for x in [0, 0, 0, 0, 13, 13, 13]:\n...     n = note.Note('G#')\n...     n.duration = duration.Duration('half')\n...     n.offset = x\n...     a.insert(n)\n...\n>>> d = a.getOverlaps()\n>>> len(d[0])\n4\n>>> len(d[13])\n3\n>>> a = stream.Stream()\n>>> for x in [0, 0, 0, 0, 3, 3, 3]:\n...     n = note.Note('G#')\n...     n.duration = duration.Duration('whole')\n...     n.offset = x\n...     a.insert(n)\n...\n\n\nDefault is to not include coincident boundaries\n>>> d = a.getOverlaps()\n>>> len(d[0])\n7",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "getTimeSignatures",
        "type": "Title"
    },
    {
        "text": "searchContext",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "returnDefault",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "recurse",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "sortByCreationTime",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Collect all TimeSignature objects in this stream.\nIf no TimeSignature objects are defined, get a default (4/4 or whatever\nis defined in the defaults.py file).\n>>> s = stream.Part(id='changingMeter')\n>>> s.repeatInsert(note.Note('C#'), list(range(11)))\n\n\n>>> threeFour = meter.TimeSignature('3/4')\n>>> s.insert(0.0, threeFour)\n>>> twoTwo = meter.TimeSignature('2/2')\n>>> s.insert(3.0, twoTwo)\n>>> tsStream = s.getTimeSignatures()\n>>> tsStream.derivation.method\n'getTimeSignatures'\n\n\n>>> tsStream\n<music21.stream.Part changingMeter>\n>>> tsStream.show('text')\n{0.0} <music21.meter.TimeSignature 3/4>\n{3.0} <music21.meter.TimeSignature 2/2>\n\n\nThe contents of the time signature stream are the original, not copies\nof the original:\n>>> tsStream[0] is threeFour\nTrue\n\n\nMany time signatures are found within measures, so this method will find\nthem also and place them at the appropriate point within the overall Stream.\nN.B. if there are different time signatures for different parts, this method\nwill not distinguish which parts use which time signatures.\n>>> sm = s.makeMeasures()\n>>> sm.show('text')\n{0.0} <music21.stream.Measure 1 offset=0.0>\n    {0.0} <music21.clef.TrebleClef>\n    {0.0} <music21.meter.TimeSignature 3/4>\n    {0.0} <music21.note.Note C#>\n    {1.0} <music21.note.Note C#>\n    {2.0} <music21.note.Note C#>\n{3.0} <music21.stream.Measure 2 offset=3.0>\n    {0.0} <music21.meter.TimeSignature 2/2>\n    {0.0} <music21.note.Note C#>\n    {1.0} <music21.note.Note C#>\n    {2.0} <music21.note.Note C#>\n    {3.0} <music21.note.Note C#>\n{7.0} <music21.stream.Measure 3 offset=7.0>\n    {0.0} <music21.note.Note C#>\n    {1.0} <music21.note.Note C#>\n    {2.0} <music21.note.Note C#>\n    {3.0} <music21.note.Note C#>\n    {4.0} <music21.bar.Barline type=final>\n\n\n>>> tsStream2 = sm.getTimeSignatures()\n>>> tsStream2.show('text')\n{0.0} <music21.meter.TimeSignature 3/4>\n{3.0} <music21.meter.TimeSignature 2/2>\n\n\nIf you do not want this recursion, set recurse=False\n>>> len(sm.getTimeSignatures(recurse=False, returnDefault=False))\n0\n\n\nWe set returnDefault=False here, because otherwise a default time signature\nof 4/4 is returned:\n>>> sm.getTimeSignatures(recurse=False)[0]\n<music21.meter.TimeSignature 4/4>\n\n\nNote that a measure without any time signature can still find a context TimeSignature\nwith this method so long as searchContext is True (as by default):\n>>> m3 = sm.measure(3)\n>>> m3.show('text')\n{0.0} <music21.note.Note C#>\n{1.0} <music21.note.Note C#>\n{2.0} <music21.note.Note C#>\n{3.0} <music21.note.Note C#>\n{4.0} <music21.bar.Barline type=final>\n\n\n>>> m3.getTimeSignatures()[0]\n<music21.meter.TimeSignature 2/2>\n\n\nThe oldest context for the measure will be used unless sortByCreationTime is False, in which\ncase the typical order of context searching will be used.\n>>> p2 = stream.Part()\n>>> p2.insert(0, meter.TimeSignature('1/1'))\n>>> p2.append(m3)\n>>> m3.getTimeSignatures()[0]\n<music21.meter.TimeSignature 2/2>\n\n\nIf searchContext is False then the default will be returned (which is somewhat\nacceptable here, since there are 4 quarter notes in the measure) but not generally correct:\n>>> m3.getTimeSignatures(searchContext=False)[0]\n<music21.meter.TimeSignature 4/4>\n\n\n\nChanged in v8: time signatures within recursed streams are found by default.\nAdded recurse. Removed option for recurse=False and still getting the\nfirst time signature in the first measure.  This was wholly inconsistent.",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "hasElement",
        "type": "Title"
    },
    {
        "text": "obj",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Return True if an element, provided as an argument, is contained in\nthis Stream.\nThis method is based on object equivalence, not parameter equivalence\nof different objects.\n>>> s = stream.Stream()\n>>> n1 = note.Note('g')\n>>> n2 = note.Note('g#')\n>>> s.append(n1)\n>>> s.hasElement(n1)\nTrue",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "hasElementOfClass",
        "type": "Title"
    },
    {
        "text": "className",
        "type": "Title"
    },
    {
        "text": "forceFlat",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Given a single class name as string,\nreturn True or False if an element with the\nspecified class is found.\nOnly a single class name can be given.\n>>> s = stream.Stream()\n>>> s.append(meter.TimeSignature('5/8'))\n>>> s.append(note.Note('d-2'))\n>>> s.insert(dynamics.Dynamic('fff'))\n>>> s.hasElementOfClass(meter.TimeSignature)\nTrue\n>>> s.hasElementOfClass('Measure')\nFalse\n\n\nTo be deprecated in v8 \u2014 to be removed in v9, use:\n>>> bool(s.getElementsByClass(meter.TimeSignature))\nTrue\n>>> bool(s.getElementsByClass(stream.Measure))\nFalse\n\n\nforceFlat does nothing, while getElementsByClass can be done on recurse()",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "hasMeasures",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Return a boolean value showing if this Stream contains Measures.\n>>> p = stream.Part()\n>>> p.repeatAppend(note.Note(), 8)\n>>> p.hasMeasures()\nFalse\n>>> p.makeMeasures(inPlace=True)\n>>> len(p.getElementsByClass(stream.Measure))\n2\n>>> p.hasMeasures()\nTrue\n\n\nOnly returns True if the immediate Stream has measures, not if there are nested measures:\n>>> sc = stream.Score()\n>>> sc.append(p)\n>>> sc.hasMeasures()\nFalse",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "hasPartLikeStreams",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Return a boolean value showing if this Stream contains any Parts,\nor Part-like sub-Streams.\nPart-like sub-streams are Streams that contain Measures or Notes.\nAnd where no sub-stream begins at an offset besides zero.\n>>> s = stream.Score()\n>>> s.hasPartLikeStreams()\nFalse\n>>> p1 = stream.Part()\n>>> p1.repeatAppend(note.Note(), 8)\n>>> s.insert(0, p1)\n>>> s.hasPartLikeStreams()\nTrue\n\n\nA stream that has a measure in it is not a part-like stream.\n>>> s = stream.Score()\n>>> m1 = stream.Measure()\n>>> m1.repeatAppend(note.Note(), 4)\n>>> s.append(m1)\n>>> s.hasPartLikeStreams()\nFalse\n\n\nA stream with a single generic Stream substream at the beginning has part-like Streams\u2026\n>>> s = stream.Score()\n>>> m1 = stream.Stream()\n>>> m1.repeatAppend(note.Note(), 4)\n>>> s.append(m1)\n>>> s.hasPartLikeStreams()\nTrue\n\n\nAdding another though makes it not part-like.\n>>> m2 = stream.Stream()\n>>> m2.repeatAppend(note.Note(), 4)\n>>> s.append(m2)\n>>> s.hasPartLikeStreams()\nFalse\n\n\nFlat objects do not have part-like Streams:\n>>> sf = s.flatten()\n>>> sf.hasPartLikeStreams()\nFalse",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "hasVoices",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Return a boolean value showing if this Stream contains Voices",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "haveAccidentalsBeenMade",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "If Accidentals.displayStatus is None for all\ncontained pitches, it as assumed that accidentals\nhave not been set for display and/or makeAccidentals\nhas not been run. If any Accidental has displayStatus\nother than None, this method returns True, regardless\nof if makeAccidentals has actually been run.",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "index",
        "type": "Title"
    },
    {
        "text": "el",
        "type": "Title"
    },
    {
        "text": "Music21Object",
        "type": "Title"
    },
    {
        "text": "\u2192 int",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Return the first matched index for\nthe specified object.\nRaises a StreamException if the object cannot\nbe found.\n>>> s = stream.Stream()\n>>> n1 = note.Note('G')\n>>> n2 = note.Note('A')\n\n\n>>> s.insert(0.0, n1)\n>>> s.insert(5.0, n2)\n>>> len(s)\n2\n>>> s.index(n1)\n0\n>>> s.index(n2)\n1\n\n\nNote that this is done via Object identity, so another identical\nG won't be found in the stream.\n>>> n3 = note.Note('G')\n>>> s.index(n3)\nTraceback (most recent call last):\nmusic21.exceptions21.StreamException: cannot find object (<music21.note.Note G>) in Stream\n\n\nTo find the index of something equal to the object in the stream, cast the\nstream to a tuple or list first:\n>>> tuple(s).index(n3)\n0",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "insert",
        "type": "Title"
    },
    {
        "text": "offsetOrItemOrList",
        "type": "Title"
    },
    {
        "text": "itemOrNone",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "ignoreSort",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "setActiveSite",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Inserts an item(s) at the given offset(s).\nIf ignoreSort is True then the inserting does not\nchange whether the Stream is sorted or not (much faster if you're\ngoing to be inserting dozens\nof items that don't change the sort status)\nThe setActiveSite parameter should nearly always be True; only for\nadvanced Stream manipulation would you not change\nthe activeSite after inserting an element.\nHas three forms: in the two argument form, inserts an\nelement at the given offset:\n>>> st1 = stream.Stream()\n>>> st1.insert(32, note.Note('B-'))\n>>> st1.highestOffset\n32.0\n\n\nIn the single argument form with an object, inserts the element at its\nstored offset:\n>>> n1 = note.Note('C#')\n>>> n1.offset = 30.0\n>>> st1 = stream.Stream()\n>>> st1.insert(n1)\n>>> st2 = stream.Stream()\n>>> st2.insert(40.0, n1)\n>>> n1.getOffsetBySite(st1)\n30.0\n\n\nIn single argument form with a list, the list should\ncontain pairs that alternate\noffsets and items; the method then, obviously, inserts the items\nat the specified offsets.\nNote: This functionality will be deprecated in v9 and replaced\nwith a list of tuples of [(offset, element), (offset, element)]\nand removed in v10\n>>> n1 = note.Note('G')\n>>> n2 = note.Note('F#')\n>>> st3 = stream.Stream()\n>>> st3.insert([1.0, n1, 2.0, n2])\n>>> n1.getOffsetBySite(st3)\n1.0\n>>> n2.getOffsetBySite(st3)\n2.0\n>>> len(st3)\n2\n\n\nRaises an error if offset is not a number\n>>> stream.Stream().insert('l', note.Note('B'))\nTraceback (most recent call last):\nmusic21.exceptions21.StreamException: Offset 'l' must be a number.\n\n\n\u2026or if the object is not a music21 object (or a list of them)\n>>> stream.Stream().insert(3.3, 'hello')\nTraceback (most recent call last):\nmusic21.exceptions21.StreamException: The object you tried to add\n    to the Stream, 'hello', is not a Music21Object.\n    Use an ElementWrapper object if this is what you intend.\n\n\nThe error message is slightly different in the one-element form:\n>>> stream.Stream().insert('hello')\nTraceback (most recent call last):\nmusic21.exceptions21.StreamException: Cannot insert item 'hello' to\n    stream -- is it a music21 object?",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "insertAndShift",
        "type": "Title"
    },
    {
        "text": "offsetOrItemOrList",
        "type": "Title"
    },
    {
        "text": "itemOrNone",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Insert an item at a specified or native offset,\nand shift any elements found in the Stream to start at\nthe end of the added elements.\nThis presently does not shift elements that have durations\nthat extend into the lowest insert position.\n>>> st1 = stream.Stream()\n>>> st1.insertAndShift(32, note.Note('B'))\n>>> st1.highestOffset\n32.0\n>>> st1.insertAndShift(32, note.Note('C'))\n>>> st1.highestOffset\n33.0\n>>> st1.show('text', addEndTimes=True)\n{32.0 - 33.0} <music21.note.Note C>\n{33.0 - 34.0} <music21.note.Note B>\n\n\nLet's insert an item at the beginning, note that\nsince the C and B are not affected, they do not shift.\n>>> st1.insertAndShift(0, note.Note('D'))\n>>> st1.show('text', addEndTimes=True)\n{0.0 - 1.0} <music21.note.Note D>\n{32.0 - 33.0} <music21.note.Note C>\n{33.0 - 34.0} <music21.note.Note B>\n\n\nBut if we insert something again at the beginning of the stream,\neverything after the first shifted note begins shifting, so the\nC and the B shift even though there is a gap there.  Normally\nthere's no gaps in a stream, so this will not be a factor:\n>>> st1.insertAndShift(0, note.Note('E'))\n>>> st1.show('text', addEndTimes=True)\n{0.0 - 1.0} <music21.note.Note E>\n{1.0 - 2.0} <music21.note.Note D>\n{33.0 - 34.0} <music21.note.Note C>\n{34.0 - 35.0} <music21.note.Note B>\n\n\nIn the single argument form with an object, inserts the element at its stored offset:\n>>> n1 = note.Note('C#')\n>>> n1.offset = 30.0\n>>> n2 = note.Note('D#')\n>>> n2.offset = 30.0\n>>> st1 = stream.Stream()\n>>> st1.insertAndShift(n1)\n>>> st1.insertAndShift(n2)  # will shift offset of n1\n>>> n1.getOffsetBySite(st1)\n31.0\n>>> n2.getOffsetBySite(st1)\n30.0\n>>> st1.show('text', addEndTimes=True)\n{30.0 - 31.0} <music21.note.Note D#>\n{31.0 - 32.0} <music21.note.Note C#>\n\n\n>>> st2 = stream.Stream()\n>>> st2.insertAndShift(40.0, n1)\n>>> st2.insertAndShift(40.0, n2)\n>>> n1.getOffsetBySite(st2)\n41.0\n\n\nIn single argument form with a list, the list should contain pairs that alternate\noffsets and items; the method then, obviously, inserts the items\nat the specified offsets:\n>>> n1 = note.Note('G-')\n>>> n2 = note.Note('F-')\n>>> st3 = stream.Stream()\n>>> st3.insertAndShift([1.0, n1, 2.0, n2])\n>>> n1.getOffsetBySite(st3)\n1.0\n>>> n2.getOffsetBySite(st3)\n2.0\n>>> len(st3)\n2\n>>> st3.show('text', addEndTimes=True)\n{1.0 - 2.0} <music21.note.Note G->\n{2.0 - 3.0} <music21.note.Note F->\n\n\nN.B. \u2014 using this method on a list assumes that you'll be inserting\ncontiguous objects; you can't shift things that are separated, as this\nfollowing FAILED example shows.\n>>> n1 = note.Note('G', type='half')\n>>> st4 = stream.Stream()\n>>> st4.repeatAppend(n1, 3)\n>>> st4.insertAndShift([2.0, note.Note('e'), 4.0, note.Note('f')])\n>>> st4.show('text')\n{0.0} <music21.note.Note G>\n{2.0} <music21.note.Note E>\n{4.0} <music21.note.Note F>\n{5.0} <music21.note.Note G>\n{7.0} <music21.note.Note G>\n\n\nAs an FYI, there is no removeAndShift() function, so the opposite of\ninsertAndShift(el) is remove(el, shiftOffsets=True).",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "insertIntoNoteOrChord",
        "type": "Title"
    },
    {
        "text": "offset",
        "type": "Title"
    },
    {
        "text": "noteOrChord",
        "type": "Title"
    },
    {
        "text": "chordsOnly",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Insert a Note or Chord into an offset position in this Stream.\nIf there is another Note or Chord in this position,\ncreate a new Note or Chord that combines the pitches of the\ninserted chord. If there is a Rest in this position,\nthe Rest is replaced by the Note or Chord. The duration of the\npreviously-found chord will remain the same in the new Chord.\n>>> n1 = note.Note('D4')\n>>> n1.duration.quarterLength = 2.0\n>>> r1 = note.Rest()\n>>> r1.duration.quarterLength = 2.0\n>>> c1 = chord.Chord(['C4', 'E4'])\n>>> s = stream.Stream()\n>>> s.append(n1)\n>>> s.append(r1)\n>>> s.append(c1)\n>>> s.show('text')\n{0.0} <music21.note.Note D>\n{2.0} <music21.note.Rest half>\n{4.0} <music21.chord.Chord C4 E4>\n\n\nSave the original Streams for later\n>>> import copy\n>>> s2 = copy.deepcopy(s)\n>>> s3 = copy.deepcopy(s)\n>>> s4 = copy.deepcopy(s)\n\n\nNotice that the duration of the inserted element is not taken into\nconsideration and the original element is not broken up,\nas it would be in chordify().  But Chords and Notes are created\u2026\n>>> for i in [0.0, 2.0, 4.0]:\n...     s.insertIntoNoteOrChord(i, note.Note('F#4'))\n>>> s.show('text')\n{0.0} <music21.chord.Chord D4 F#4>\n{2.0} <music21.note.Note F#>\n{4.0} <music21.chord.Chord C4 E4 F#4>\n\n\nif chordsOnly is set to True then no notes are returned, only chords, but\nuntouched notes are left alone:\n>>> s2.insert(5.0, note.Note('E##4'))\n>>> for i in [0.0, 2.0, 4.0]:\n...     s2.insertIntoNoteOrChord(i, note.Note('F#4'), chordsOnly=True)\n>>> s2.show('text')\n{0.0} <music21.chord.Chord D4 F#4>\n{2.0} <music21.chord.Chord F#4>\n{4.0} <music21.chord.Chord C4 E4 F#4>\n{5.0} <music21.note.Note E##>\n\n\nA chord inserted on top of a note always changes the note into a chord:\n>>> s2.insertIntoNoteOrChord(5.0, chord.Chord('F#4 G-4'))\n>>> s2.show('text')\n{0.0} <music21.chord.Chord D4 F#4>\n{2.0} <music21.chord.Chord F#4>\n{4.0} <music21.chord.Chord C4 E4 F#4>\n{5.0} <music21.chord.Chord E##4 F#4 G-4>\n\n\nChords can also be inserted into rests:\n>>> s3.getElementsByOffset(2.0).first()\n<music21.note.Rest half>\n>>> s3.insertIntoNoteOrChord(2.0, chord.Chord('C4 E4 G#4'))\n>>> s3.show('text')\n{0.0} <music21.note.Note D>\n{2.0} <music21.chord.Chord C4 E4 G#4>\n{4.0} <music21.chord.Chord C4 E4>\n\n\nDespite the variable name, a rest could be inserted into a noteOrChord.\nIt does nothing to existing notes or chords, and just adds a new rest\nafterwards.\n>>> s4.show('text', addEndTimes=True)\n{0.0 - 2.0} <music21.note.Note D>\n{2.0 - 4.0} <music21.note.Rest half>\n{4.0 - 5.0} <music21.chord.Chord C4 E4>\n\n\n>>> for i in [0.0, 4.0, 6.0]:  # skipping 2.0 for now\n...     r = note.Rest(type='quarter')\n...     s4.insertIntoNoteOrChord(i, r)\n>>> r2 = note.Rest(type='quarter')\n>>> s4.insertIntoNoteOrChord(2.0, r)\n>>> s4.show('text', addEndTimes=True)\n{0.0 - 2.0} <music21.note.Note D>\n{2.0 - 4.0} <music21.note.Rest half>\n{4.0 - 5.0} <music21.chord.Chord C4 E4>\n{6.0 - 7.0} <music21.note.Rest quarter>\n\n\nNotice that (1) the original duration and not the new duration is used, unless\nthere is no element at that place, and (2) if an element is put into a place where\nno existing element was found, then it will be found in the new Stream, but if it\nis placed on top of an existing element, the original element or a new copy will remain:\n>>> r in s4\nTrue\n>>> r2 in s4\nFalse\n\n\nIf a Stream has more than one note, chord, or rest at that position,\ncurrently an error is raised.  This may change later:\n>>> s5 = stream.Stream()\n>>> s5.insert(0, note.Note('C##4'))\n>>> s5.insert(0, note.Note('E--4'))\n>>> s5.insertIntoNoteOrChord(0, note.Note('D4'))\nTraceback (most recent call last):\nmusic21.exceptions21.StreamException: more than one element found at the specified offset",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "invertDiatonic",
        "type": "Title"
    },
    {
        "text": "inversionNote=<music21.note.Note C>",
        "type": "Title"
    },
    {
        "text": "inPlace=False",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "inverts a stream diatonically around the given note (by default, middle C)\nFor pieces where the key signature\ndoes not change throughout the piece it is MUCH faster than\nfor pieces where the key signature changes.\nHere in this test, we put Ciconia's Quod Jactatur (a single voice\npiece that should have a canon solution: see trecento.quodJactatur)\ninto 3 flats (instead of its original 1 flat) in measure 1, but\ninto 5 sharps in measure 2 and then invert around F4, creating\na new piece.\n>>> qj = corpus.parse('ciconia/quod_jactatur').parts[0].measures(1, 2)\n>>> qj.id = 'measureExcerpt'\n\n\n>>> qj.show('text')\n{0.0} <music21.instrument.Piano 'P1: MusicXML Part: Grand Piano'>\n{0.0} <music21.stream.Measure 1 offset=0.0>\n    {0.0} <music21.layout.SystemLayout>\n    {0.0} <music21.clef.Treble8vbClef>\n    {0.0} <music21.tempo.MetronomeMark Quarter=120 (playback only)>\n    {0.0} <music21.key.Key of F major>\n    {0.0} <music21.meter.TimeSignature 2/4>\n    {0.0} <music21.note.Note C>\n    {1.5} <music21.note.Note D>\n{2.0} <music21.stream.Measure 2 offset=2.0>\n    {0.0} <music21.note.Note E>\n    {0.5} <music21.note.Note D>\n    {1.0} <music21.note.Note C>\n    {1.5} <music21.note.Note D>\n\n\n>>> qjFlat = qj.flatten()\n>>> k1 = qjFlat.getElementsByClass(key.KeySignature).first()\n>>> k3flats = key.KeySignature(-3)\n>>> qjFlat.replace(k1, k3flats, allDerived=True)\n>>> qj.getElementsByClass(stream.Measure)[1].insert(0, key.KeySignature(5))\n\n\n>>> qj2 = qj.invertDiatonic(note.Note('F4'), inPlace=False)\n>>> qj2.show('text')\n{0.0} <music21.instrument.Piano 'P1: MusicXML Part: Grand Piano'>\n{0.0} <music21.stream.Measure 1 offset=0.0>\n    {0.0} <music21.layout.SystemLayout>\n    {0.0} <music21.clef.Treble8vbClef>\n    {0.0} <music21.tempo.MetronomeMark Quarter=120 (playback only)>\n    {0.0} <music21.key.KeySignature of 3 flats>\n    {0.0} <music21.meter.TimeSignature 2/4>\n    {0.0} <music21.note.Note B->\n    {1.5} <music21.note.Note A->\n{2.0} <music21.stream.Measure 2 offset=2.0>\n    {0.0} <music21.key.KeySignature of 5 sharps>\n    {0.0} <music21.note.Note G#>\n    {0.5} <music21.note.Note A#>\n    {1.0} <music21.note.Note B>\n    {1.5} <music21.note.Note A#>\n\n\n\nChanged in v5: inPlace is False by default.",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "isSequence",
        "type": "Title"
    },
    {
        "text": "\u2192 bool",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "A stream is a sequence if it has no overlaps.\n>>> a = stream.Stream()\n>>> for x in [0, 0, 0, 0, 3, 3, 3]:\n...     n = note.Note('G#')\n...     n.duration = duration.Duration('whole')\n...     n.offset = x * 1\n...     a.insert(n)\n...\n>>> a.isSequence()\nFalse",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "isTwelveTone",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Return true if this Stream only employs twelve-tone equal-tempered pitch values.\n>>> s = stream.Stream()\n>>> s.append(note.Note('G#4'))\n>>> s.isTwelveTone()\nTrue\n>>> s.append(note.Note('G~4'))\n>>> s.isTwelveTone()\nFalse",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "isWellFormedNotation",
        "type": "Title"
    },
    {
        "text": "\u2192 bool",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Return True if, given the context of this Stream or Stream subclass,\ncontains what appears to be well-formed notation. This often means\nthe formation of Measures, or a Score that contains Part with Measures.\n>>> s = corpus.parse('bwv66.6')\n>>> s.isWellFormedNotation()\nTrue\n>>> s.parts[0].isWellFormedNotation()\nTrue\n>>> s.parts[0].getElementsByClass(stream.Measure).first().isWellFormedNotation()\nTrue\n\n\n>>> s2 = stream.Score()\n>>> m = stream.Measure()\n>>> s2.append(m)\n>>> s2.isWellFormedNotation()\nFalse\n\n\n>>> o = stream.Opus([s])\n>>> o.isWellFormedNotation()\nTrue\n>>> o2 = stream.Opus([s2])\n>>> o2.isWellFormedNotation()\nFalse\n\n\nOnly Measures and Voices are allowed to contain notes and rests directly:\n>>> m.isWellFormedNotation()\nTrue\n>>> s2.append(note.Rest())\n>>> s2.isWellFormedNotation()\nFalse",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "iter",
        "type": "Title"
    },
    {
        "text": "\u2192 StreamIterator[M21ObjType]",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "The Stream iterator, used in all for\nloops and similar iteration routines. This method returns the\nspecialized music21.stream.StreamIterator class, which\nadds necessary Stream-specific features.\nGenerally you don't need this, just iterate over a stream, but it is necessary\nto add custom filters to an iterative search before iterating.",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "last",
        "type": "Title"
    },
    {
        "text": "\u2192 M21ObjType | None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Return the last element of a Stream.  (Added for compatibility with StreamIterator)\nOr None if the Stream is empty.\ns.last() is the same speed as s[-1], except for not raising an IndexError.\n>>> nC = note.Note('C4')\n>>> nD = note.Note('D4')\n>>> s = stream.Stream()\n>>> s.append([nC, nD])\n>>> s.last()\n<music21.note.Note D>\n\n\n>>> empty = stream.Stream()\n>>> print(empty.last())\nNone\n\n\n\nNew in v7.",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "lyrics",
        "type": "Title"
    },
    {
        "text": "ignoreBarlines",
        "type": "Title"
    },
    {
        "text": "bool",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "recurse",
        "type": "Title"
    },
    {
        "text": "bool",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "skipTies",
        "type": "Title"
    },
    {
        "text": "bool",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "\u2192 dict[int, list[music21.note.Lyric | None | list[music21.note.Lyric | None | list[ForwardRef('RecursiveLyricList')]]]]",
        "type": "NarrativeText"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Returns a dict of lists of lyric objects (with the keys being\nthe lyric numbers) found in self. Each list will have an element for each\nnote in the stream (which may be a note.Lyric() or None).\nBy default, this method automatically\nrecurses through measures, but not other container streams.\n>>> s = converter.parse('tinynotation: 4/4 a4 b c d   e f g a', makeNotation=False)\n>>> someLyrics = ['this', 'is', 'a', 'list', 'of', 'eight', 'lyric', 'words']\n>>> for n, lyric in zip(s.notes, someLyrics):\n...     n.lyric = lyric\n\n\n>>> s.lyrics()\n{1: [<music21.note.Lyric number=1 syllabic=single text='this'>, ...,\n     <music21.note.Lyric number=1 syllabic=single text='words'>]}\n\n\n>>> s.notes[3].lyric = None\n>>> s.lyrics()[1]\n[<music21.note.Lyric number=1 syllabic=single text='this'>, ..., None, ...,\n <music21.note.Lyric number=1 syllabic=single text='words'>]\n\n\nIf ignoreBarlines is True, it will behave as if the elements in measures are all\nin a flattened stream (note that this is not stream.flatten()\nas it does not copy the elements)\ntogether without measure containers. This means that even if recurse is\nFalse, lyrics() will still essentially recurse through measures.\n>>> s.makeMeasures(inPlace=True)\n>>> s.lyrics()[1]\n[<music21.note.Lyric number=1 syllabic=single text='this'>, ..., None, ...,\n <music21.note.Lyric number=1 syllabic=single text='words'>]\n\n\n>>> list(s.lyrics(ignoreBarlines=False).keys())\n[]\n\n\nIf recurse is True, this method will recurse through all container streams and\nbuild a nested list structure mirroring the hierarchy of the stream.\nNote that if ignoreBarlines is True, measure structure will not be reflected\nin the hierarchy, although if ignoreBarlines is False, it will.\nNote that streams which do not contain any instance of a lyric number will not\nappear anywhere in the final list (not as a [] or otherwise).\n>>> scr = stream.Score(s)\n\n\n>>> scr.lyrics(ignoreBarlines=False, recurse=True)[1]\n[[[<music21.note.Lyric number=1 syllabic=single text='this'>, <...'is'>, <...'a'>, None],\n  [<...'of'>, <...'eight'>, <...'lyric'>, <...'words'>]]]\n\n\nNotice that the measures are nested in the part which is nested in the score.\n>>> scr.lyrics(ignoreBarlines=True, recurse=True)[1]\n[[<music21.note.Lyric number=1 syllabic=single text='this'>, <...'is'>, <...'a'>, None,\n  <...'of'>, <...'eight'>, <...'lyric'>, <...'words'>]]\n\n\nNotice that this time, the measure structure is ignored.\n>>> list(scr.lyrics(ignoreBarlines=True, recurse=False).keys())\n[]",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "makeAccidentals",
        "type": "Title"
    },
    {
        "text": "pitchPast",
        "type": "Title"
    },
    {
        "text": "list",
        "type": "Title"
    },
    {
        "text": "music21.pitch.Pitch",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "pitchPastMeasure",
        "type": "Title"
    },
    {
        "text": "list",
        "type": "Title"
    },
    {
        "text": "music21.pitch.Pitch",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "otherSimultaneousPitches",
        "type": "Title"
    },
    {
        "text": "list",
        "type": "Title"
    },
    {
        "text": "music21.pitch.Pitch",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "useKeySignature",
        "type": "Title"
    },
    {
        "text": "bool | KeySignature",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "alteredPitches",
        "type": "Title"
    },
    {
        "text": "list",
        "type": "Title"
    },
    {
        "text": "music21.pitch.Pitch",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "searchKeySignatureByContext",
        "type": "Title"
    },
    {
        "text": "bool",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "cautionaryPitchClass",
        "type": "Title"
    },
    {
        "text": "bool",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "cautionaryAll",
        "type": "Title"
    },
    {
        "text": "bool",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "inPlace",
        "type": "Title"
    },
    {
        "text": "bool",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "overrideStatus",
        "type": "Title"
    },
    {
        "text": "bool",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "cautionaryNotImmediateRepeat",
        "type": "Title"
    },
    {
        "text": "bool",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "tiePitchSet",
        "type": "Title"
    },
    {
        "text": "set",
        "type": "Title"
    },
    {
        "text": "str",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "A method to set and provide accidentals given various conditions and contexts.\npitchPast is a list of pitches preceding this pitch in this measure.\npitchPastMeasure is a list of pitches preceding this pitch but in a previous measure.\notherSimultaneousPitches is a list of other pitches in this simultaneity, for use\nwhen cautionaryPitchClass is True.\nIf useKeySignature is True, a KeySignature will be searched\nfor in this Stream or this Stream's defined contexts. An alternative KeySignature\ncan be supplied with this object and used for temporary pitch processing.\nIf alteredPitches is a list of modified pitches (Pitches with Accidentals) that\ncan be directly supplied to Accidental processing. These are the same values obtained\nfrom a music21.key.KeySignature object using the\nalteredPitches property.\nIf cautionaryPitchClass is True, comparisons to past accidentals are made regardless\nof register. That is, if a past sharp is found two octaves above a present natural,\na natural sign is still displayed.\nIf cautionaryAll is True, all accidentals are shown.\nIf overrideStatus is True, this method will ignore any current displayStatus setting\nfound on the Accidental. By default this does not happen. If displayStatus is set to\nNone, the Accidental's displayStatus is set.\nIf cautionaryNotImmediateRepeat is True, cautionary accidentals will be displayed for\nan altered pitch even if that pitch had already been displayed as altered.\nIf tiePitchSet is not None it should be a set of .nameWithOctave strings\nto determine whether following accidentals should be shown because the last\nnote of the same pitch had a start or continue tie.\nIf searchKeySignatureByContext is True then keySignatures from the context of the\nstream will be used if none found.\nThe updateAccidentalDisplay() method is used to determine if\nan accidental is necessary.\nThis will assume that the complete Stream is the context of evaluation. For smaller context\nranges, call this on Measure objects.\nIf inPlace is True, this is done in-place; if inPlace is False,\nthis returns a modified deep copy.\n\nChanged in v6: does not return anything if inPlace is True.\nChanged in v7: default inPlace is False\nChanged in v8: altered unisons/octaves in Chords now supply clarifying naturals.\n\nAll arguments are keyword only.",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "makeBeams",
        "type": "Title"
    },
    {
        "text": "inPlace",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "setStemDirections",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "failOnNoTimeSignature",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Return a new Stream, or modify the Stream in place, with beams applied to all\nnotes.\nSee makeBeams().\n\nNew in v6.7: setStemDirections.\nNew in v7: failOnNoTimeSignature raises StreamException if no TimeSignature\nexists in the stream context from which to make measures.",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "makeImmutable",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Clean this Stream: for self and all elements, purge all dead locations\nand remove all non-contained sites. Further, restore all active sites.",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "makeMeasures",
        "type": "Title"
    },
    {
        "text": "meterStream",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "refStreamOrTimeRange",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "searchContext",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "innerBarline",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "finalBarline",
        "type": "Title"
    },
    {
        "text": "'final'",
        "type": "Title"
    },
    {
        "text": "bestClef",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "inPlace",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Return a new stream (or if inPlace=True change in place) this\nStream so that it has internal measures.\nFor more details, see makeMeasures().",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "makeMutable",
        "type": "Title"
    },
    {
        "text": "recurse",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "makeNotation",
        "type": "Title"
    },
    {
        "text": "meterStream",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "refStreamOrTimeRange",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "inPlace",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "bestClef",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "pitchPast",
        "type": "Title"
    },
    {
        "text": "list",
        "type": "Title"
    },
    {
        "text": "music21.pitch.Pitch",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "pitchPastMeasure",
        "type": "Title"
    },
    {
        "text": "list",
        "type": "Title"
    },
    {
        "text": "music21.pitch.Pitch",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "useKeySignature",
        "type": "Title"
    },
    {
        "text": "bool | KeySignature",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "alteredPitches",
        "type": "Title"
    },
    {
        "text": "list",
        "type": "Title"
    },
    {
        "text": "music21.pitch.Pitch",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "cautionaryPitchClass",
        "type": "Title"
    },
    {
        "text": "bool",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "cautionaryAll",
        "type": "Title"
    },
    {
        "text": "bool",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "overrideStatus",
        "type": "Title"
    },
    {
        "text": "bool",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "cautionaryNotImmediateRepeat",
        "type": "Title"
    },
    {
        "text": "bool",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "tiePitchSet",
        "type": "Title"
    },
    {
        "text": "set",
        "type": "Title"
    },
    {
        "text": "str",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "This method calls a sequence of Stream methods on this Stream to prepare\nnotation, including creating voices for overlapped regions, Measures\nif necessary, creating ties, beams, accidentals, and tuplet brackets.\nIf inPlace is True, this is done in-place.\nif inPlace is False, this returns a modified deep copy.\nThe following additional parameters are documented on\nmakeAccidentals():\npitchPast\npitchPastMeasure\nuseKeySignature\nalteredPitches\ncautionaryPitchClass\ncautionaryAll\noverrideStatus\ncautionaryNotImmediateRepeat\ntiePitchSet\n\n\n>>> s = stream.Stream()\n>>> n = note.Note('g')\n>>> n.quarterLength = 1.5\n>>> s.repeatAppend(n, 10)\n>>> sMeasures = s.makeNotation()\n>>> len(sMeasures.getElementsByClass(stream.Measure))\n4\n>>> sMeasures.getElementsByClass(stream.Measure).last().rightBarline.type\n'final'\n\n\n\nChanged in v7: inPlace=True returns None.",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "makeRests",
        "type": "Title"
    },
    {
        "text": "refStreamOrTimeRange",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "fillGaps",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "timeRangeFromBarDuration",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "inPlace",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "hideRests",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Calls makeRests().\n\nChanged in v7, inPlace=False by default.",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "makeTies",
        "type": "Title"
    },
    {
        "text": "meterStream=None",
        "type": "Title"
    },
    {
        "text": "inPlace=False",
        "type": "Title"
    },
    {
        "text": "displayTiedAccidentals=False",
        "type": "Title"
    },
    {
        "text": "classFilterList=(<class 'music21.note.GeneralNote'>",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Calls makeTies().\n\nChanged in v4: inPlace=False by default.\nNew in v.7: classFilterList.",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "makeVoices",
        "type": "Title"
    },
    {
        "text": "inPlace",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "fillGaps",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "If this Stream has overlapping Notes or Chords, this method will isolate\nall overlaps in unique Voices, and place those Voices in the Stream.\n>>> s = stream.Stream()\n>>> s.insert(0, note.Note('C4', quarterLength=4))\n>>> s.repeatInsert(note.Note('b-4', quarterLength=0.5), [x * 0.5 for x in list(range(8))])\n>>> s.makeVoices(inPlace=True)\n>>> len(s.voices)\n2\n>>> [n.pitch for n in s.voices[0].notes]\n[<music21.pitch.Pitch C4>]\n>>> [str(n.pitch) for n in s.voices[1].notes]\n['B-4', 'B-4', 'B-4', 'B-4', 'B-4', 'B-4', 'B-4', 'B-4']\n\n\n\nChanged in v7: if fillGaps=True and called on an incomplete measure,\nmakes trailing rests in voices. This scenario occurs when parsing MIDI.",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "measure",
        "type": "Title"
    },
    {
        "text": "measureNumber",
        "type": "Title"
    },
    {
        "text": "collect",
        "type": "Title"
    },
    {
        "text": "('Clef', 'TimeSignature', 'Instrument', 'KeySignature')",
        "type": "Title"
    },
    {
        "text": "indicesNotNumbers",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "\u2192 Measure | None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Given a measure number, return a single\nMeasure object if the Measure number exists, otherwise return None.\nThis method is distinguished from measures()\nin that this method returns a single Measure object, not a Stream containing\none or more Measure objects.\n>>> a = corpus.parse('bach/bwv324.xml')\n>>> a.parts[0].measure(3)\n<music21.stream.Measure 3 offset=8.0>\n\n\nSee measures() for an explanation of collect and\nindicesNotNumbers\nTo get the last measure of a piece, use -1 as a measureNumber \u2014 this will turn\non indicesNotNumbers if it is off:\n>>> a.parts[0].measure(-1)\n<music21.stream.Measure 9 offset=38.0>\n\n\nGetting a non-existent measure will return None:\n>>> print(a.parts[0].measure(99))\nNone",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "measureOffsetMap",
        "type": "Title"
    },
    {
        "text": "classFilterList",
        "type": "Title"
    },
    {
        "text": "list",
        "type": "Title"
    },
    {
        "text": "Type",
        "type": "Title"
    },
    {
        "text": "list",
        "type": "Title"
    },
    {
        "text": "str",
        "type": "Title"
    },
    {
        "text": "tuple",
        "type": "Title"
    },
    {
        "text": "Type",
        "type": "Title"
    },
    {
        "text": "tuple",
        "type": "Title"
    },
    {
        "text": "str",
        "type": "Title"
    },
    {
        "text": "('Measure',)",
        "type": "Title"
    },
    {
        "text": "\u2192 OrderedDict[float | Fraction, list[music21.stream.base.Measure]]",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "If this Stream contains Measures, returns an OrderedDict\nwhose keys are the offsets of the start of each measure\nand whose values are a list of references\nto the Measure objects that start\nat that offset.\nEven in normal music there may be more than\none Measure starting at each offset because each\nPart might define its own Measure.\nHowever, you are unlikely to encounter such things unless you\nrun Score.flatten(retainContainers=True).\nThe offsets are always measured relative to the\ncalling Stream (self).\nYou can specify a classFilterList argument as a list of classes\nto find instead of Measures.  But the default will of course\nfind Measure objects.\nExample 1: This Bach chorale is in 4/4 without a pickup, so\nas expected, measures are found every 4 offsets, until the\nweird recitation in m. 7 which in our edition lasts 10 beats\nand thus causes a gap in measureOffsetMap from 24.0 to 34.0.\n\n>>> chorale = corpus.parse('bach/bwv324.xml')\n>>> alto = chorale.parts['#alto']\n>>> altoMeasures = alto.measureOffsetMap()\n>>> altoMeasures\nOrderedDict([(0.0, [<music21.stream.Measure 1 offset=0.0>]),\n             (4.0, [<music21.stream.Measure 2 offset=4.0>]),\n             (8.0, [<music21.stream.Measure 3 offset=8.0>]),\n             ...\n             (38.0, [<music21.stream.Measure 9 offset=38.0>])])\n>>> list(altoMeasures.keys())\n[0.0, 4.0, 8.0, 12.0, 16.0, 20.0, 24.0, 34.0, 38.0]\n\n\naltoMeasures is a dictionary of the measures\nthat are found in the alto part, so we can get\nthe measure beginning on offset 4.0 (measure 2)\nand display it (though it's the only measure\nfound at offset 4.0, there might be others as\nin example 2, so we need to call altoMeasures[4.0][0]\nto get this measure.):\n>>> altoMeasures[4.0]\n[<music21.stream.Measure 2 offset=4.0>]\n>>> altoMeasures[4.0][0].show('text')\n{0.0} <music21.note.Note D>\n{1.0} <music21.note.Note D#>\n{2.0} <music21.note.Note E>\n{3.0} <music21.note.Note F#>\n\n\nExample 2: How to get all the measures from all parts (not the\nmost efficient way, but it works!):\n>>> mom = chorale.measureOffsetMap()\n>>> mom\nOrderedDict([(0.0, [<music21.stream.Measure 1 offset=0.0>,\n                    <music21.stream.Measure 1 offset=0.0>,\n                    <music21.stream.Measure 1 offset=0.0>,\n                    <music21.stream.Measure 1 offset=0.0>]),\n              (4.0, [<music21.stream.Measure 2 offset=4.0>,\n                     ...])])\n>>> for measure_obj in mom[8.0]:\n...     print(measure_obj, measure_obj.getContextByClass(stream.Part).id)\n<music21.stream.Measure 3 offset=8.0> Soprano\n<music21.stream.Measure 3 offset=8.0> Alto\n<music21.stream.Measure 3 offset=8.0> Tenor\n<music21.stream.Measure 3 offset=8.0> Bass\n\n\nChanged in v9: classFilterList must be a list or tuple of strings or Music21Objects",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "measures",
        "type": "Title"
    },
    {
        "text": "numberStart",
        "type": "Title"
    },
    {
        "text": "numberEnd",
        "type": "Title"
    },
    {
        "text": "collect",
        "type": "Title"
    },
    {
        "text": "('Clef', 'TimeSignature', 'Instrument', 'KeySignature')",
        "type": "Title"
    },
    {
        "text": "gatherSpanners",
        "type": "Title"
    },
    {
        "text": "GatherSpanners.ALL",
        "type": "Title"
    },
    {
        "text": "indicesNotNumbers",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "\u2192 Stream[Measure]",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Get a region of Measures based on a start and end Measure number\nwhere the boundary numbers are both included.\nThat is, a request for measures 4 through 10 will return 7 Measures, numbers 4 through 10.\nAdditionally, any number of associated classes can be gathered from the context\nand put into the measure.  By default, we collect the Clef, TimeSignature, KeySignature,\nand Instrument so that there is enough context to perform.  (See getContextByClass()\nand .previous() for definitions of the context)\nWhile all elements in the source are the original elements in the extracted region,\nnew Measure objects are created and returned.\n>>> bachIn = corpus.parse('bach/bwv66.6')\n>>> bachExcerpt = bachIn.parts[0].measures(1, 3)\n>>> len(bachExcerpt.getElementsByClass(stream.Measure))\n3\n\n\nBecause bwv66.6 has a pickup measure, and we requested to start at measure 1,\nthis is NOT true:\n>>> firstExcerptMeasure = bachExcerpt.getElementsByClass(stream.Measure).first()\n>>> firstBachMeasure = bachIn.parts[0].getElementsByClass(stream.Measure).first()\n>>> firstExcerptMeasure is firstBachMeasure\nFalse\n>>> firstBachMeasure.number\n0\n>>> firstExcerptMeasure.number\n1\n\n\nTo get all measures from the beginning, go ahead and always request measure 0 to x,\nthere will be no error if there is not a pickup measure.\n>>> bachExcerpt = bachIn.parts[0].measures(0, 3)\n>>> excerptNote = bachExcerpt.getElementsByClass(stream.Measure).first().notes.first()\n>>> originalNote = bachIn.parts[0].recurse().notes[0]\n>>> excerptNote is originalNote\nTrue\n\n\nif indicesNotNumbers is True, then it ignores defined measureNumbers and\nuses 0-indexed measure objects and half-open range.  For instance, if you have a piece\nthat goes \u009cm1, m2, m3, m4, \u2026\u009d (like a standard piece without pickups, then\n.measures(1, 3, indicesNotNumbers=True) would return measures 2 and 3, because\nit is interpreted as the slice from object with index 1, which is measure 2 (m1 has\nan index of 0) up to but NOT including the object with index 3, which is measure 4.\nIndicesNotNumbers is like a Python-slice.\n>>> bachExcerpt2 = bachIn.parts[0].measures(0, 2, indicesNotNumbers=True)\n>>> for m in bachExcerpt2.getElementsByClass(stream.Measure):\n...     print(m)\n...     print(m.number)\n<music21.stream.Measure 0 offset=0.0>\n0\n<music21.stream.Measure 1 offset=1.0>\n1\n\n\nIf numberEnd=None then it is interpreted as the last measure of the stream:\n>>> bachExcerpt3 = bachIn.parts[0].measures(7, None)\n>>> for m in bachExcerpt3.getElementsByClass(stream.Measure):\n...     print(m)\n<music21.stream.Measure 7 offset=0.0>\n<music21.stream.Measure 8 offset=4.0>\n<music21.stream.Measure 9 offset=8.0>\n\n\nNote that the offsets in the new stream are shifted so that the first measure\nin the excerpt begins at 0.0\nThe measure elements are the same objects as the original:\n>>> lastExcerptMeasure = bachExcerpt3.getElementsByClass(stream.Measure).last()\n>>> lastOriginalMeasure = bachIn.parts[0].getElementsByClass(stream.Measure).last()\n>>> lastExcerptMeasure is lastOriginalMeasure\nTrue\n\n\nAt the beginning of the Stream returned, before the measures will be some additional\nobjects so that the context is properly preserved:\n>>> for thing in bachExcerpt3:\n...     print(thing)\nP1: Soprano: Instrument 1\n<music21.clef.TrebleClef>\nf# minor\n<music21.meter.TimeSignature 4/4>\n<music21.stream.Measure 7 offset=0.0>\n<music21.stream.Measure 8 offset=4.0>\n<music21.stream.Measure 9 offset=8.0>\n\n\nCollecting gets the most recent element in the context of the stream:\n>>> bachIn.parts[0].insert(10, key.Key('D-'))\n>>> bachExcerpt4 = bachIn.parts[0].measures(7, None)\n>>> for thing in bachExcerpt4:\n...     print(thing)\nP1: Soprano: Instrument 1\n<music21.clef.TrebleClef>\nD- major\n...\n\n\nWhat is collected is determined by the \u009ccollect\u009d iterable.  To collect nothing\nsend an empty list:\n>>> bachExcerpt5 = bachIn.parts[0].measures(8, None, collect=[])\n>>> for thing in bachExcerpt5:\n...     print(thing)\n<music21.stream.Measure 8 offset=0.0>\n<music21.stream.Measure 9 offset=4.0>\n\n\nIf a stream has measure suffixes, then Streams having that suffix or no suffix\nare returned.\n>>> p = stream.Part()\n>>> mSuffix3 = stream.Measure(number=3)\n>>> mSuffix4 = stream.Measure(number=4)\n>>> mSuffix4a = stream.Measure(number=4)\n>>> mSuffix4a.numberSuffix = 'a'\n>>> mSuffix4b = stream.Measure(number=4)\n>>> mSuffix4b.numberSuffix = 'b'\n>>> mSuffix5 = stream.Measure(number=5)\n>>> mSuffix5a = stream.Measure(number=5)\n>>> mSuffix5a.numberSuffix = 'a'\n>>> mSuffix6 = stream.Measure(number=6)\n>>> p.append([mSuffix3, mSuffix4, mSuffix4a, mSuffix4b, mSuffix5, mSuffix5a, mSuffix6])\n>>> suffixExcerpt = p.measures('4b', 6)\n>>> suffixExcerpt.show('text')\n{0.0} <music21.stream.Measure 4 offset=0.0>\n\n{0.0} <music21.stream.Measure 4b offset=0.0>\n\n{0.0} <music21.stream.Measure 5 offset=0.0>\n\n{0.0} <music21.stream.Measure 5a offset=0.0>\n\n{0.0} <music21.stream.Measure 6 offset=0.0>\n\n>>> suffixExcerpt2 = p.measures(3, '4a')\n>>> suffixExcerpt2.show('text')\n{0.0} <music21.stream.Measure 3 offset=0.0>\n\n{0.0} <music21.stream.Measure 4 offset=0.0>\n\n{0.0} <music21.stream.Measure 4a offset=0.0>\n\n\nGatherSpanners can change the output:\n>>> from music21.common.enums import GatherSpanners\n>>> beachIn = corpus.parse('beach')\n>>> beachExcerpt = beachIn.measures(3, 4, gatherSpanners=GatherSpanners.ALL)\n>>> len(beachExcerpt.spannerBundle)\n8\n>>> len(beachIn.spannerBundle)\n93\n\n\n\nChanged in v7: does not create measures automatically.\nChanged in v7: If gatherSpanners is True or GatherSpanners.ALL (default),\nthen just the spanners pertaining to the requested measure region\nare provided, rather than the entire bundle from the source.",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "melodicIntervals",
        "type": "Title"
    },
    {
        "text": "**",
        "type": "UncategorizedText"
    },
    {
        "text": "skipKeywords",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Returns a Stream of Interval objects\nbetween Notes (and by default, Chords) that follow each other in a stream.\nthe offset of the Interval is the offset of the beginning of the interval\n(if two notes are adjacent, then this offset is equal to the offset of\nthe second note, but if skipRests is set to True or there is a gap\nin the Stream, then these two numbers\nwill be different).\nSee findConsecutiveNotes() in this class for\na discussion of what is meant by default for \u009cconsecutive notes\u009d, and\nwhich keywords such as skipChords, skipRests, skipUnisons, etc. can be\nused to change that behavior.\nThe interval between a Note and a Chord (or between two chords) is the\ninterval to the first pitch of the Chord (pitches[0]) which is usually the lowest.\nFor more complex interval calculations,\nrun findConsecutiveNotes() and then calculate\nyour own intervals directly.\nReturns an empty Stream if there are not at least two elements found by\nfindConsecutiveNotes.\n>>> s1 = converter.parse(\"tinynotation: 3/4 c4 d' r b b'\", makeNotation=False)\n>>> s1.show()\n\n\n\n>>> intervalStream1 = s1.melodicIntervals()\n>>> intervalStream1.show('text')\n{1.0} <music21.interval.Interval M9>\n{4.0} <music21.interval.Interval P8>\n\n\n>>> M9 = intervalStream1[0]\n>>> M9.noteStart.nameWithOctave, M9.noteEnd.nameWithOctave\n('C4', 'D5')\n\n\nUsing the skip attributes from findConsecutiveNotes(),\nwe can alter which intervals are reported:\n>>> intervalStream2 = s1.melodicIntervals(skipRests=True, skipOctaves=True)\n>>> intervalStream2.show('text')\n{1.0} <music21.interval.Interval M9>\n{2.0} <music21.interval.Interval m-3>\n\n\n>>> m3 = intervalStream2[1]\n>>> m3.directedNiceName\n'Descending Minor Third'",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "mergeAttributes",
        "type": "Title"
    },
    {
        "text": "other",
        "type": "Title"
    },
    {
        "text": "Music21Object",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Merge relevant attributes from the Other stream into this one.\n>>> s = stream.Stream()\n>>> s.append(note.Note())\n>>> s.autoSort = False\n>>> s.id = 'hi'\n>>> s2 = stream.Stream()\n>>> s2.mergeAttributes(s)\n>>> s2.autoSort\nFalse\n>>> s2\n<music21.stream.Stream hi>\n>>> len(s2)\n0",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "mergeElements",
        "type": "Title"
    },
    {
        "text": "other",
        "type": "Title"
    },
    {
        "text": "classFilterList",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Given another Stream, store references of each element\nin the other Stream in this Stream. This does not make\ncopies of any elements, but simply stores all of them in this Stream.\nOptionally, provide a list of classes to include with the classFilter list.\nThis method provides functionality like a shallow copy,\nbut manages locations properly, only copies elements,\nand permits filtering by class type.\n>>> s1 = stream.Stream()\n>>> s2 = stream.Stream()\n>>> n1 = note.Note('f#')\n>>> n2 = note.Note('g')\n>>> s1.append(n1)\n>>> s1.append(n2)\n>>> s2.mergeElements(s1)\n>>> len(s2)\n2\n>>> s1[0] is s2[0]\nTrue\n>>> s1[1] is s2[1]\nTrue\n\n\n>>> viola = instrument.Viola()\n>>> trumpet = instrument.Trumpet()\n>>> s1.insert(0, viola)\n>>> s1.insert(0, trumpet)\n>>> s2.mergeElements(s1, classFilterList=('BrassInstrument',))\n>>> len(s2)\n3\n>>> viola in s2\nFalse",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "metronomeMarkBoundaries",
        "type": "Title"
    },
    {
        "text": "srcObj",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Return a list of offset start, offset end,\nMetronomeMark triples for all TempoIndication objects found\nin this Stream or a Stream provided by srcObj.\nIf no MetronomeMarks are found, or an initial region does not\nhave a MetronomeMark, a mark of quarter equal to 120 is provided as default.\nNote that if other TempoIndication objects are defined,\nthey will be converted to MetronomeMarks and returned here\n>>> s = stream.Stream()\n>>> s.repeatAppend(note.Note(), 8)\n>>> s.insert([6, tempo.MetronomeMark(number=240)])\n>>> s.metronomeMarkBoundaries()\n[(0.0, 6.0, <music21.tempo.MetronomeMark animato Quarter=120>),\n (6.0, 8.0, <music21.tempo.MetronomeMark Quarter=240>)]",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "offsetMap",
        "type": "Title"
    },
    {
        "text": "srcObj",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Returns a list where each element is a NamedTuple\nconsisting of the \u0098offset' of each element in a stream, the\n\u0098endTime' (that is, the offset plus the duration) and the\n\u0098element' itself.  Also contains a \u0098voiceIndex' entry which\ncontains the voice number of the element, or None if there\nare no voices.\n>>> n1 = note.Note(type='quarter')\n>>> c1 = clef.AltoClef()\n>>> n2 = note.Note(type='half')\n>>> s1 = stream.Stream()\n>>> s1.append([n1, c1, n2])\n>>> om = s1.offsetMap()\n>>> om[2].offset\n1.0\n>>> om[2].endTime\n3.0\n>>> om[2].element is n2\nTrue\n>>> om[2].voiceIndex\n\n\nNeeded for makeMeasures and a few other places.\nThe Stream source of elements is self by default,\nunless a srcObj is provided.  (this will be removed in v.8)\n>>> s = stream.Stream()\n>>> s.repeatAppend(note.Note(), 8)\n>>> for om in s.offsetMap():\n...     om\nOffsetMap(element=<music21.note.Note C>, offset=0.0, endTime=1.0, voiceIndex=None)\nOffsetMap(element=<music21.note.Note C>, offset=1.0, endTime=2.0, voiceIndex=None)\nOffsetMap(element=<music21.note.Note C>, offset=2.0, endTime=3.0, voiceIndex=None)\nOffsetMap(element=<music21.note.Note C>, offset=3.0, endTime=4.0, voiceIndex=None)\nOffsetMap(element=<music21.note.Note C>, offset=4.0, endTime=5.0, voiceIndex=None)\nOffsetMap(element=<music21.note.Note C>, offset=5.0, endTime=6.0, voiceIndex=None)\nOffsetMap(element=<music21.note.Note C>, offset=6.0, endTime=7.0, voiceIndex=None)\nOffsetMap(element=<music21.note.Note C>, offset=7.0, endTime=8.0, voiceIndex=None)",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "playingWhenAttacked",
        "type": "Title"
    },
    {
        "text": "el",
        "type": "Title"
    },
    {
        "text": "elStream",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Given an element (from another Stream) returns the single element\nin this Stream that is sounding while the given element starts.\nIf there are multiple elements sounding at the moment it is\nattacked, the method returns the first element of the same class\nas this element, if any. If no element\nis of the same class, then the first element encountered is\nreturned. For more complex usages, use allPlayingWhileSounding.\nReturns None if no elements fit the bill.\nThe optional elStream is the stream in which el is found.\nIf provided, el's offset\nin that Stream is used.  Otherwise, the current offset in\nel is used.  It is just\nin case you are paranoid that el.offset might not be what\nyou want, because of some fancy manipulation of\nel.activeSite\n>>> n1 = note.Note('G#')\n>>> n2 = note.Note('D#')\n>>> s1 = stream.Stream()\n>>> s1.insert(20.0, n1)\n>>> s1.insert(21.0, n2)\n\n\n>>> n3 = note.Note('C#')\n>>> s2 = stream.Stream()\n>>> s2.insert(20.0, n3)\n>>> s1.playingWhenAttacked(n3)\n<music21.note.Note G#>\n\n\n>>> n3.setOffsetBySite(s2, 20.5)\n>>> s1.playingWhenAttacked(n3)\n<music21.note.Note G#>\n\n\n>>> n3.setOffsetBySite(s2, 21.0)\n>>> n3.offset\n21.0\n>>> s1.playingWhenAttacked(n3)\n<music21.note.Note D#>\n\n\nIf there is more than one item at the same time in the other stream\nthen the first item matching the same class is returned, even if\nanother element has a closer offset.\n>>> n3.setOffsetBySite(s2, 20.5)\n>>> s1.insert(20.5, clef.BassClef())\n>>> s1.playingWhenAttacked(n3)\n<music21.note.Note G#>\n>>> fc = clef.FClef()  # superclass of BassClef\n>>> s2.insert(20.5, fc)\n>>> s1.playingWhenAttacked(fc)\n<music21.clef.BassClef>\n\n\nBut since clefs have zero duration, moving the FClef ever so slightly\nwill find the note instead\n>>> fc.setOffsetBySite(s2, 20.6)\n>>> s1.playingWhenAttacked(fc)\n<music21.note.Note G#>\n\n\nOptionally, specify the site to get the offset from:\n>>> n3.setOffsetBySite(s2, 21.0)\n>>> n3.setOffsetBySite(None, 100)\n>>> n3.activeSite = None\n>>> s1.playingWhenAttacked(n3) is None\nTrue\n>>> s1.playingWhenAttacked(n3, s2).name\n'D#'",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "plot",
        "type": "Title"
    },
    {
        "text": "plotFormat",
        "type": "Title"
    },
    {
        "text": "str | None",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "xValue",
        "type": "Title"
    },
    {
        "text": "str | None",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "yValue",
        "type": "Title"
    },
    {
        "text": "str | None",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "zValue",
        "type": "Title"
    },
    {
        "text": "str | None",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "returnInNotebook",
        "type": "Title"
    },
    {
        "text": "bool",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "**",
        "type": "UncategorizedText"
    },
    {
        "text": "keywords",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Given a method and keyword configuration arguments, create and display a plot.\nNote: plot() requires the Python package matplotlib to be installed.\nFor details on arguments this function takes, see\nUser's Guide, Chapter 22: Graphing.\n>>> s = corpus.parse('bach/bwv57.8')\n>>> thePlot = s.plot('pianoroll')\n\n\n\nBy default, a plot is returned in normal Python environments, but not\nin Jupyter notebook/JupyterLab/Google Colab.  The\nkeyword returnInNotebook if True returns a plot no matter what.\n\nChanged in v9: Changed default for return in notebook, and addedreturnInNotebook keyword based on changes to recent Jupyter and\nsimilar releases.",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "pop",
        "type": "Title"
    },
    {
        "text": "index",
        "type": "Title"
    },
    {
        "text": "int | None",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u2192 Music21Object",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Return and remove the object found at the\nuser-specified index value. Index values are\nthose found in elements and are not necessary offset order.\n>>> a = stream.Stream()\n>>> for i in range(12):  # notes C, C#, etc. to B\n...     a.append(note.Note(i))\n>>> a.pop(0)\n<music21.note.Note C>\n>>> len(a)\n11\n\n\nIf nothing is given, then it pops the last thing from the stream.\n>>> a.pop()\n<music21.note.Note B>\n>>> len(a)\n10",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "quantize",
        "type": "NarrativeText"
    },
    {
        "text": "quarterLengthDivisors",
        "type": "Title"
    },
    {
        "text": "Iterable[int]",
        "type": "Title"
    },
    {
        "text": "()",
        "type": "UncategorizedText"
    },
    {
        "text": "processOffsets",
        "type": "Title"
    },
    {
        "text": "bool",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "processDurations",
        "type": "Title"
    },
    {
        "text": "bool",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "inPlace",
        "type": "Title"
    },
    {
        "text": "bool",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "recurse",
        "type": "Title"
    },
    {
        "text": "bool",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Quantize time values in this Stream by snapping offsets\nand/or durations to the nearest multiple of a quarter length value\ngiven as one or more divisors of 1 quarter length. The quantized\nvalue found closest to a divisor multiple will be used.\nThe quarterLengthDivisors provides a flexible way to provide quantization\nsettings. For example, (2,) will snap all events to eighth note grid.\n(4, 3) will snap events to sixteenth notes and eighth note triplets,\nwhichever is closer. (4, 6) will snap events to sixteenth notes and\nsixteenth note triplets.  If quarterLengthDivisors is not specified then\ndefaults.quantizationQuarterLengthDivisors is used.  The default is (4, 3).\nprocessOffsets determines whether the Offsets are quantized.\nprocessDurations determines whether the Durations are quantized.\nBoth are set to True by default.  Setting both to False does nothing to the Stream.\nif inPlace is True, then the quantization is done on the Stream itself.  If False\n(default) then a new quantized Stream of the same class is returned.\nIf recurse is True, then all substreams are also quantized.\nIf False (default), then only the highest level of the Stream is quantized.\n\n\nChanged in v7:\nrecurse defaults False\nlook-ahead approach to choosing divisors to avoid gaps when processing durations\n\n\n\n\n\n>>> n = note.Note()\n>>> n.quarterLength = 0.49\n>>> s = stream.Stream()\n>>> s.repeatInsert(n, [0.1, 0.49, 0.9])\n>>> nShort = note.Note()\n>>> nShort.quarterLength = 0.26\n>>> s.repeatInsert(nShort, [1.49, 1.76])\n\n\n>>> s.quantize((4,), processOffsets=True, processDurations=True, inPlace=True)\n>>> [e.offset for e in s]\n[0.0, 0.5, 1.0, 1.5, 1.75]\n>>> [e.duration.quarterLength for e in s]\n[0.5, 0.5, 0.5, 0.25, 0.25]\n\n\nThe error in quantization is set in the editorial attribute for the note in\ntwo places .offsetQuantizationError and .quarterLengthQuantizationError\n>>> [e.editorial.offsetQuantizationError for e in s.notes]\n[0.1, -0.01, -0.1, -0.01, 0.01]\n>>> [e.editorial.quarterLengthQuantizationError for e in s.notes]\n[-0.01, -0.01, -0.01, 0.01, 0.01]\n\n\nwith default quarterLengthDivisors\u2026\n>>> s = stream.Stream()\n>>> s.repeatInsert(n, [0.1, 0.49, 0.9])\n>>> nShort = note.Note()\n>>> nShort.quarterLength = 0.26\n>>> s.repeatInsert(nShort, [1.49, 1.76])\n>>> quantized = s.quantize(processOffsets=True, processDurations=True, inPlace=False)\n>>> [e.offset for e in quantized]\n[0.0, 0.5, 1.0, 1.5, 1.75]\n>>> [e.duration.quarterLength for e in quantized]\n[0.5, 0.5, 0.5, 0.25, 0.25]\n\n\nSet recurse=True to quantize elements in substreams such as parts, measures, voices:\n>>> myPart = converter.parse('tinynotation: c32 d32 e32 f32')\n>>> myPart.quantize(inPlace=True)\n>>> [e.offset for e in myPart.measure(1).notes]  # no change!\n[0.0, 0.125, 0.25, 0.375]\n\n\n>>> myPart.quantize(inPlace=True, recurse=True)\n>>> [e.offset for e in myPart.measure(1).notes]\n[0.0, 0.0, 0.25, Fraction(1, 3)]\n\n\n\nNew in v7: if both processDurations and processOffsets are True, then\nthe next note's quantized offset is taken into account when quantizing the\nduration of the current note. This is to prevent unnecessary gaps from applying\ndifferent quantization units to adjacent notes:\n\n>>> s2 = stream.Stream()\n>>> nOddLength = note.Note(quarterLength=0.385)\n>>> s2.repeatInsert(nOddLength, [0, 0.5, 1, 1.5])\n>>> s2.show('t', addEndTimes=True)\n    {0.0 - 0.385} <music21.note.Note C>\n    {0.5 - 0.885} <music21.note.Note C>\n    {1.0 - 1.385} <music21.note.Note C>\n    {1.5 - 1.885} <music21.note.Note C>\n\n\nBefore v.7, this would have yielded four triplet-eighths (separated by 1/6 QL rests):\n>>> s2.quantize(processOffsets=True, processDurations=True, inPlace=True)\n>>> s2.show('text', addEndTimes=True)\n    {0.0 - 0.5} <music21.note.Note C>\n    {0.5 - 1.0} <music21.note.Note C>\n    {1.0 - 1.5} <music21.note.Note C>\n    {1.5 - 1.8333} <music21.note.Note C>",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "recurse",
        "type": "Title"
    },
    {
        "text": "streamsOnly",
        "type": "Title"
    },
    {
        "text": "Literal[False]",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "restoreActiveSites",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "classFilter",
        "type": "Title"
    },
    {
        "text": "()",
        "type": "UncategorizedText"
    },
    {
        "text": "includeSelf",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u2192 RecursiveIterator[M21ObjType]",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "recurse",
        "type": "Title"
    },
    {
        "text": "streamsOnly",
        "type": "Title"
    },
    {
        "text": "Literal[True]",
        "type": "Title"
    },
    {
        "text": "restoreActiveSites",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "classFilter",
        "type": "Title"
    },
    {
        "text": "()",
        "type": "UncategorizedText"
    },
    {
        "text": "includeSelf",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u2192 RecursiveIterator[Stream]",
        "type": "Title"
    },
    {
        "text": ".recurse() is a fundamental method of music21 for getting into\nelements contained in a Score, Part, or Measure, where elements such as\nnotes are contained in sub-Stream elements.\nReturns an iterator that iterates over a list of Music21Objects\ncontained in the Stream, starting with self's elements (unless\nincludeSelf=True in which case, it starts with the element itself),\nand whenever finding a Stream subclass in self,\nthat Stream subclass's elements.\nHere's an example. Let's create a simple score.\n>>> s = stream.Score(id='mainScore')\n>>> p0 = stream.Part(id='part0')\n>>> p1 = stream.Part(id='part1')\n\n\n>>> m01 = stream.Measure(number=1)\n>>> m01.append(note.Note('C', type='whole'))\n>>> m02 = stream.Measure(number=2)\n>>> m02.append(note.Note('D', type='whole'))\n>>> m11 = stream.Measure(number=1)\n>>> m11.append(note.Note('E', type='whole'))\n>>> m12 = stream.Measure(number=2)\n>>> m12.append(note.Note('F', type='whole'))\n\n\n>>> p0.append([m01, m02])\n>>> p1.append([m11, m12])\n\n\n>>> s.insert(0, p0)\n>>> s.insert(0, p1)\n>>> s.show('text')\n{0.0} <music21.stream.Part part0>\n    {0.0} <music21.stream.Measure 1 offset=0.0>\n        {0.0} <music21.note.Note C>\n    {4.0} <music21.stream.Measure 2 offset=4.0>\n        {0.0} <music21.note.Note D>\n{0.0} <music21.stream.Part part1>\n    {0.0} <music21.stream.Measure 1 offset=0.0>\n        {0.0} <music21.note.Note E>\n    {4.0} <music21.stream.Measure 2 offset=4.0>\n        {0.0} <music21.note.Note F>\n\n\nNow we could assign the .recurse() method to something,\nbut that won't have much effect:\n>>> sRecurse = s.recurse()\n>>> sRecurse\n<music21.stream.iterator.RecursiveIterator for Score:mainScore @:0>\n\n\nSo, that's not how we use .recurse().  Instead, use it in a for loop:\n>>> for el in s.recurse():\n...     tup = (el, el.offset, el.activeSite)\n...     print(tup)\n(<music21.stream.Part part0>, 0.0, <music21.stream.Score mainScore>)\n(<music21.stream.Measure 1 offset=0.0>, 0.0, <music21.stream.Part part0>)\n(<music21.note.Note C>, 0.0, <music21.stream.Measure 1 offset=0.0>)\n(<music21.stream.Measure 2 offset=4.0>, 4.0, <music21.stream.Part part0>)\n(<music21.note.Note D>, 0.0, <music21.stream.Measure 2 offset=4.0>)\n(<music21.stream.Part part1>, 0.0, <music21.stream.Score mainScore>)\n(<music21.stream.Measure 1 offset=0.0>, 0.0, <music21.stream.Part part1>)\n(<music21.note.Note E>, 0.0, <music21.stream.Measure 1 offset=0.0>)\n(<music21.stream.Measure 2 offset=4.0>, 4.0, <music21.stream.Part part1>)\n(<music21.note.Note F>, 0.0, <music21.stream.Measure 2 offset=4.0>)\n\n\nIf we specify includeSelf=True then the original stream is also iterated:\n>>> for el in s.recurse(includeSelf=True):\n...     tup = (el, el.offset, el.activeSite)\n...     print(tup)\n(<music21.stream.Score mainScore>, 0.0, None)\n(<music21.stream.Part part0>, 0.0, <music21.stream.Score mainScore>)\n(<music21.stream.Measure 1 offset=0.0>, 0.0, <music21.stream.Part part0>)\n(<music21.note.Note C>, 0.0, <music21.stream.Measure 1 offset=0.0>)\n...\n\n\nNotice that like calling .show(\u0098text'), the offsets are relative to their containers.\nCompare the difference between putting .recurse().notes and .flatten().notes:\n>>> for el in s.recurse().notes:\n...     tup = (el, el.offset, el.activeSite)\n...     print(tup)\n(<music21.note.Note C>, 0.0, <music21.stream.Measure 1 offset=0.0>)\n(<music21.note.Note D>, 0.0, <music21.stream.Measure 2 offset=4.0>)\n(<music21.note.Note E>, 0.0, <music21.stream.Measure 1 offset=0.0>)\n(<music21.note.Note F>, 0.0, <music21.stream.Measure 2 offset=4.0>)\n\n\n>>> for el in s.flatten().notes:\n...     tup = (el, el.offset, el.activeSite)\n...     print(tup)\n(<music21.note.Note C>, 0.0, <music21.stream.Score mainScore_flat>)\n(<music21.note.Note E>, 0.0, <music21.stream.Score mainScore_flat>)\n(<music21.note.Note D>, 4.0, <music21.stream.Score mainScore_flat>)\n(<music21.note.Note F>, 4.0, <music21.stream.Score mainScore_flat>)\n\n\nIf you don't need correct offsets or activeSites, set restoreActiveSites to False.\nThen the last offset/activeSite will be used.  It's a bit of a speedup, but leads to some\nbad code, so use it only in highly optimized situations.\nWe'll also test using multiple classes here\u2026 the Stream given is the same as the\ns.flatten().notes stream.\n>>> for el in s.recurse(classFilter=('Note', 'Rest'), restoreActiveSites=False):\n...     tup = (el, el.offset, el.activeSite)\n...     print(tup)\n(<music21.note.Note C>, 0.0, <music21.stream.Score mainScore_flat>)\n(<music21.note.Note D>, 4.0, <music21.stream.Score mainScore_flat>)\n(<music21.note.Note E>, 0.0, <music21.stream.Score mainScore_flat>)\n(<music21.note.Note F>, 4.0, <music21.stream.Score mainScore_flat>)\n\n\nSo, this is pretty unreliable so don't use it unless the tiny speedup is worth it.\nThe other two attributes are pretty self-explanatory: streamsOnly will put only Streams\nin, while includeSelf will add the initial stream from recursion.  If the inclusion or\nexclusion of self is important to you, put it in explicitly.\n>>> for el in s.recurse(includeSelf=False, streamsOnly=True):\n...     tup = (el, el.offset, el.activeSite)\n...     print(tup)\n(<music21.stream.Part part0>, 0.0, <music21.stream.Score mainScore>)\n(<music21.stream.Measure 1 offset=0.0>, 0.0, <music21.stream.Part part0>)\n(<music21.stream.Measure 2 offset=4.0>, 4.0, <music21.stream.Part part0>)\n(<music21.stream.Part part1>, 0.0, <music21.stream.Score mainScore>)\n(<music21.stream.Measure 1 offset=0.0>, 0.0, <music21.stream.Part part1>)\n(<music21.stream.Measure 2 offset=4.0>, 4.0, <music21.stream.Part part1>)\n\n\n\nWarning\nRemember that like all iterators, it is dangerous to alter\nthe components of the Stream being iterated over during iteration.\nif you need to edit while recursing, list(s.recurse()) is safer.\n\n\nChanged in v5.5: All attributes are keyword only.\nChanged in v8: removed parameter skipSelf.  Use includeSelf instead.",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "recurseRepr",
        "type": "Title"
    },
    {
        "text": "prefixSpaces",
        "type": "Title"
    },
    {
        "text": "addBreaks",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "addIndent",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "addEndTimes",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "useMixedNumerals",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "\u2192 str",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Used by .show(\u0098text') to display a stream's contents with offsets.\n>>> s1 = stream.Stream()\n>>> s2 = stream.Stream()\n>>> s3 = stream.Stream()\n>>> n1 = note.Note()\n>>> s3.append(n1)\n>>> s2.append(s3)\n>>> s1.append(s2)\n>>> post = s1.recurseRepr(addBreaks=False, addIndent=False)\n>>> post\n'{0.0} <music21.stream.Stream ...> / {0.0} <...> / {0.0} <music21.note.Note C>'\n\n\nMade public in v7.  Always calls on self.",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "remove",
        "type": "NarrativeText"
    },
    {
        "text": "targetOrList",
        "type": "Title"
    },
    {
        "text": "Music21Object",
        "type": "Title"
    },
    {
        "text": "Sequence",
        "type": "Title"
    },
    {
        "text": "Music21Object",
        "type": "Title"
    },
    {
        "text": "shiftOffsets",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "recurse",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Remove an object from this Stream. Additionally, this Stream is\nremoved from the object's sites in Sites.\nIf a list of objects is passed, they will all be removed.\nIf shiftOffsets is True, then offsets will be\ncorrected after object removal. It is more efficient to pass\na list of objects than to call remove on\neach object individually if shiftOffsets is True.\n>>> import copy\n>>> s = stream.Stream()\n>>> n1 = note.Note('g')\n>>> n2 = note.Note('g#')\n\n\nCopies of an object are not the same as the object\n>>> n3 = copy.deepcopy(n2)\n>>> s.insert(10, n1)\n>>> s.insert(5, n2)\n>>> s.remove(n1)\n>>> len(s)\n1\n>>> s.insert(20, n3)\n>>> s.remove(n3)\n>>> [e for e in s] == [n2]\nTrue\n\n\nNo error is raised if the target is not found.\n>>> s.remove(n3)\n\n\n>>> s2 = stream.Stream()\n>>> c = clef.TrebleClef()\n>>> n1, n2, n3, n4 = note.Note('a'), note.Note('b'), note.Note('c'), note.Note('d')\n>>> n5, n6, n7, n8 = note.Note('e'), note.Note('f'), note.Note('g'), note.Note('a')\n>>> s2.insert(0.0, c)\n>>> s2.append([n1, n2, n3, n4, n5, n6, n7, n8])\n>>> s2.remove(n1, shiftOffsets=True)\n>>> s2.show('text')\n{0.0} <music21.clef.TrebleClef>\n{0.0} <music21.note.Note B>\n{1.0} <music21.note.Note C>\n{2.0} <music21.note.Note D>\n{3.0} <music21.note.Note E>\n{4.0} <music21.note.Note F>\n{5.0} <music21.note.Note G>\n{6.0} <music21.note.Note A>\n\n\n>>> s2.remove([n3, n6, n4], shiftOffsets=True)\n>>> s2.show('text')\n{0.0} <music21.clef.TrebleClef>\n{0.0} <music21.note.Note B>\n{1.0} <music21.note.Note E>\n{2.0} <music21.note.Note G>\n{3.0} <music21.note.Note A>\n\n\nWith the recurse=True parameter, we can remove elements deeply nested.\nHowever, shiftOffsets\ndoes not work with recurse=True yet.\n>>> p1 = stream.Part()\n>>> m1 = stream.Measure(number=1)\n>>> c = clef.BassClef()\n>>> m1.insert(0, c)\n>>> m1.append(note.Note(type='whole'))\n>>> p1.append(m1)\n>>> m2 = stream.Measure(number=2)\n>>> n2 = note.Note('D', type='half')\n>>> m2.append(n2)\n>>> n3 = note.Note(type='half')\n>>> m2.append(n3)\n>>> p1.append(m2)\n>>> p1.show('text')\n{0.0} <music21.stream.Measure 1 offset=0.0>\n    {0.0} <music21.clef.BassClef>\n    {0.0} <music21.note.Note C>\n{4.0} <music21.stream.Measure 2 offset=4.0>\n    {0.0} <music21.note.Note D>\n    {2.0} <music21.note.Note C>\n\n\nWithout recurse=True:\n>>> p1.remove(n2)\n>>> p1.show('text')\n{0.0} <music21.stream.Measure 1 offset=0.0>\n    {0.0} <music21.clef.BassClef>\n    {0.0} <music21.note.Note C>\n{4.0} <music21.stream.Measure 2 offset=4.0>\n    {0.0} <music21.note.Note D>\n    {2.0} <music21.note.Note C>\n\n\nWith recurse=True:\n>>> p1.remove(n2, recurse=True)\n>>> p1.show('text')\n{0.0} <music21.stream.Measure 1 offset=0.0>\n    {0.0} <music21.clef.BassClef>\n    {0.0} <music21.note.Note C>\n{4.0} <music21.stream.Measure 2 offset=4.0>\n    {2.0} <music21.note.Note C>\n\n\nWith recurse=True and a list to remove:\n>>> p1.remove([c, n3], recurse=True)\n>>> p1.show('text')\n{0.0} <music21.stream.Measure 1 offset=0.0>\n    {0.0} <music21.note.Note C>\n{4.0} <music21.stream.Measure 2 offset=4.0>\n\n\nCan also remove elements stored at end:\n>>> streamWithBarline = stream.Stream(note.Note())\n>>> barline = bar.Barline('final')\n>>> streamWithBarline.storeAtEnd(barline)\n>>> barline in streamWithBarline\nTrue\n>>> streamWithBarline.remove(barline)\n>>> barline in streamWithBarline\nFalse\n\n\n\nChanged in v5.3: firstMatchOnly removed \u2014 impossible to have element\nin stream twice.  recurse and shiftOffsets changed to keywordOnly arguments",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "removeByClass",
        "type": "Title"
    },
    {
        "text": "classFilterList",
        "type": "Title"
    },
    {
        "text": "\u2192 None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Remove all elements from the Stream\nbased on one or more classes given\nin a list.\n>>> s = stream.Stream()\n>>> s.append(meter.TimeSignature('4/4'))\n>>> s.repeatAppend(note.Note('C'), 8)\n>>> len(s)\n9\n>>> s.removeByClass('GeneralNote')\n>>> len(s)\n1\n>>> len(s.notes)\n0\n\n\nTest that removing from end elements works.\n>>> s = stream.Measure()\n>>> s.append(meter.TimeSignature('4/4'))\n>>> s.repeatAppend(note.Note('C'), 4)\n>>> s.rightBarline = bar.Barline('final')\n>>> len(s)\n6\n>>> s.removeByClass('Barline')\n>>> len(s)\n5",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "removeByNotOfClass",
        "type": "Title"
    },
    {
        "text": "classFilterList",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Remove all elements not of the specified\nclass or subclass in the Stream in place.\n>>> s = stream.Stream()\n>>> s.append(meter.TimeSignature('4/4'))\n>>> s.repeatAppend(note.Note('C'), 8)\n>>> len(s)\n9\n>>> s.removeByNotOfClass(meter.TimeSignature)\n>>> len(s)\n1\n>>> len(s.notes)\n0",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "repeatAppend",
        "type": "Title"
    },
    {
        "text": "item",
        "type": "Title"
    },
    {
        "text": "numberOfTimes",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Given an object and a number, run append that many times on\na deepcopy of the object.\nnumberOfTimes should of course be a positive integer.\n>>> a = stream.Stream()\n>>> n = note.Note('D--')\n>>> n.duration.type = 'whole'\n>>> a.repeatAppend(n, 10)\n>>> a.show('text')\n{0.0} <music21.note.Note D-->\n{4.0} <music21.note.Note D-->\n{8.0} <music21.note.Note D-->\n{12.0} <music21.note.Note D-->\n...\n{36.0} <music21.note.Note D-->\n\n\n>>> a.duration.quarterLength\n40.0\n>>> a[9].offset\n36.0",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "repeatInsert",
        "type": "Title"
    },
    {
        "text": "item",
        "type": "Title"
    },
    {
        "text": "offsets",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Given an object, create a deep copy of each object at\neach position specified by the offset list:\n>>> a = stream.Stream()\n>>> n = note.Note('G-')\n>>> n.quarterLength = 1\n\n\n>>> a.repeatInsert(n, [0, 2, 3, 4, 4.5, 5, 6, 7, 8, 9, 10, 11, 12])\n>>> len(a)\n13\n>>> a[10].offset\n10.0",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "replace",
        "type": "NarrativeText"
    },
    {
        "text": "target",
        "type": "Title"
    },
    {
        "text": "Music21Object",
        "type": "Title"
    },
    {
        "text": "replacement",
        "type": "Title"
    },
    {
        "text": "Music21Object",
        "type": "Title"
    },
    {
        "text": "recurse",
        "type": "Title"
    },
    {
        "text": "bool",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "allDerived",
        "type": "NarrativeText"
    },
    {
        "text": "bool",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "\u2192 None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Given a target object, replace it with\nthe supplied replacement object.\nDoes nothing if target cannot be found. Raises StreamException if replacement\nis already in the stream.\nIf allDerived is True (as it is by default), all sites (stream) that\nthis stream derives from and also\nhave a reference for the replacement will be similarly changed.\nThis is useful for altering both a flat and nested representation.\n>>> cSharp = note.Note('C#4')\n>>> s = stream.Stream()\n>>> s.insert(0, cSharp)\n>>> dFlat = note.Note('D-4')\n>>> s.replace(cSharp, dFlat)\n>>> s.show('t')\n{0.0} <music21.note.Note D->\n\n\nIf allDerived is True then all streams that this stream comes from get changed\n(but not non-derived streams)\n>>> otherStream = stream.Stream()\n>>> otherStream.insert(0, dFlat)\n>>> f = note.Note('F4')\n>>> sf = s.flatten()\n>>> sf is not s\nTrue\n>>> sf.replace(dFlat, f, allDerived=True)\n>>> sf[0] is f\nTrue\n>>> s[0] is f\nTrue\n>>> otherStream[0] is dFlat\nTrue\n\n\nNote that it does not work the other way: if we made the replacement on s\nthen sf, the flattened representation, would not be changed, since s\ndoes not derive from sf but vice-versa.\nWith recurse=True, a stream can replace an element that is\nfurther down in the hierarchy.  First let's set up a\nnested score:\n>>> s = stream.Score()\n>>> p = stream.Part(id='part1')\n>>> s.append(p)\n>>> m = stream.Measure()\n>>> p.append(m)\n>>> cSharp = note.Note('C#4')\n>>> m.append(cSharp)\n>>> s.show('text')\n{0.0} <music21.stream.Part part1>\n    {0.0} <music21.stream.Measure 0 offset=0.0>\n        {0.0} <music21.note.Note C#>\n\n\nNow make a deep-nested replacement\n>>> dFlat = note.Note('D-4')\n>>> s.replace(cSharp, dFlat, recurse=True)\n>>> s.show('text')\n{0.0} <music21.stream.Part part1>\n    {0.0} <music21.stream.Measure 0 offset=0.0>\n        {0.0} <music21.note.Note D->\n\n\n\nChanged by v5: allTargetSites renamed to allDerived \u2014 only\nsearches in derivation chain.\nChanged in v5.3: firstMatchOnly removed \u2014 impossible to have element\nin stream twice.  recurse and shiftOffsets changed to keywordOnly arguments\nChanged in v6: recurse works\nChanged in v7: raises StreamException if replacement is already in the stream.",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "scaleDurations",
        "type": "Title"
    },
    {
        "text": "amountToScale",
        "type": "Title"
    },
    {
        "text": "inPlace",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Scale all durations by a provided scalar. Offsets are not modified.\nTo augment or diminish a Stream, see the\naugmentOrDiminish() method.\nWe do not retain durations in any circumstance;\nif inPlace=False, two deepcopies of each duration are done.",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "scaleOffsets",
        "type": "Title"
    },
    {
        "text": "amountToScale",
        "type": "Title"
    },
    {
        "text": "anchorZero",
        "type": "Title"
    },
    {
        "text": "'lowest'",
        "type": "Title"
    },
    {
        "text": "anchorZeroRecurse",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "inPlace",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Scale all offsets by a multiplication factor given\nin amountToScale. Durations are not altered.\nTo augment or diminish a Stream,\nsee the augmentOrDiminish() method.\nThe anchorZero parameter determines if and/or where\nthe zero offset is established for the set of\noffsets in this Stream before processing.\nOffsets are shifted to make either the lower\nor upper values the new zero; then offsets are scaled;\nthen the shifts are removed. Accepted values are None\n(no offset shifting), \u009clowest\u009d, or \u009chighest\u009d.\nThe anchorZeroRecurse parameter determines the\nanchorZero for all embedded Streams, and Streams\nembedded within those Streams. If the lowest offset\nin an embedded Stream is non-zero, setting this value\nto None will allow the space between the start of that\nStream and the first element to be scaled. If the\nlowest offset in an embedded Stream is non-zero,\nsetting this value to \u0098lowest' will not alter the\nspace between the start of that Stream and the first\nelement to be scaled.\nTo shift all the elements in a Stream, see the\nshiftElements() method.\n\nChanged in v5: inPlace is default False, and anchorZero, anchorZeroRecurse\nand inPlace are keyword only arguments.",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "setDerivationMethod",
        "type": "Title"
    },
    {
        "text": "derivationMethod",
        "type": "Title"
    },
    {
        "text": "str",
        "type": "Title"
    },
    {
        "text": "recurse",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "\u2192 None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Sets the .derivation.method for each element in the Stream\nif it has a .derivation object.\n>>> import copy\n>>> s = converter.parse('tinyNotation: 2/4 c2 d e f')\n>>> s2 = copy.deepcopy(s)\n>>> s2.recurse().notes[-1].derivation\n<Derivation of <music21.note.Note F> from <music21.note.Note F> via '__deepcopy__'>\n>>> s2.setDerivationMethod('exampleCopy', recurse=True)\n>>> s2.recurse().notes[-1].derivation\n<Derivation of <music21.note.Note F> from <music21.note.Note F> via 'exampleCopy'>\n\n\nWithout recurse:\n>>> s = converter.parse('tinyNotation: 2/4 c2 d e f')\n>>> s2 = copy.deepcopy(s)\n>>> s2.setDerivationMethod('exampleCopy')\n>>> s2.recurse().notes[-1].derivation\n<Derivation of <music21.note.Note F> from <music21.note.Note F> via '__deepcopy__'>",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "setElementOffset",
        "type": "Title"
    },
    {
        "text": "element",
        "type": "Title"
    },
    {
        "text": "Music21Object",
        "type": "Title"
    },
    {
        "text": "offset",
        "type": "Title"
    },
    {
        "text": "int",
        "type": "Title"
    },
    {
        "text": "float",
        "type": "Title"
    },
    {
        "text": "Fraction",
        "type": "Title"
    },
    {
        "text": "OffsetSpecial",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Sets the Offset for an element that is already in a given stream.\nSet up a note in two different streams at two different offsets:\n>>> n = note.Note('B-4')\n>>> s = stream.Stream(id='Stream1')\n>>> s.insert(10, n)\n>>> n.offset\n10.0\n>>> n.activeSite.id\n'Stream1'\n\n\n>>> s2 = stream.Stream(id='Stream2')\n>>> s2.insert(30, n)\n>>> n.activeSite.id\n'Stream2'\n\n\nNow change the note's offset in Stream1:\n>>> s.setElementOffset(n, 20.0)\n\n\nThis call has the effect of switching the activeSite of n to s.\n>>> n.activeSite.id\n'Stream1'\n>>> n.offset\n20.0\n>>> n.getOffsetBySite(s)\n20.0\n\n\nIf the element is not in the Stream, raises a StreamException:\n>>> n2 = note.Note('D')\n>>> s.setElementOffset(n2, 30.0)\nTraceback (most recent call last):\nmusic21.exceptions21.StreamException: Cannot set the offset for element\n    <music21.note.Note D>, not in Stream <music21.stream.Stream Stream1>.\n\n\n\nChanged in v5.5: also sets .activeSite for the element\nChanged in v6.7: also runs coreElementsChanged()\nChanged in v7: addElement is removed;\nsee coreSetElementOffset()",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "shiftElements",
        "type": "Title"
    },
    {
        "text": "offset",
        "type": "Title"
    },
    {
        "text": "startOffset",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "endOffset",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "classFilterList",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Add the given offset value to every offset of\nthe objects found in the Stream. Objects that are\nspecifically placed at the end of the Stream via\n.storeAtEnd() (such as right barlines) are\nnot affected.\nIf startOffset is given then elements before\nthat offset will not be shifted.  If endOffset is given\nthen all elements at or after this offset will be not be shifted.\n>>> a = stream.Stream()\n>>> a.repeatInsert(note.Note('C'), list(range(10)))\n>>> a.shiftElements(30)\n>>> a.lowestOffset\n30.0\n>>> a.shiftElements(-10)\n>>> a.lowestOffset\n20.0\n\n\nUse shiftElements to move elements after a change in\nduration:\n>>> st2 = stream.Stream()\n>>> st2.insert(0, note.Note('D4', type='whole'))\n>>> st2.repeatInsert(note.Note('C4'), list(range(4, 8)))\n>>> st2.show('text')\n{0.0} <music21.note.Note D>\n{4.0} <music21.note.Note C>\n{5.0} <music21.note.Note C>\n{6.0} <music21.note.Note C>\n{7.0} <music21.note.Note C>\n\n\nNow make the first note a dotted whole note and shift the rest by two quarters\u2026\n>>> firstNote = st2[0]\n>>> firstNoteOldQL = firstNote.quarterLength\n>>> firstNote.duration.dots = 1\n>>> firstNoteNewQL = firstNote.quarterLength\n>>> shiftAmount = firstNoteNewQL - firstNoteOldQL\n>>> shiftAmount\n2.0\n\n\n>>> st2.shiftElements(shiftAmount, startOffset=4.0)\n>>> st2.show('text')\n{0.0} <music21.note.Note D>\n{6.0} <music21.note.Note C>\n{7.0} <music21.note.Note C>\n{8.0} <music21.note.Note C>\n{9.0} <music21.note.Note C>\n\n\nA class filter list may be given.  It must be an iterable.\n>>> st2.insert(7.5, key.Key('F'))\n>>> st2.shiftElements(2/3, startOffset=6.0, endOffset=8.0,\n...                   classFilterList=[note.Note])\n>>> st2.show('text')\n{0.0} <music21.note.Note D>\n{6.6667} <music21.note.Note C>\n{7.5} <music21.key.Key of F major>\n{7.6667} <music21.note.Note C>\n{8.0} <music21.note.Note C>\n{9.0} <music21.note.Note C>",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "show",
        "type": "Title"
    },
    {
        "text": "fmt",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "app",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "**",
        "type": "UncategorizedText"
    },
    {
        "text": "keywords",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Displays an object in a format provided by the\nfmt argument or, if not provided, the format set in the user's Environment\nValid formats include (but are not limited to):\nmusicxml\ntext\nmidi\nlily (or lilypond)\nlily.png\nlily.pdf\nlily.svg\nbraille\nvexflow\nmusicxml.png\n\n\nN.B. score.write(\u0098lily') returns a bare lilypond file,\nscore.show(\u0098lily') runs it through lilypond and displays it as a png.\nSome formats, including .musicxml, create a copy of the stream, pack it into a well-formed\nscore if necessary, and run makeNotation(). To\navoid this when showing .musicxml, use makeNotation=False, an advanced option\nthat prioritizes speed but may not guarantee satisfactory notation.",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "showVariantAsOssialikePart",
        "type": "Title"
    },
    {
        "text": "containedPart",
        "type": "Title"
    },
    {
        "text": "variantGroups",
        "type": "Title"
    },
    {
        "text": "inPlace",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Takes a part within the score and a list of variant groups within that part.\nPuts the variant object\nin a part surrounded by hidden rests to mimic the appearance of an ossia despite limited\nmusicXML support for ossia staves. Note that this will ignore variants with .lengthType\n\u0098elongation' and \u0098deletion' as there is no good way to represent ossia staves like those\nby this method.\n>>> sPartStr = 'd4 e4 f4 g4   a2 b-4 a4    g4 a8 g8 f4 e4    d2 a2 '\n>>> v1Str =    '              a2. b-8 a8 '\n>>> v2Str =    '                                             d4 f4 a2 '\n\n\n>>> sPartStr += \"d4 e4 f4 g4    a2 b-4 a4    g4 a8 b-8 c'4 c4    f1\"\n\n\n>>> sPartStream = converter.parse('tinynotation: 4/4 ' + sPartStr)\n>>> sPartStream.makeMeasures(inPlace=True)  # maybe not necessary?\n>>> v1stream = converter.parse('tinynotation: 4/4 ' + v1Str)\n>>> v2stream = converter.parse('tinynotation: 4/4 ' + v2Str)\n\n\n>>> v1 = variant.Variant()\n>>> v1measure = stream.Measure()\n>>> v1.insert(0.0, v1measure)\n>>> for e in v1stream.notesAndRests:\n...    v1measure.insert(e.offset, e)\n\n\n>>> v2 = variant.Variant()\n>>> v2measure = stream.Measure()\n>>> v2.insert(0.0, v2measure)\n>>> for e in v2stream.notesAndRests:\n...    v2measure.insert(e.offset, e)\n\n\n>>> v3 = variant.Variant()\n>>> v2.replacementDuration = 4.0\n>>> v3.replacementDuration = 4.0\n>>> v1.groups = ['variant1']\n>>> v2.groups = ['variant2']\n>>> v3.groups = ['variant3']\n\n\n>>> sPart = stream.Part()\n>>> for e in sPartStream:\n...    sPart.insert(e.offset, e)\n\n\n>>> sPart.insert(4.0, v1)\n>>> sPart.insert(12.0, v2)\n>>> sPart.insert(20.0, v3)  # This is a deletion variant and will be skipped\n>>> s = stream.Score()\n>>> s.insert(0.0, sPart)\n>>> streamWithOssia = s.showVariantAsOssialikePart(sPart,\n...          ['variant1', 'variant2', 'variant3'], inPlace=False)\n>>> streamWithOssia.show()",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "simultaneousAttacks",
        "type": "Title"
    },
    {
        "text": "stream2",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "returns an ordered list of offsets where elements are started (attacked)\nat the same time in both self and stream2.\nIn this example, we create one stream of Qtr, Half, Qtr, and one of Half, Qtr, Qtr.\nThere are simultaneous attacks at offset 0.0 (the beginning) and at offset 3.0,\nbut not at 1.0 or 2.0:\n>>> st1 = stream.Stream()\n>>> st2 = stream.Stream()\n>>> st1.append([note.Note(type='quarter'),\n...             note.Note(type='half'),\n...             note.Note(type='quarter')])\n>>> st2.append([note.Note(type='half'),\n...             note.Note(type='quarter'),\n...             note.Note(type='quarter')])\n>>> print(st1.simultaneousAttacks(st2))\n[0.0, 3.0]",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "sliceAtOffsets",
        "type": "Title"
    },
    {
        "text": "offsetList",
        "type": "Title"
    },
    {
        "text": "target",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "addTies",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "inPlace",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "displayTiedAccidentals",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Given a list of quarter lengths, slice and optionally tie all\nMusic21Objects crossing these points.\n>>> s = stream.Stream()\n>>> n = note.Note()\n>>> n.duration.type = 'whole'\n>>> s.append(n)\n>>> post = s.sliceAtOffsets([1, 2, 3], inPlace=True)\n>>> [(e.offset, e.quarterLength) for e in s]\n[(0.0, 1.0), (1.0, 1.0), (2.0, 1.0), (3.0, 1.0)]",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "sliceByBeat",
        "type": "Title"
    },
    {
        "text": "target",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "addTies",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "inPlace",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "displayTiedAccidentals",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Slice all elements in the Stream that have a Duration at\nthe offsets determined to be the beat from the local TimeSignature.\n\nChanged in v7: return None if inPlace is True",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "sliceByGreatestDivisor",
        "type": "Title"
    },
    {
        "text": "addTies",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "inPlace",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Slice all Duration objects on all Notes and Rests of this Stream.\nDuration are sliced according to the approximate GCD found in all durations.",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "sliceByQuarterLengths",
        "type": "Title"
    },
    {
        "text": "quarterLengthList",
        "type": "Title"
    },
    {
        "text": "target",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "addTies",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "inPlace",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Slice all Duration objects on all Notes and Rests\nof this Stream.\nDuration are sliced according to values provided in quarterLengthList list.\nIf the sum of these values is less than the Duration, the values are accumulated\nin a loop to try to fill the Duration. If a match cannot be found, an\nException is raised.\nIf target is None, the entire Stream is processed. Otherwise, only the element\nspecified is manipulated.",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "sort",
        "type": "Title"
    },
    {
        "text": "force",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Sort this Stream in place by offset, then priority, then\nstandard class sort order (e.g., Clefs before KeySignatures before\nTimeSignatures).\nNote that Streams automatically sort themselves unless\nautoSort is set to False (as in the example below)\nIf force is True, a sort will be attempted regardless of any other parameters.\n>>> n1 = note.Note('A')\n>>> n2 = note.Note('B')\n>>> s = stream.Stream()\n>>> s.autoSort = False\n>>> s.insert(100, n2)\n>>> s.insert(0, n1)  # now a has a lower offset by higher index\n>>> [n.name for n in s]\n['B', 'A']\n>>> s[0].name\n'B'\n>>> s.sort()\n>>> s[0].name\n'A'\n>>> [n.name for n in s]\n['A', 'B']",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "sorted",
        "type": "NarrativeText"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "(TL;DR: you probably do not need to call this method unless you have turned .autoSort to\noff.)\nReturns a new Stream where all the elements are sorted according to offset time, then\npriority, then classSortOrder (so that, for instance, a Clef at offset 0 appears before\na Note at offset 0).\nIf this Stream is not flat, then only the elements directly in the stream itself are sorted.\nTo sort all, run myStream.flatten().sorted().\nFor instance, here is an unsorted Stream:\n>>> s = stream.Stream()\n>>> s.autoSort = False  # if True, sorting is automatic\n>>> s.insert(1, note.Note('D'))\n>>> s.insert(0, note.Note('C'))\n>>> s.show('text')\n{1.0} <music21.note.Note D>\n{0.0} <music21.note.Note C>\n\n\nBut a sorted version of the Stream puts the C first:\n>>> s.sorted().show('text')\n{0.0} <music21.note.Note C>\n{1.0} <music21.note.Note D>\n\n\nWhile the original stream remains unsorted:\n>>> s.show('text')\n{1.0} <music21.note.Note D>\n{0.0} <music21.note.Note C>",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "splitAtDurations",
        "type": "Title"
    },
    {
        "text": "recurse",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "\u2192 _SplitTuple",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Overrides base method splitAtDurations()\nso that once each element in the stream having a complex duration is split\ninto similar, shorter elements representing each duration component,\nthe original element is actually replaced in the stream where it was found\nwith those new elements.\nReturns a 1-tuple containing itself, for consistency with the superclass method.\n>>> s = stream.Stream()\n>>> s.insert(note.Note(quarterLength=5.0))\n>>> post = s.splitAtDurations()\n>>> post\n(<music21.stream.Stream 0x10955ceb0>,)\n>>> [n.duration for n in s]\n[<music21.duration.Duration 4.0>, <music21.duration.Duration 1.0>]\n\n\nUnless recurse=True, notes in substreams will not be found.\n>>> s2 = stream.Score()\n>>> p = stream.Part([note.Note(quarterLength=5)])\n>>> s2.append(p)\n>>> s2.splitAtDurations()\n(<music21.stream.Score 0x10d12f100>,)\n>>> [n.duration for n in s2.recurse().notes]\n[<music21.duration.Duration 5.0>]\n>>> s2.splitAtDurations(recurse=True)\n(<music21.stream.Score 0x10d12f100>,)\n>>> [n.duration for n in s2.recurse().notes]\n[<music21.duration.Duration 4.0>, <music21.duration.Duration 1.0>]\n\n\nrecurse=True should not be necessary to find elements in streams\nwithout substreams, such as a loose Voice:\n>>> v = stream.Voice([note.Note(quarterLength=5.5)], id=1)\n>>> v.splitAtDurations()\n(<music21.stream.Voice 1>,)\n>>> [n.duration for n in v.notes]\n[<music21.duration.Duration 4.0>, <music21.duration.Duration 1.5>]\n\n\nBut a Voice in a Measure (most common) will not be found without recurse:\n>>> m = stream.Measure()\n>>> v2 = stream.Voice([note.Note(quarterLength=5.25)])\n>>> m.insert(v2)\n>>> m.splitAtDurations()\n(<music21.stream.Measure 0 offset=0.0>,)\n>>> [n.duration for n in m.recurse().notes]\n[<music21.duration.Duration 5.25>]\n\n\nFor any spanner containing the element being removed, the first or last of the\nreplacing components replaces the removed element\n(according to whether it was first or last in the spanner.)\n>>> s3 = stream.Stream()\n>>> n1 = note.Note(quarterLength=5)\n>>> n2 = note.Note(quarterLength=5)\n>>> s3.append([n1, n2])\n>>> s3.insert(0, spanner.Slur([n1, n2]))\n>>> post = s3.splitAtDurations()\n>>> s3.spanners.first().getFirst() is n1\nFalse\n>>> s3.spanners.first().getFirst().duration\n<music21.duration.Duration 4.0>\n>>> s3.spanners.first().getLast().duration\n<music21.duration.Duration 1.0>\n\n\nDoes not act on rests where .fullMeasure is True or \u0098always',\nnor when .fullMeasure is \u0098auto' and the duration equals the .barDuration.\nThis is because full measure rests are usually represented\nas a single whole rest regardless of their duration.\n>>> r = note.Rest(quarterLength=5.0)\n>>> r.fullMeasure = 'auto'\n>>> v = stream.Voice(r)\n>>> m = stream.Measure(v)\n>>> result = m.splitAtDurations(recurse=True)\n>>> list(result[0][note.Rest])\n[<music21.note.Rest 5ql>]\n\n\nHere is a rest that doesn't fill the measure:\n>>> m.insert(0, meter.TimeSignature('6/4'))\n>>> result = m.splitAtDurations(recurse=True)\n>>> list(result[0][note.Rest])\n[<music21.note.Rest whole>, <music21.note.Rest quarter>]\n\n\nBut by calling it a full-measure rest, we won't try to split it:\n>>> r2 = note.Rest(quarterLength=5.0)\n>>> r2.fullMeasure = True\n>>> m2 = stream.Measure(r2)\n>>> m2.insert(0, meter.TimeSignature('6/4'))\n>>> result = m2.splitAtDurations()\n>>> list(result[0][note.Rest])\n[<music21.note.Rest 5ql>]",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "splitAtQuarterLength",
        "type": "Title"
    },
    {
        "text": "quarterLength",
        "type": "Title"
    },
    {
        "text": "retainOrigin",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "addTies",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "displayTiedAccidentals",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "searchContext",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "This method overrides the method on Music21Object to provide\nsimilar functionality for Streams.\nMost arguments are passed to Music21Object.splitAtQuarterLength.\n\nChanged in v7: all but quarterLength are keyword only",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "splitByClass",
        "type": "Title"
    },
    {
        "text": "classObj",
        "type": "Title"
    },
    {
        "text": "fx",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Given a stream, get all objects of type classObj and divide them into\ntwo new streams depending on the results of fx.\nFx should be a lambda or other function on elements.\nAll elements where fx returns \u009cTrue\u009d go in the first stream.\nAll other elements are put in the second stream.\nIf classObj is None then all elements are returned.  ClassObj\ncan also be a list of classes.\nIn this example, we will create 50 notes from midi note 30 (two\noctaves and a tritone below middle C) to midi note 80 (an octave\nand a minor sixth above middle C) and add them to a Stream.\nWe then create a lambda function to split between those notes\nbelow middle C (midi note 60) and those above\n(google \u009clambda functions in Python\u009d for more information on\nwhat these powerful tools are).\n>>> stream1 = stream.Stream()\n>>> for x in range(30, 81):\n...     n = note.Note()\n...     n.pitch.midi = x\n...     stream1.append(n)\n>>> fx = lambda n: n.pitch.midi < 60\n>>> b, c = stream1.splitByClass(note.Note, fx)\n\n\nStream b now contains all the notes below middle C,\nthat is, 30 notes, beginning with F#1 and ending with B3\nwhile Stream c has the 21 notes from C4 to A-5:\n>>> len(b)\n30\n>>> (b[0].nameWithOctave, b[-1].nameWithOctave)\n('F#1', 'B3')\n>>> len(c)\n21\n>>> (c[0].nameWithOctave, c[-1].nameWithOctave)\n('C4', 'G#5')",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "storeAtEnd",
        "type": "Title"
    },
    {
        "text": "itemOrList",
        "type": "Title"
    },
    {
        "text": "ignoreSort",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Inserts an item or items at the end of the Stream,\nstored in the special box (called _endElements).\nThis method is useful for putting things such as\nright bar lines or courtesy clefs that should always\nbe at the end of a Stream no matter what else is appended\nto it.\nAs sorting is done only by priority and class,\nit cannot avoid setting isSorted to False.\n>>> s = stream.Stream()\n>>> b = bar.Repeat()\n>>> s.storeAtEnd(b)\n>>> b in s\nTrue\n>>> s.elementOffset(b)\n0.0\n>>> s.elementOffset(b, returnSpecial=True)\n<OffsetSpecial.AT_END>\n\n\nOnly elements of zero duration can be stored.  Otherwise, a\nStreamException is raised.",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "stripTies",
        "type": "Title"
    },
    {
        "text": "inPlace",
        "type": "Title"
    },
    {
        "text": "Literal[True]",
        "type": "Title"
    },
    {
        "text": "matchByPitch",
        "type": "Title"
    },
    {
        "text": "bool",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "\u2192 None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "stripTies",
        "type": "Title"
    },
    {
        "text": "inPlace",
        "type": "Title"
    },
    {
        "text": "Literal[False]",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "matchByPitch",
        "type": "Title"
    },
    {
        "text": "bool",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "\u2192 StreamType",
        "type": "Title"
    },
    {
        "text": "Find all notes that are tied; remove all tied notes,\nthen make the first of the tied notes have a duration\nequal to that of all tied constituents. Lastly,\nremove the formerly-tied notes.\nThis method can be used on Stream and Stream subclasses.\nWhen used on a stream containing Part-like substreams, as with many scores,\nPart, Measure, and other\nStream subclasses are retained.\ninPlace controls whether the input stream is modified or whether a deep copy\nis made. (New in v7, to conform to the rest of music21, inPlace=True returns None.)\nPresently, this only works if tied notes are sequential in the same voice; ultimately\nthis will need to look at .to and .from attributes (if they exist)\n>>> a = stream.Stream()\n>>> n = note.Note()\n>>> n.quarterLength = 6\n>>> a.append(n)\n>>> m = a.makeMeasures()\n>>> m.makeTies(inPlace=True)\n>>> len(m.flatten().notes)\n2\n\n\n>>> m = m.stripTies()\n>>> len(m.flatten().notes)\n1\n\n\nIn cases where notes are manipulated after initial tie creation,\nsome chord members might lack ties. This will not prevent merging the tied notes\nif all the pitches match, and matchByPitch=True (default):\n>>> c1 = chord.Chord('C4 E4')\n>>> c1.tie = tie.Tie('start')\n\n\n>>> c2 = chord.Chord('C4 E4')\n>>> c2.tie = tie.Tie('stop')\n\n\n>>> m = stream.Measure()\n>>> m.append([c1, c2])\n\n\n>>> c1.add(note.Note('G4'))\n>>> c2.add(note.Note('G4'))\n\n\n>>> c2.notes[-1].tie is None\nTrue\n\n\n>>> strippedPitchMatching = m.stripTies()\n>>> len(strippedPitchMatching.flatten().notes)\n1\n\n\nThis can be prevented with matchByPitch=False, in which case every note,\nincluding each chord member, must have \u009cstop\u009d and/or \u009ccontinue\u009d tie types,\nwhich was not the case above:\n>>> strippedMixedTieTypes = m.stripTies(matchByPitch=False)\n>>> len(strippedMixedTieTypes.flatten().notes)\n2\n\n\n>>> c2.notes[0].tie = tie.Tie('stop')\n>>> c2.notes[1].tie = tie.Tie('stop')\n>>> c2.notes[2].tie = tie.Tie('stop')\n>>> strippedUniformTieTypes = m.stripTies(matchByPitch=False)\n>>> len(strippedUniformTieTypes.flatten().notes)\n1\n\n\nNotice the matching happens even after altering the pitches:\n>>> c3 = c2.transpose(6)\n>>> otherM = stream.Measure([c1, c3])\n>>> strippedTransposed = otherM.stripTies(matchByPitch=False)\n>>> len(strippedTransposed.flatten().notes)\n1\n\n\nWhen matchByPitch is True (as it is by default) the following\nbehavior defined regarding chords with a tie type \u009ccontinue\u009d:\n>>> c1.notes[0].tie = tie.Tie('continue')\n>>> c1.notes[1].tie = tie.Tie('start')\n>>> c1.notes[2].tie = tie.Tie('start')\n\n\nContinue is accepted here as an ersatz-start:\n>>> stripped1 = m.stripTies(matchByPitch=True)\n>>> len(stripped1.flatten().notes)\n1\n\n\nBut prepend an element so that it's considered as a tie continuation:\n>>> c0 = chord.Chord('C4 E4 G4')\n>>> c0.tie = tie.Tie('start')\n>>> m2 = stream.Measure()\n>>> m2.append([c0, c1, c2])\n\n\nNow the mixed tie types on c1 will only be connected to c2\non the permissive option (matchByPitch=True):\n>>> stripped2 = m2.stripTies(matchByPitch=True)\n>>> stripped2.elements\n(<music21.chord.Chord C4 E4 G4>,)\n\n\n>>> stripped3 = m2.stripTies(matchByPitch=False)\n>>> stripped3.elements\n(<music21.chord.Chord C4 E4 G4>,\n <music21.chord.Chord C4 E4 G4>,\n <music21.chord.Chord C4 E4 G4>)\n\n\nNow correct the tie types on c1 and try the strict option:\n>>> c1.notes[0].tie = tie.Tie('continue')\n>>> c1.notes[1].tie = tie.Tie('continue')\n>>> c1.notes[2].tie = tie.Tie('continue')\n>>> stripped4 = m2.stripTies(matchByPitch=False)\n>>> stripped4.elements\n(<music21.chord.Chord C4 E4 G4>,)\n\n\nNow replace the first element with just a single C4 note.\nThe following chords will be merged with each other, but not with the single\nnote, even on matchByPitch=False.\n(matchByPitch=False is permissive about pitch but strict about cardinality.)\n>>> newC = note.Note('C4')\n>>> newC.tie = tie.Tie('start')\n>>> m2.replace(c0, newC)\n>>> stripped5 = m2.stripTies(matchByPitch=False)\n>>> stripped5.elements\n(<music21.note.Note C>, <music21.chord.Chord C4 E4 G4>)\n\n\n\nChanged in v7: matchByPitch defaults True",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "template",
        "type": "Title"
    },
    {
        "text": "fillWithRests",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "removeClasses",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "retainVoices",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Return a new Stream based on this one, but without the notes and other elements\nbut keeping instruments, clefs, keys, etc.\nClasses to remove are specified in removeClasses.\nIf this Stream contains measures, return a new Stream\nwith new Measures populated with the same characteristics of those found in this Stream.\n>>> b = corpus.parse('bwv66.6')\n>>> sopr = b.parts[0]\n>>> soprEmpty = sopr.template()\n>>> soprEmpty.show('text')\n{0.0} <music21.instrument.Instrument 'P1: Soprano: Instrument 1'>\n{0.0} <music21.stream.Measure 0 offset=0.0>\n    {0.0} <music21.clef.TrebleClef>\n    {0.0} <music21.tempo.MetronomeMark Quarter=96 (playback only)>\n    {0.0} <music21.key.Key of f# minor>\n    {0.0} <music21.meter.TimeSignature 4/4>\n    {0.0} <music21.note.Rest quarter>\n{1.0} <music21.stream.Measure 1 offset=1.0>\n    {0.0} <music21.note.Rest whole>\n{5.0} <music21.stream.Measure 2 offset=5.0>\n    {0.0} <music21.note.Rest whole>\n{9.0} <music21.stream.Measure 3 offset=9.0>\n    {0.0} <music21.layout.SystemLayout>\n    {0.0} <music21.note.Rest whole>\n{13.0} <music21.stream.Measure 4 offset=13.0>\n...\n\n\nReally make empty with fillWithRests=False\n>>> alto = b.parts[1]\n>>> altoEmpty = alto.template(fillWithRests=False)\n>>> altoEmpty.show('text')\n{0.0} <music21.instrument.Instrument 'P2: Alto: Instrument 2'>\n{0.0} <music21.stream.Measure 0 offset=0.0>\n    {0.0} <music21.clef.TrebleClef>\n    {0.0} <music21.tempo.MetronomeMark Quarter=96 (playback only)>\n    {0.0} <music21.key.Key of f# minor>\n    {0.0} <music21.meter.TimeSignature 4/4>\n{1.0} <music21.stream.Measure 1 offset=1.0>\n\n{5.0} <music21.stream.Measure 2 offset=5.0>\n\n{9.0} <music21.stream.Measure 3 offset=9.0>\n    {0.0} <music21.layout.SystemLayout>\n...\n\n\nremoveClasses can be a list or set of classes to remove.  By default it is\n[\u0098GeneralNote', \u0098Dynamic', \u0098Expression']\n>>> tenor = b.parts[2]\n>>> tenorNoClefsSignatures = tenor.template(fillWithRests=False,\n...       removeClasses=['Clef', 'KeySignature', 'TimeSignature', 'Instrument'])\n>>> tenorNoClefsSignatures.show('text')\n{0.0} <music21.stream.Measure 0 offset=0.0>\n    {0.0} <music21.tempo.MetronomeMark Quarter=96 (playback only)>\n    {0.0} <music21.note.Note A>\n    {0.5} <music21.note.Note B>\n{1.0} <music21.stream.Measure 1 offset=1.0>\n    {0.0} <music21.note.Note C#>\n    {1.0} <music21.note.Note B>\n    {2.0} <music21.note.Note A>\n    {3.0} <music21.note.Note B>\n{5.0} <music21.stream.Measure 2 offset=5.0>\n...\n\n\nSetting removeClasses to True removes everything that is not a Stream:\n>>> bass = b.parts[3]\n>>> bassEmpty = bass.template(fillWithRests=False, removeClasses=True)\n>>> bassEmpty.show('text')\n{0.0} <music21.stream.Measure 0 offset=0.0>\n\n{1.0} <music21.stream.Measure 1 offset=1.0>\n\n{5.0} <music21.stream.Measure 2 offset=5.0>\n\n{9.0} <music21.stream.Measure 3 offset=9.0>\n\n{13.0} <music21.stream.Measure 4 offset=13.0>\n\n...\n\n\nOn the whole score:\n>>> b.template().show('text')\n{0.0} <music21.metadata.Metadata object at 0x106151940>\n{0.0} <music21.stream.Part Soprano>\n    {0.0} <music21.instrument.Instrument 'P1: Soprano: Instrument 1'>\n    {0.0} <music21.stream.Measure 0 offset=0.0>\n        {0.0} <music21.clef.TrebleClef>\n        {0.0} <music21.tempo.MetronomeMark Quarter=96 (playback only)>\n        {0.0} <music21.key.Key of f# minor>\n        {0.0} <music21.meter.TimeSignature 4/4>\n        {0.0} <music21.note.Rest quarter>\n    {1.0} <music21.stream.Measure 1 offset=1.0>\n        {0.0} <music21.note.Rest whole>\n        ...\n    {33.0} <music21.stream.Measure 9 offset=33.0>\n        {0.0} <music21.note.Rest dotted-half>\n        {3.0} <music21.bar.Barline type=final>\n{0.0} <music21.stream.Part Alto>\n    {0.0} <music21.instrument.Instrument 'P2: Alto: Instrument 2'>\n    {0.0} <music21.stream.Measure 0 offset=0.0>\n        {0.0} <music21.clef.TrebleClef>\n        {0.0} <music21.tempo.MetronomeMark Quarter=96 (playback only)>\n        {0.0} <music21.key.Key of f# minor>\n        {0.0} <music21.meter.TimeSignature 4/4>\n        {0.0} <music21.note.Rest quarter>\n    {1.0} <music21.stream.Measure 1 offset=1.0>\n        {0.0} <music21.note.Rest whole>\n    ...\n    {33.0} <music21.stream.Measure 9 offset=33.0>\n        {0.0} <music21.note.Rest dotted-half>\n        {3.0} <music21.bar.Barline type=final>\n{0.0} <music21.layout.StaffGroup ...>\n\n\nIf retainVoices is False (default True) then Voice streams are treated\ndifferently from all other Streams and are removed.  All elements in the\nvoice are removed even if they do not match the classList:\n>>> p = stream.Part(id='part0')\n>>> m1 = stream.Measure(number=1)\n>>> v1 = stream.Voice(id='voice1')\n>>> v1.insert(0, note.Note('E', quarterLength=4.0))\n>>> v2 = stream.Voice(id='voice2')\n>>> v2.insert(0, note.Note('G', quarterLength=2.0))\n>>> m1.insert(0, v1)\n>>> m1.insert(0, v2)\n>>> m2 = stream.Measure(number=2)\n>>> m2.insert(0, note.Note('D', quarterLength=4.0))\n>>> p.append([m1, m2])\n>>> pt = p.template(retainVoices=False)\n>>> pt.show('text')\n{0.0} <music21.stream.Measure 1 offset=0.0>\n    {0.0} <music21.note.Rest whole>\n{4.0} <music21.stream.Measure 2 offset=4.0>\n    {0.0} <music21.note.Rest whole>\n>>> pt[0][0].quarterLength\n4.0\n\n\nDeveloper note \u2014 if you just want a copy of a Score with new\nPart and Measure objects, but you don't care that the notes, etc.\ninside are the same objects as the original (i.e., you do not\nplan to manipulate them, or you want the manipulations to\nreturn to the original objects), using .template() is several\ntimes faster than a deepcopy of the stream (about 4x faster\non bwv66.6)\n\nChanged in v7: all arguments are keyword only.",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "toSoundingPitch",
        "type": "Title"
    },
    {
        "text": "preserveAccidentalDisplay",
        "type": "Title"
    },
    {
        "text": "bool",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "inPlace",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "If not at sounding pitch, transpose all Pitch\nelements to sounding pitch. The atSoundingPitch property\nis used to determine if transposition is necessary.\nAffected by the presence of Instruments and by Ottava spanners\n>>> sc = stream.Score()\n>>> p = stream.Part(id='barisax')\n>>> p.append(instrument.BaritoneSaxophone())\n>>> m = stream.Measure(number=1)\n>>> m.append(note.Note('A4'))\n>>> p.append(m)\n>>> sc.append(p)\n>>> sc.atSoundingPitch = False\n\n\n>>> scSounding = sc.toSoundingPitch()\n>>> scSounding.show('text')\n{0.0} <music21.stream.Part barisax>\n    {0.0} <music21.instrument.BaritoneSaxophone 'Baritone Saxophone'>\n    {0.0} <music21.stream.Measure 1 offset=0.0>\n        {0.0} <music21.note.Note C>\n\n\n>>> scSounding.atSoundingPitch\nTrue\n>>> scSounding.parts[0].atSoundingPitch\nTrue\n>>> scSounding.recurse().notes[0].nameWithOctave\n'C3'\n\n\nIf \u0098atSoundingPitch' is unknown for this Stream and all of its parent Streams\nthen no transposition will take place, and atSoundingPitch will remain unknown\n(this used to raise an exception):\n>>> s = stream.Score()\n>>> p = stream.Part(id='partEmpty')\n>>> s.insert(0.0, p)\n>>> p.toSoundingPitch()\n<music21.stream.Part partEmpty>\n>>> s.atSoundingPitch = False\n>>> sp = p.toSoundingPitch()\n>>> sp\n<music21.stream.Part partEmpty>\n>>> sp.atSoundingPitch\n'unknown'\n>>> sp.derivation.origin is p\nTrue\n\n\n\nChanged in v2.0.10: inPlace is False\nChanged in v5: returns None if inPlace=True\nChanged in v9: no transposition instead of exception if atSoundingPitch is \u0098unknown'",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "toWrittenPitch",
        "type": "Title"
    },
    {
        "text": "ottavasToSounding",
        "type": "NarrativeText"
    },
    {
        "text": "bool",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "preserveAccidentalDisplay",
        "type": "Title"
    },
    {
        "text": "bool",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "inPlace",
        "type": "Title"
    },
    {
        "text": "bool",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "If not at written pitch, transpose all Pitch elements to\nwritten pitch. The atSoundingPitch property is used to\ndetermine if transposition is necessary.  Note that if\nottavasToSounding is True, any notes/chords within\nan Ottava will _then_ be transposed to sounding Pitch (this\nis useful for the MusicXML writer, since MusicXML likes\nall pitches to be written pitches, except for those in\nottavas, which should be transposed to written (by instrument)\nand then transposed to sounding (by ottava).\n>>> sc = stream.Score()\n>>> p = stream.Part(id='baritoneSax')\n>>> p.append(instrument.BaritoneSaxophone())\n>>> m = stream.Measure(number=1)\n>>> m.append(note.Note('C3'))\n>>> p.append(m)\n>>> sc.append(p)\n>>> sc.atSoundingPitch = True\n>>> scWritten = sc.toWrittenPitch()\n>>> scWritten.show('text')\n{0.0} <music21.stream.Part baritoneSax>\n    {0.0} <music21.instrument.BaritoneSaxophone 'Baritone Saxophone'>\n    {0.0} <music21.stream.Measure 1 offset=0.0>\n        {0.0} <music21.note.Note A>\n>>> scWritten.atSoundingPitch\nFalse\n>>> scWritten.parts[0].atSoundingPitch\nFalse\n>>> scWritten.recurse().notes[0].nameWithOctave\n'A4'\n\n\n\nChanged in v3: inPlace defaults to False\nChanged in v5 returns None if inPlace=True\nChanged in v9: no transposition instead of exception if atSoundingPitch is \u0098unknown'",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "transferOffsetToElements",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Transfer the offset of this stream to all\ninternal elements; then set\nthe offset of this stream to zero.\n>>> a = stream.Stream()\n>>> a.repeatInsert(note.Note('C'), list(range(10)))\n>>> a.offset = 30\n>>> a.transferOffsetToElements()\n>>> a.lowestOffset\n30.0\n>>> a.offset\n0.0\n>>> a.offset = 20\n>>> a.transferOffsetToElements()\n>>> a.lowestOffset\n50.0",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "transpose",
        "type": "Title"
    },
    {
        "text": "value",
        "type": "Title"
    },
    {
        "text": "str",
        "type": "Title"
    },
    {
        "text": "int",
        "type": "Title"
    },
    {
        "text": "'music21.interval.IntervalBase'",
        "type": "Title"
    },
    {
        "text": "inPlace",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "recurse",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "classFilterList",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Transpose all specified classes in the\nStream by the\nuser-provided value. If the value is an integer, the\ntransposition is treated in half steps. If the value is\na string, any Interval string specification can be\nprovided.\nreturns a new Stream by default, but if the\noptional \u009cinPlace\u009d key is set to True then\nit modifies pitches in place.\nTODO: for generic interval set accidental by key signature.\n>>> aInterval = interval.Interval('d5')\n\n\n>>> aStream = corpus.parse('bach/bwv324.xml')\n>>> part = aStream.parts[0]\n>>> [str(p) for p in aStream.parts[0].pitches[:10]]\n['B4', 'D5', 'B4', 'B4', 'B4', 'B4', 'C5', 'B4', 'A4', 'A4']\n\n\n>>> bStream = aStream.parts[0].flatten().transpose('d5')\n>>> [str(p) for p in bStream.pitches[:10]]\n['F5', 'A-5', 'F5', 'F5', 'F5', 'F5', 'G-5', 'F5', 'E-5', 'E-5']\n\n\nTest that aStream hasn't been changed:\n>>> [str(p) for p in aStream.parts[0].pitches[:10]]\n['B4', 'D5', 'B4', 'B4', 'B4', 'B4', 'C5', 'B4', 'A4', 'A4']\n\n\n>>> cStream = bStream.flatten().transpose('a4')\n>>> [str(p) for p in cStream.pitches[:10]]\n['B5', 'D6', 'B5', 'B5', 'B5', 'B5', 'C6', 'B5', 'A5', 'A5']\n\n\n>>> cStream.flatten().transpose(aInterval, inPlace=True)\n>>> [str(p) for p in cStream.pitches[:10]]\n['F6', 'A-6', 'F6', 'F6', 'F6', 'F6', 'G-6', 'F6', 'E-6', 'E-6']\n\n\n\nChanged in v8: first value is position only, all other values are keyword only",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "voicesToParts",
        "type": "Title"
    },
    {
        "text": "separateById",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "If this Stream defines one or more voices,\nextract each into a Part, returning a Score.\nIf this Stream has no voices, return the Stream as a Part within a Score.\n>>> c = corpus.parse('demos/two-voices')\n>>> c.show('t')\n{0.0} <music21.text.TextBox 'Music21 Fr...'>\n{0.0} <music21.text.TextBox 'Music21'>\n{0.0} <music21.metadata.Metadata object at 0x109ce1630>\n{0.0} <music21.stream.Part Piano>\n    {0.0} <music21.instrument.Instrument 'P1: Piano: '>\n    {0.0} <music21.stream.Measure 1 offset=0.0>\n        {0.0} <music21.layout.PageLayout>\n        {0.0} <music21.layout.SystemLayout>\n        ...\n        {0.0} <music21.clef.BassClef>\n        {0.0} <music21.key.Key of D major>\n        {0.0} <music21.meter.TimeSignature 4/4>\n        {0.0} <music21.stream.Voice 3>\n            {0.0} <music21.note.Note E>\n            ...\n            {3.0} <music21.note.Rest quarter>\n        {0.0} <music21.stream.Voice 4>\n            {0.0} <music21.note.Note F#>\n            ...\n            {3.5} <music21.note.Note B>\n    {4.0} <music21.stream.Measure 2 offset=4.0>\n        {0.0} <music21.stream.Voice 3>\n            {0.0} <music21.note.Note E>\n            ...\n            {3.0} <music21.note.Rest quarter>\n        {0.0} <music21.stream.Voice 4>\n            {0.0} <music21.note.Note E>\n            ...\n            {3.5} <music21.note.Note A>\n    {8.0} <music21.stream.Measure 3 offset=8.0>\n        {0.0} <music21.note.Rest whole>\n        {4.0} <music21.bar.Barline type=final>\n{0.0} <music21.layout.ScoreLayout>\n\n\n>>> ce = c.voicesToParts()\n>>> ce.show('t')\n{0.0} <music21.stream.Part Piano-v0>\n    {0.0} <music21.instrument.Instrument 'P1: Piano: '>\n    {0.0} <music21.stream.Measure 1 offset=0.0>\n        {0.0} <music21.clef.TrebleClef>\n        {0.0} <music21.key.Key of D major>\n        {0.0} <music21.meter.TimeSignature 4/4>\n        {0.0} <music21.note.Note E>\n        ...\n        {3.0} <music21.note.Rest quarter>\n    {4.0} <music21.stream.Measure 2 offset=4.0>\n        {0.0} <music21.note.Note E>\n        ...\n        {3.0} <music21.note.Rest quarter>\n    {8.0} <music21.stream.Measure 3 offset=8.0>\n        {0.0} <music21.note.Rest whole>\n        {4.0} <music21.bar.Barline type=final>\n{0.0} <music21.stream.Part Piano-v1>\n    {0.0} <music21.instrument.Instrument 'P1: Piano: '>\n    {0.0} <music21.stream.Measure 1 offset=0.0>\n        {0.0} <music21.clef.BassClef>\n        {0.0} <music21.key.Key of D major>\n        ...\n        {3.5} <music21.note.Note B>\n    {4.0} <music21.stream.Measure 2 offset=4.0>\n        {0.0} <music21.note.Note E>\n        ...\n        {3.5} <music21.note.Note A>\n    {8.0} <music21.stream.Measure 3 offset=8.0>\n        {0.0} <music21.bar.Barline type=final>\n\n\nIf separateById is True then all voices with the same id\nwill be connected to the same Part, regardless of order\nthey appear in the measure.\nCompare the previous output:\n>>> p0pitches = ce.parts[0].pitches\n>>> p1pitches = ce.parts[1].pitches\n>>> ' '.join([p.nameWithOctave for p in p0pitches])\n'E4 D#4 D#4 E4 F#4 E4 B3 B3 E4 E4'\n>>> ' '.join([p.nameWithOctave for p in p1pitches])\n'F#2 F#3 E3 E2 D#2 D#3 B2 B3 E2 E3 D3 D2 C#2 C#3 A2 A3'\n\n\nSwap voice ids in first measure:\n>>> m0 = c.parts[0].getElementsByClass(stream.Measure).first()\n>>> m0.voices[0].id, m0.voices[1].id\n('3', '4')\n>>> m0.voices[0].id = '4'\n>>> m0.voices[1].id = '3'\n\n\nNow run voicesToParts with separateById=True\n>>> ce = c.voicesToParts(separateById=True)\n>>> p0pitches = ce.parts[0].pitches\n>>> p1pitches = ce.parts[1].pitches\n>>> ' '.join([p.nameWithOctave for p in p0pitches])\n'E4 D#4 D#4 E4 F#4 E2 E3 D3 D2 C#2 C#3 A2 A3'\n>>> ' '.join([p.nameWithOctave for p in p1pitches])\n'F#2 F#3 E3 E2 D#2 D#3 B2 B3 E4 B3 B3 E4 E4'\n\n\nNote that the second and subsequent measure's pitches were changed\nnot the first, because separateById aligns the voices according to\norder first encountered, not by sorting the Ids.",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "write",
        "type": "Title"
    },
    {
        "text": "fmt",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "fp",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "**",
        "type": "UncategorizedText"
    },
    {
        "text": "keywords",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Write out a file of music notation (or an image, etc.) in a given format.  If\nfp is specified as a file path then the file will be placed there.  If it is not\ngiven then a temporary file will be created.\nIf fmt is not given then the default of your Environment's \u0098writeFormat' will\nbe used.  For most people that is musicxml.\nReturns the full path to the file.\nSome formats, including .musicxml, create a copy of the stream, pack it into a well-formed\nscore if necessary, and run makeNotation(). To\navoid this when writing .musicxml, use makeNotation=False, an advanced option\nthat prioritizes speed but may not guarantee satisfactory notation.",
        "type": "ListItem"
    },
    {
        "text": "Methods inherited from StreamCore:",
        "type": "NarrativeText"
    },
    {
        "text": "asTimespans() asTree() coreAppend() coreCopyAsDerivation() coreElementsChanged() coreGatherMissingSpanners() coreGetElementByMemoryLocation() coreGuardBeforeAddElement() coreHasElementByMemoryLocation() coreInsert() coreSelfActiveSite() coreSetElementOffset() coreStoreAtEnd()",
        "type": "Table"
    },
    {
        "text": "Methods inherited from Music21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "clearCache() containerHierarchy() contextSites() getAllContextsByClass() getContextByClass() getOffsetBySite() getOffsetInHierarchy() getSpannerSites() informSites() next() previous() purgeLocations() purgeOrphans() setOffsetBySite() sortTuple() splitByQuarterLengths()",
        "type": "Table"
    },
    {
        "text": "Methods inherited from ProtoM21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "isClassOrSubclass()",
        "type": "Table"
    },
    {
        "text": "Stream instance variables",
        "type": "Title"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "autoSort",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Boolean describing whether the Stream is automatically sorted by\noffset whenever necessary.",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "definesExplicitPageBreaks",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Boolean that says whether all page breaks in the piece are\nexplicitly defined.  Only used on musicxml output (maps to the\nmusicxml <supports attribute=\u009dnew-page\u009d> tag) and only if this is\nthe outermost Stream being shown.",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "definesExplicitSystemBreaks",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Boolean that says whether all system breaks in the piece are\nexplicitly defined.  Only used on musicxml output (maps to the\nmusicxml <supports attribute=\u009dnew-system\u009d> tag) and only if this is\nthe outermost Stream being shown",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "isFlat",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Boolean describing whether this Stream contains embedded\nsub-Streams or Stream subclasses (not flat).",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "isSorted",
        "type": "NarrativeText"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Boolean describing whether the Stream is sorted or not.",
        "type": "ListItem"
    },
    {
        "text": "Stream.",
        "type": "Title"
    },
    {
        "text": "recursionType",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Class variable:\nRecursionType Enum of (ELEMENTS_FIRST (default), FLATTEN, ELEMENTS_ONLY)\nthat decides whether the stream likely holds relevant\ncontexts for the elements in it.\nDefine this for a stream class, not an individual object.\nsee contextSites()",
        "type": "ListItem"
    },
    {
        "text": "Instance variables inherited from Music21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "classSortOrder groups isStream sites",
        "type": "Table"
    },
    {
        "text": "Measure\u00c2\u00b6",
        "type": "Title"
    },
    {
        "text": "class",
        "type": "Title"
    },
    {
        "text": "music21.stream.base.",
        "type": "Title"
    },
    {
        "text": "Measure",
        "type": "Title"
    },
    {
        "text": "args",
        "type": "Title"
    },
    {
        "text": "number",
        "type": "Title"
    },
    {
        "text": "int | str",
        "type": "Title"
    },
    {
        "text": "**",
        "type": "UncategorizedText"
    },
    {
        "text": "keywords",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "A representation of a Measure organized as a Stream.\nAll properties of a Measure that are Music21 objects are found as part of\nthe Stream's elements.\nMeasure number can be explicitly set with the number keyword:\n>>> m4 = stream.Measure(number=4)\n>>> m4\n<music21.stream.Measure 4 offset=0.0>\n>>> m4.number\n4\n\n\nIf passed a single integer as an argument, assumes that this int\nis the measure number.\n>>> m5 = stream.Measure(5)\n>>> m5\n<music21.stream.Measure 5 offset=0.0>\n\n\nNumber can also be a string if there is a suffix:\n>>> m4 = stream.Measure(number='4a')\n>>> m4\n<music21.stream.Measure 4a offset=0.0>\n>>> m4.numberSuffix\n'a'\n\n\nThough they have all the features of general streams,\nMeasures have specific attributes that allow for setting their number\nand numberSuffix, keep track of whether they have a different clef or\nkey or timeSignature than previous measures, allow for padding (and pickups),\nand can be found as a \u009cmeasure slice\u009d within a score and parts.",
        "type": "ListItem"
    },
    {
        "text": "Measure bases",
        "type": "Title"
    },
    {
        "text": "Stream",
        "type": "ListItem"
    },
    {
        "text": "StreamCore",
        "type": "ListItem"
    },
    {
        "text": "Music21Object",
        "type": "ListItem"
    },
    {
        "text": "ProtoM21Object",
        "type": "ListItem"
    },
    {
        "text": "Measure read-only properties",
        "type": "Title"
    },
    {
        "text": "Measure.",
        "type": "Title"
    },
    {
        "text": "barDuration",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Return the bar duration, or the Duration specified by the TimeSignature,\nregardless of what elements are found in this Measure or the highest time.\nTimeSignature is found first within the Measure,\nor within a context based search.\nTo get the duration of the total length of elements, just use the\n.duration property.\nHere we create a 3/4 measure and \u009cover-stuff\u009d it with five quarter notes.\nbarDuration still gives a duration of 3.0, or a dotted quarter note,\nwhile .duration gives a whole note tied to a quarter.\n>>> m = stream.Measure()\n>>> m.timeSignature = meter.TimeSignature('3/4')\n>>> m.barDuration\n<music21.duration.Duration 3.0>\n>>> m.repeatAppend(note.Note(type='quarter'), 5)\n>>> m.barDuration\n<music21.duration.Duration 3.0>\n>>> m.duration\n<music21.duration.Duration 5.0>\n\n\nThe objects returned by barDuration and duration are\nfull Duration\nobjects, will all the relevant properties:\n>>> m.barDuration.fullName\n'Dotted Half'\n>>> m.duration.fullName\n'Whole tied to Quarter (5 total QL)'",
        "type": "ListItem"
    },
    {
        "text": "Read-only properties inherited from Stream:",
        "type": "NarrativeText"
    },
    {
        "text": "beat beatDuration beatStr beatStrength flat highestOffset highestTime isGapless lowestOffset notes notesAndRests pitches secondsMap spanners voices",
        "type": "Table"
    },
    {
        "text": "Read-only properties inherited from StreamCore:",
        "type": "NarrativeText"
    },
    {
        "text": "spannerBundle",
        "type": "Table"
    },
    {
        "text": "Read-only properties inherited from Music21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "hasEditorialInformation hasStyleInformation measureNumber",
        "type": "Table"
    },
    {
        "text": "Read-only properties inherited from ProtoM21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "classSet classes",
        "type": "Table"
    },
    {
        "text": "Measure read/write properties",
        "type": "Title"
    },
    {
        "text": "Measure.",
        "type": "Title"
    },
    {
        "text": "leftBarline",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Get or set the left barline, or the Barline object\nfound at offset zero of the Measure.  Can be set either with a string\nrepresenting barline style or a bar.Barline() object or None.\nNote that not all bars have\nbarline objects here \u2014 regular barlines don't need them.",
        "type": "ListItem"
    },
    {
        "text": "Measure.",
        "type": "Title"
    },
    {
        "text": "rightBarline",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Get or set the right barline, or the Barline object\nfound at the offset equal to the bar duration.\n>>> b = bar.Barline('final')\n>>> m = stream.Measure()\n>>> print(m.rightBarline)\nNone\n>>> m.rightBarline = b\n>>> m.rightBarline.type\n'final'\n\n\nA string can also be used instead:\n>>> c = converter.parse('tinynotation: 3/8 C8 D E F G A B4.')\n>>> c.measure(1).rightBarline = 'light-light'\n>>> c.measure(3).rightBarline = 'light-heavy'\n>>> c.show()",
        "type": "ListItem"
    },
    {
        "text": "Read/write properties inherited from Stream:",
        "type": "NarrativeText"
    },
    {
        "text": "atSoundingPitch clef duration elements finalBarline keySignature metadata seconds staffLines timeSignature",
        "type": "Table"
    },
    {
        "text": "Read/write properties inherited from Music21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "activeSite derivation editorial id offset priority quarterLength style",
        "type": "Table"
    },
    {
        "text": "Measure methods",
        "type": "Title"
    },
    {
        "text": "Measure.",
        "type": "Title"
    },
    {
        "text": "barDurationProportion",
        "type": "Title"
    },
    {
        "text": "barDuration",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Return a floating point value greater than 0 showing the proportion\nof the bar duration that is filled based on the highest time of\nall elements. 0.0 is empty, 1.0 is filled; 1.5 specifies of an\noverflow of half.\nBar duration refers to the duration of the Measure as suggested by\nthe TimeSignature. This value cannot be determined without a TimeSignature.\nAn already-obtained Duration object can be supplied with the barDuration\noptional argument.\n>>> import copy\n>>> m = stream.Measure()\n>>> m.timeSignature = meter.TimeSignature('3/4')\n>>> n = note.Note()\n>>> n.quarterLength = 1\n>>> m.append(copy.deepcopy(n))\n>>> m.barDurationProportion()\nFraction(1, 3)\n>>> m.append(copy.deepcopy(n))\n>>> m.barDurationProportion()\nFraction(2, 3)\n>>> m.append(copy.deepcopy(n))\n>>> m.barDurationProportion()\n1.0\n>>> m.append(copy.deepcopy(n))\n>>> m.barDurationProportion()\nFraction(4, 3)",
        "type": "ListItem"
    },
    {
        "text": "Measure.",
        "type": "Title"
    },
    {
        "text": "bestTimeSignature",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Given a Measure with elements in it,\nget a TimeSignature that contains all elements.\nCalls meter.bestTimeSignature(self)\nNote: this does not yet accommodate triplets.\nWe create a simple stream that should be in 3/4\n>>> s = converter.parse('C4 D4 E8 F8', format='tinyNotation', makeNotation=False)\n>>> m = stream.Measure()\n>>> for el in s:\n...     m.insert(el.offset, el)\n\n\nBut there is no TimeSignature!\n>>> m.show('text')\n{0.0} <music21.note.Note C>\n{1.0} <music21.note.Note D>\n{2.0} <music21.note.Note E>\n{2.5} <music21.note.Note F>\n\n\nSo, we get the best Time Signature and put it in the Stream.\n>>> ts = m.bestTimeSignature()\n>>> ts\n<music21.meter.TimeSignature 3/4>\n>>> m.timeSignature = ts\n>>> m.show('text')\n{0.0} <music21.meter.TimeSignature 3/4>\n{0.0} <music21.note.Note C>\n{1.0} <music21.note.Note D>\n{2.0} <music21.note.Note E>\n{2.5} <music21.note.Note F>\n\n\nFor further details about complex time signatures, etc.\nsee meter.bestTimeSignature()",
        "type": "ListItem"
    },
    {
        "text": "Measure.",
        "type": "Title"
    },
    {
        "text": "makeNotation",
        "type": "Title"
    },
    {
        "text": "inPlace",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "**",
        "type": "UncategorizedText"
    },
    {
        "text": "subroutineKeywords",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "This method calls a sequence of Stream methods on this\nMeasure to prepare notation.\nIf inPlace is True, this is done in-place; if\ninPlace is False, this returns a modified deep copy.\n>>> m = stream.Measure()\n>>> n1 = note.Note('g#')\n>>> n2 = note.Note('g')\n>>> m.append([n1, n2])\n>>> m.makeNotation(inPlace=True)\n>>> m.notes[1].pitch.accidental\n<music21.pitch.Accidental natural>",
        "type": "ListItem"
    },
    {
        "text": "Measure.",
        "type": "Title"
    },
    {
        "text": "measureNumberWithSuffix",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Return the measure .number with the .numberSuffix as a string.\n>>> m = stream.Measure()\n>>> m.number = 4\n>>> m.numberSuffix = 'A'\n>>> m.measureNumberWithSuffix()\n'4A'\n\n\nTest that it works as musicxml\n>>> xml = musicxml.m21ToXml.GeneralObjectExporter().parse(m)\n>>> print(xml.decode('utf-8'))\n<?xml version=\"1.0\"...?>\n...\n<part id=\"...\">\n    <!--========================= Measure 4 ==========================-->\n    <measure implicit=\"no\" number=\"4A\">\n...\n\n\nTest round tripping:\n>>> s2 = converter.parseData(xml)\n>>> print(s2[stream.Measure].first().measureNumberWithSuffix())\n4A\n\n\nNote that we use print here because in parsing the data will become a unicode string.",
        "type": "ListItem"
    },
    {
        "text": "Measure.",
        "type": "Title"
    },
    {
        "text": "mergeAttributes",
        "type": "Title"
    },
    {
        "text": "other",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Given another Measure, configure all non-element attributes of this\nMeasure with the attributes of the other Measure. No elements\nwill be changed or copied.\nThis method is necessary because Measures, unlike some Streams,\nhave attributes independent of any stored elements.\nOverrides base.Music21Object.mergeAttributes\n>>> m1 = stream.Measure()\n>>> m1.id = 'MyMeasure'\n>>> m1.clefIsNew = True\n>>> m1.number = 2\n>>> m1.numberSuffix = 'b'\n>>> m1.layoutWidth = 200\n\n\n>>> m2 = stream.Measure()\n>>> m2.mergeAttributes(m1)\n>>> m2.layoutWidth\n200\n>>> m2.id\n'MyMeasure'\n>>> m2\n<music21.stream.Measure 2b offset=0.0>\n\n\nTry with not another Measure\u2026\n>>> m3 = stream.Stream()\n>>> m3.id = 'hello'\n>>> m2.mergeAttributes(m3)\n>>> m2.id\n'hello'\n>>> m2.layoutWidth\n200",
        "type": "ListItem"
    },
    {
        "text": "Measure.",
        "type": "Title"
    },
    {
        "text": "padAsAnacrusis",
        "type": "Title"
    },
    {
        "text": "useGaps",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "useInitialRests",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Given an incompletely filled Measure, adjust the paddingLeft value to\nrepresent contained events as shifted to fill the right-most duration of the bar.\nCalling this method will overwrite any previously set paddingLeft value,\nbased on the current TimeSignature-derived barDuration attribute.\n>>> m = stream.Measure()\n>>> m.timeSignature = meter.TimeSignature('3/4')\n>>> n = note.Note()\n>>> n.quarterLength = 1.0\n>>> m.append(n)\n>>> m.padAsAnacrusis()\n>>> m.paddingLeft\n2.0\n\n\n>>> m.timeSignature = meter.TimeSignature('5/4')\n>>> m.padAsAnacrusis()\n>>> m.paddingLeft\n4.0\n\n\nEmpty space at the beginning of the measure will not be taken in account:\n>>> m = stream.Measure()\n>>> m.timeSignature = meter.TimeSignature('3/4')\n>>> n = note.Note(type='quarter')\n>>> m.insert(2.0, n)\n>>> m.padAsAnacrusis()\n>>> m.paddingLeft\n0.0\n\n\nIf useInitialRests is True, then rests at the beginning of the measure\nare removed.  This is especially useful for formats that don't give a\nway to specify a pickup measure (such as tinynotation) or software\nthat generates incorrect opening measures.  So, to fix the problem before,\nput a rest at the beginning and call useInitialRests:\n>>> r = note.Rest(type='half')\n>>> m.insert(0, r)\n>>> m.padAsAnacrusis(useInitialRests=True)\n>>> m.paddingLeft\n2.0\n\n\nAnd the rest is gone!\n>>> m.show('text')\n{0.0} <music21.meter.TimeSignature 3/4>\n{0.0} <music21.note.Note C>\n\n\nOnly initial rests count for useInitialRests:\n>>> m = stream.Measure()\n>>> m.timeSignature = meter.TimeSignature('3/4')\n>>> m.append(note.Rest(type='eighth'))\n>>> m.append(note.Rest(type='eighth'))\n>>> m.append(note.Note('C4', type='quarter'))\n>>> m.append(note.Rest(type='eighth'))\n>>> m.append(note.Note('D4', type='eighth'))\n>>> m.show('text')\n{0.0} <music21.meter.TimeSignature 3/4>\n{0.0} <music21.note.Rest eighth>\n{0.5} <music21.note.Rest eighth>\n{1.0} <music21.note.Note C>\n{2.0} <music21.note.Rest eighth>\n{2.5} <music21.note.Note D>\n>>> m.padAsAnacrusis(useInitialRests=True)\n>>> m.paddingLeft\n1.0\n>>> m.show('text')\n{0.0} <music21.meter.TimeSignature 3/4>\n{0.0} <music21.note.Note C>\n{1.0} <music21.note.Rest eighth>\n{1.5} <music21.note.Note D>",
        "type": "ListItem"
    },
    {
        "text": "Methods inherited from Stream:",
        "type": "NarrativeText"
    },
    {
        "text": "__eq__() __getitem__() activateVariants() addGroupForElements() allPlayingWhileSounding() analyze() append() attachIntervalsBetweenStreams() attachMelodicIntervals() augmentOrDiminish() beatAndMeasureFromOffset() chordify() clear() cloneEmpty() containerInHierarchy() elementOffset() expandRepeats() explode() extendDuration() extendTies() extractContext() findConsecutiveNotes() findGaps() first() flatten() flattenUnnecessaryVoices() getElementAfterElement() getElementAtOrBefore() getElementBeforeOffset() getElementById() getElementsByClass() getElementsByGroup() getElementsByOffset() getElementsNotOfClass() getInstrument() getInstruments() getOverlaps() getTimeSignatures() hasElement() hasElementOfClass() hasMeasures() hasPartLikeStreams() hasVoices() haveAccidentalsBeenMade() index() insert() insertAndShift() insertIntoNoteOrChord() invertDiatonic() isSequence() isTwelveTone() isWellFormedNotation() iter() last() lyrics() makeAccidentals() makeBeams() makeImmutable() makeMeasures() makeMutable() makeRests() makeTies() makeVoices() measure() measureOffsetMap() measures() melodicIntervals() mergeElements() metronomeMarkBoundaries() offsetMap() playingWhenAttacked() plot() pop() quantize() recurse() recurseRepr() remove() removeByClass() removeByNotOfClass() repeatAppend() repeatInsert() replace() scaleDurations() scaleOffsets() setDerivationMethod() setElementOffset() shiftElements() show() showVariantAsOssialikePart() simultaneousAttacks() sliceAtOffsets() sliceByBeat() sliceByGreatestDivisor() sliceByQuarterLengths() sort() sorted() splitAtDurations() splitAtQuarterLength() splitByClass() storeAtEnd() stripTies() template() toSoundingPitch() toWrittenPitch() transferOffsetToElements() transpose() voicesToParts() write()",
        "type": "Table"
    },
    {
        "text": "Methods inherited from StreamCore:",
        "type": "NarrativeText"
    },
    {
        "text": "asTimespans() asTree() coreAppend() coreCopyAsDerivation() coreElementsChanged() coreGatherMissingSpanners() coreGetElementByMemoryLocation() coreGuardBeforeAddElement() coreHasElementByMemoryLocation() coreInsert() coreSelfActiveSite() coreSetElementOffset() coreStoreAtEnd()",
        "type": "Table"
    },
    {
        "text": "Methods inherited from Music21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "clearCache() containerHierarchy() contextSites() getAllContextsByClass() getContextByClass() getOffsetBySite() getOffsetInHierarchy() getSpannerSites() informSites() next() previous() purgeLocations() purgeOrphans() setOffsetBySite() sortTuple() splitByQuarterLengths()",
        "type": "Table"
    },
    {
        "text": "Methods inherited from ProtoM21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "isClassOrSubclass()",
        "type": "Table"
    },
    {
        "text": "Measure instance variables",
        "type": "Title"
    },
    {
        "text": "Measure.",
        "type": "Title"
    },
    {
        "text": "clefIsNew",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Boolean describing if the Clef is different than the previous Measure.",
        "type": "ListItem"
    },
    {
        "text": "Measure.",
        "type": "Title"
    },
    {
        "text": "keyIsNew",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Boolean describing if KeySignature is different than the previous Measure.",
        "type": "ListItem"
    },
    {
        "text": "Measure.",
        "type": "Title"
    },
    {
        "text": "layoutWidth",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "A suggestion for layout width, though most rendering systems do not support\nthis designation. Use SystemLayout\nobjects instead.",
        "type": "ListItem"
    },
    {
        "text": "Measure.",
        "type": "Title"
    },
    {
        "text": "number",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "A number representing the displayed or shown\nMeasure number as presented in a written Score.",
        "type": "ListItem"
    },
    {
        "text": "Measure.",
        "type": "Title"
    },
    {
        "text": "numberSuffix",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "If a Measure number has a string annotation, such as \u009ca\u009d or similar,\nthis string is stored here. Note that in MusicXML, such\nsuffixes often appear as\nprefixes to measure numbers.  In music21 (like most measure\nnumbering systems), these\nnumbers appear as suffixes.",
        "type": "ListItem"
    },
    {
        "text": "Measure.",
        "type": "Title"
    },
    {
        "text": "paddingLeft",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "defines empty space at the front of the measure for purposes of determining\nbeat, etc for pickup/anacrusis bars.  In 4/4, a\nmeasure with a one-beat pickup\nnote will have a paddingLeft of 3.0.\n(The name comes from the CSS graphical term\nfor the amount of padding on the left side of a region.)",
        "type": "ListItem"
    },
    {
        "text": "Measure.",
        "type": "Title"
    },
    {
        "text": "paddingRight",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "defines empty space at the end of the measure for purposes of determining\nwhether or not a measure is filled.\nIn 4/4, a piece beginning a one-beat pickup\nnote will often have a final measure of three beats, instead of four.\nThe final\nmeasure should have a paddingRight of 1.0.\n(The name comes from the CSS graphical term\nfor the amount of padding on the right side of a region.)",
        "type": "ListItem"
    },
    {
        "text": "Measure.",
        "type": "Title"
    },
    {
        "text": "showNumber",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Enum describing if the measure number should be displayed.",
        "type": "ListItem"
    },
    {
        "text": "Measure.",
        "type": "Title"
    },
    {
        "text": "timeSignatureIsNew",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Boolean describing if the TimeSignature\nis different than the previous Measure.",
        "type": "ListItem"
    },
    {
        "text": "Instance variables inherited from Stream:",
        "type": "NarrativeText"
    },
    {
        "text": "autoSort definesExplicitPageBreaks definesExplicitSystemBreaks isFlat isSorted recursionType",
        "type": "Table"
    },
    {
        "text": "Instance variables inherited from Music21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "classSortOrder groups isStream sites",
        "type": "Table"
    },
    {
        "text": "Part\u00c2\u00b6",
        "type": "Title"
    },
    {
        "text": "class",
        "type": "Title"
    },
    {
        "text": "music21.stream.base.",
        "type": "Title"
    },
    {
        "text": "Part",
        "type": "Title"
    },
    {
        "text": "args",
        "type": "Title"
    },
    {
        "text": "**",
        "type": "UncategorizedText"
    },
    {
        "text": "keywords",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "A Stream subclass for designating music that is considered a single part.\nWhen put into a Score object, Part objects are all collected in the Score.parts\ncall.  Otherwise, they mostly work like generic Streams.\nGenerally the hierarchy goes: Score > Part > Measure > Voice, but you are not\nrequired to stick to this.\nPart groupings (piano braces, etc.) are found in the music21.layout module\nin the StaffGroup Spanner object.",
        "type": "ListItem"
    },
    {
        "text": "Part bases",
        "type": "Title"
    },
    {
        "text": "Stream",
        "type": "ListItem"
    },
    {
        "text": "StreamCore",
        "type": "ListItem"
    },
    {
        "text": "Music21Object",
        "type": "ListItem"
    },
    {
        "text": "ProtoM21Object",
        "type": "ListItem"
    },
    {
        "text": "Part read-only properties",
        "type": "Title"
    },
    {
        "text": "Read-only properties inherited from Stream:",
        "type": "NarrativeText"
    },
    {
        "text": "beat beatDuration beatStr beatStrength flat highestOffset highestTime isGapless lowestOffset notes notesAndRests pitches secondsMap spanners voices",
        "type": "Table"
    },
    {
        "text": "Read-only properties inherited from StreamCore:",
        "type": "NarrativeText"
    },
    {
        "text": "spannerBundle",
        "type": "Table"
    },
    {
        "text": "Read-only properties inherited from Music21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "hasEditorialInformation hasStyleInformation measureNumber",
        "type": "Table"
    },
    {
        "text": "Read-only properties inherited from ProtoM21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "classSet classes",
        "type": "Table"
    },
    {
        "text": "Part read/write properties",
        "type": "Title"
    },
    {
        "text": "Part.",
        "type": "Title"
    },
    {
        "text": "partAbbreviation",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Gets or sets a string representing the abbreviated name of this part\nas a whole (not counting instrument changes, etc.).\nIt can be set explicitly (or set on parsing) or it\ncan take its name from the first Instrument object\nencountered in the stream (or within a substream),\nfirst checking its .partAbbreviation, then checking its .instrumentAbbreviation\nCan also return None.\n>>> p = stream.Part()\n>>> p.partAbbreviation is None\nTrue\n>>> cl = instrument.Clarinet()\n>>> p.insert(0, cl)\n>>> p.partAbbreviation\n'Cl'\n>>> p.remove(cl)\n>>> p.partAbbreviation is None\nTrue\n>>> p.insert(0, instrument.Flute())\n>>> p.partAbbreviation\n'Fl'\n>>> p.partAbbreviation = 'Rd 1'\n>>> p.partAbbreviation\n'Rd 1'\n\n\nNote that changing an instrument's .partAbbreviation or .instrumentAbbreviation while it\nis already in the Stream will not automatically update this unless\n.coreElementsChanged() is called or this Stream's elements are otherwise altered.\nThis is because the value is cached so that O(n) searches through the Stream\ndo not need to be done every time.",
        "type": "ListItem"
    },
    {
        "text": "Part.",
        "type": "Title"
    },
    {
        "text": "partName",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Gets or sets a string representing the name of this part\nas a whole (not counting instrument changes, etc.).\nIt can be set explicitly (or set on parsing) or it\ncan take its name from the first Instrument object\nencountered in the stream (or within a substream),\nfirst checking its .partName, then checking its .instrumentName\nCan also return None.\n>>> p = stream.Part()\n>>> p.partName is None\nTrue\n>>> cl = instrument.Clarinet()\n>>> p.insert(0, cl)\n>>> p.partName\n'Clarinet'\n>>> p.remove(cl)\n>>> p.partName is None\nTrue\n>>> p.insert(0, instrument.Flute())\n>>> p.partName\n'Flute'\n>>> p.partName = 'Reed 1'\n>>> p.partName\n'Reed 1'\n\n\nNote that changing an instrument's .partName or .instrumentName while it\nis already in the Stream will not automatically update this unless\n.coreElementsChanged() is called or this Stream's elements are otherwise altered.\nThis is because the value is cached so that O(n) searches through the Stream\ndo not need to be done every time.",
        "type": "ListItem"
    },
    {
        "text": "Read/write properties inherited from Stream:",
        "type": "NarrativeText"
    },
    {
        "text": "atSoundingPitch clef duration elements finalBarline keySignature metadata seconds staffLines timeSignature",
        "type": "Table"
    },
    {
        "text": "Read/write properties inherited from Music21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "activeSite derivation editorial id offset priority quarterLength style",
        "type": "Table"
    },
    {
        "text": "Part methods",
        "type": "Title"
    },
    {
        "text": "Part.",
        "type": "Title"
    },
    {
        "text": "makeAccidentals",
        "type": "Title"
    },
    {
        "text": "alteredPitches",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "cautionaryPitchClass",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "cautionaryAll",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "inPlace",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "overrideStatus",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "cautionaryNotImmediateRepeat",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "tiePitchSet",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "This overridden method of Stream.makeAccidentals\nwalks measures to arrive at desired values for keyword arguments\ntiePitchSet and pitchPastMeasure when calling makeAccidentals()\non each Measure.\n1. Ties across barlines are detected so that accidentals are not\nunnecessarily reiterated. (tiePitchSet)\n2. Pitches appearing on the same step in an immediately preceding measure,\nif foreign to the key signature of that previous measure,\nare printed with cautionary accidentals in the subsequent measure.\n(pitchPastMeasure)\nMost of the logic has been factored out to\nmakeAccidentalsInMeasureStream(),\nwhich is called after managing the inPlace keyword and finding\nmeasures to iterate.\n\nChanged in v7: inPlace defaults False",
        "type": "ListItem"
    },
    {
        "text": "Part.",
        "type": "Title"
    },
    {
        "text": "mergeAttributes",
        "type": "Title"
    },
    {
        "text": "other",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Merge relevant attributes from the Other part\ninto this one. Key attributes of difference: partName and partAbbreviation.\nTODO: doc test",
        "type": "ListItem"
    },
    {
        "text": "Methods inherited from Stream:",
        "type": "NarrativeText"
    },
    {
        "text": "__eq__() __getitem__() activateVariants() addGroupForElements() allPlayingWhileSounding() analyze() append() attachIntervalsBetweenStreams() attachMelodicIntervals() augmentOrDiminish() beatAndMeasureFromOffset() chordify() clear() cloneEmpty() containerInHierarchy() elementOffset() expandRepeats() explode() extendDuration() extendTies() extractContext() findConsecutiveNotes() findGaps() first() flatten() flattenUnnecessaryVoices() getElementAfterElement() getElementAtOrBefore() getElementBeforeOffset() getElementById() getElementsByClass() getElementsByGroup() getElementsByOffset() getElementsNotOfClass() getInstrument() getInstruments() getOverlaps() getTimeSignatures() hasElement() hasElementOfClass() hasMeasures() hasPartLikeStreams() hasVoices() haveAccidentalsBeenMade() index() insert() insertAndShift() insertIntoNoteOrChord() invertDiatonic() isSequence() isTwelveTone() isWellFormedNotation() iter() last() lyrics() makeBeams() makeImmutable() makeMeasures() makeMutable() makeNotation() makeRests() makeTies() makeVoices() measure() measureOffsetMap() measures() melodicIntervals() mergeElements() metronomeMarkBoundaries() offsetMap() playingWhenAttacked() plot() pop() quantize() recurse() recurseRepr() remove() removeByClass() removeByNotOfClass() repeatAppend() repeatInsert() replace() scaleDurations() scaleOffsets() setDerivationMethod() setElementOffset() shiftElements() show() showVariantAsOssialikePart() simultaneousAttacks() sliceAtOffsets() sliceByBeat() sliceByGreatestDivisor() sliceByQuarterLengths() sort() sorted() splitAtDurations() splitAtQuarterLength() splitByClass() storeAtEnd() stripTies() template() toSoundingPitch() toWrittenPitch() transferOffsetToElements() transpose() voicesToParts() write()",
        "type": "Table"
    },
    {
        "text": "Methods inherited from StreamCore:",
        "type": "NarrativeText"
    },
    {
        "text": "asTimespans() asTree() coreAppend() coreCopyAsDerivation() coreElementsChanged() coreGatherMissingSpanners() coreGetElementByMemoryLocation() coreGuardBeforeAddElement() coreHasElementByMemoryLocation() coreInsert() coreSelfActiveSite() coreSetElementOffset() coreStoreAtEnd()",
        "type": "Table"
    },
    {
        "text": "Methods inherited from Music21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "clearCache() containerHierarchy() contextSites() getAllContextsByClass() getContextByClass() getOffsetBySite() getOffsetInHierarchy() getSpannerSites() informSites() next() previous() purgeLocations() purgeOrphans() setOffsetBySite() sortTuple() splitByQuarterLengths()",
        "type": "Table"
    },
    {
        "text": "Methods inherited from ProtoM21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "isClassOrSubclass()",
        "type": "Table"
    },
    {
        "text": "Part instance variables",
        "type": "Title"
    },
    {
        "text": "Instance variables inherited from Stream:",
        "type": "NarrativeText"
    },
    {
        "text": "autoSort definesExplicitPageBreaks definesExplicitSystemBreaks isFlat isSorted recursionType",
        "type": "Table"
    },
    {
        "text": "Instance variables inherited from Music21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "classSortOrder groups isStream sites",
        "type": "Table"
    },
    {
        "text": "Score\u00c2\u00b6",
        "type": "Title"
    },
    {
        "text": "class",
        "type": "Title"
    },
    {
        "text": "music21.stream.base.",
        "type": "Title"
    },
    {
        "text": "Score",
        "type": "Title"
    },
    {
        "text": "givenElements",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "Music21Object",
        "type": "Title"
    },
    {
        "text": "Sequence",
        "type": "Title"
    },
    {
        "text": "Music21Object",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "givenElementsBehavior",
        "type": "Title"
    },
    {
        "text": "GivenElementsBehavior",
        "type": "Title"
    },
    {
        "text": "GivenElementsBehavior.OFFSETS",
        "type": "Title"
    },
    {
        "text": "**",
        "type": "UncategorizedText"
    },
    {
        "text": "keywords",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "A Stream subclass for handling music with more than one Part.\nAlmost totally optional (the largest containing Stream in a piece could be\na generic Stream, or a Part, or a Staff).  And Scores can be\nembedded in other Scores (in fact, our original thought was to call\nthis class a Fragment because of this possibility of continuous\nembedding; though it's probably better to embed a Score in an Opus),\nbut we figure that many people will like calling the largest\ncontainer a Score and that this will become a standard.",
        "type": "ListItem"
    },
    {
        "text": "Score bases",
        "type": "Title"
    },
    {
        "text": "Stream",
        "type": "ListItem"
    },
    {
        "text": "StreamCore",
        "type": "ListItem"
    },
    {
        "text": "Music21Object",
        "type": "ListItem"
    },
    {
        "text": "ProtoM21Object",
        "type": "ListItem"
    },
    {
        "text": "Score read-only properties",
        "type": "Title"
    },
    {
        "text": "Score.",
        "type": "Title"
    },
    {
        "text": "parts",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Return all Part objects in a Score.\nIt filters out all other things that might be in a Score object, such as Metadata\nreturning just the Parts.\n>>> s = corpus.parse('bach/bwv66.6')\n>>> s.parts\n<music21.stream.iterator.StreamIterator for Score:bach/bwv66.6.mxl @:0>\n>>> len(s.parts)\n4",
        "type": "ListItem"
    },
    {
        "text": "Read-only properties inherited from Stream:",
        "type": "NarrativeText"
    },
    {
        "text": "beat beatDuration beatStr beatStrength flat highestOffset highestTime isGapless lowestOffset notes notesAndRests pitches secondsMap spanners voices",
        "type": "Table"
    },
    {
        "text": "Read-only properties inherited from StreamCore:",
        "type": "NarrativeText"
    },
    {
        "text": "spannerBundle",
        "type": "Table"
    },
    {
        "text": "Read-only properties inherited from Music21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "hasEditorialInformation hasStyleInformation measureNumber",
        "type": "Table"
    },
    {
        "text": "Read-only properties inherited from ProtoM21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "classSet classes",
        "type": "Table"
    },
    {
        "text": "Score read/write properties",
        "type": "Title"
    },
    {
        "text": "Read/write properties inherited from Stream:",
        "type": "NarrativeText"
    },
    {
        "text": "atSoundingPitch clef duration elements finalBarline keySignature metadata seconds staffLines timeSignature",
        "type": "Table"
    },
    {
        "text": "Read/write properties inherited from Music21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "activeSite derivation editorial id offset priority quarterLength style",
        "type": "Table"
    },
    {
        "text": "Score methods",
        "type": "Title"
    },
    {
        "text": "Score.",
        "type": "Title"
    },
    {
        "text": "expandRepeats",
        "type": "Title"
    },
    {
        "text": "copySpanners",
        "type": "Title"
    },
    {
        "text": "bool",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "\u2192 Score",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Expand all repeats, as well as all repeat indications\ngiven by text expressions such as D.C. al Segno.\nThis method always returns a new Stream, with deepcopies\nof all contained elements at all level.\nNote that copySpanners is ignored here, as they are always copied.",
        "type": "ListItem"
    },
    {
        "text": "Score.",
        "type": "Title"
    },
    {
        "text": "implode",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Reduce a polyphonic work into two staves.\nCurrently, this is just a synonym for partsToVoices with\nvoiceAllocation = 2, and permitOneVoicePerPart = False,\nbut someday this will have better methods for finding identical\nparts, etc.",
        "type": "ListItem"
    },
    {
        "text": "Score.",
        "type": "Title"
    },
    {
        "text": "makeNotation",
        "type": "Title"
    },
    {
        "text": "meterStream",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "refStreamOrTimeRange",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "inPlace",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "bestClef",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "**",
        "type": "UncategorizedText"
    },
    {
        "text": "subroutineKeywords",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "This method overrides the makeNotation method on Stream,\nsuch that a Score object with one or more Parts or Streams\nthat may not contain well-formed notation may be transformed\nand replaced by well-formed notation.\nIf inPlace is True, this is done in-place;\nif inPlace is False, this returns a modified deep copy.",
        "type": "ListItem"
    },
    {
        "text": "Score.",
        "type": "Title"
    },
    {
        "text": "measure",
        "type": "Title"
    },
    {
        "text": "measureNumber",
        "type": "Title"
    },
    {
        "text": "collect=(<class 'music21.clef.Clef'>",
        "type": "Title"
    },
    {
        "text": "<class 'music21.meter.base.TimeSignature'>",
        "type": "Title"
    },
    {
        "text": "<class 'music21.instrument.Instrument'>",
        "type": "Title"
    },
    {
        "text": "<class 'music21.key.KeySignature'>)",
        "type": "Title"
    },
    {
        "text": "gatherSpanners=GatherSpanners.ALL",
        "type": "Title"
    },
    {
        "text": "indicesNotNumbers=False",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Given a measure number (or measure index, if indicesNotNumbers is True)\nreturn another Score object which contains multiple parts but each of which has only a\nsingle Measure object if the\nMeasure number exists, otherwise returns a score with parts that are empty.\nThis method overrides the measure() method on Stream to\nallow for finding a single \u009cmeasure slice\u009d within parts:\n>>> bachIn = corpus.parse('bach/bwv324.xml')\n>>> excerpt = bachIn.measure(2)\n>>> excerpt\n<music21.stream.Score bach/bwv324.mxl>\n>>> len(excerpt.parts)\n4\n>>> excerpt.parts[0].show('text')\n{0.0} <music21.instrument.Instrument 'P1: Soprano: '>\n{0.0} <music21.clef.TrebleClef>\n{0.0} <music21.key.Key of e minor>\n{0.0} <music21.meter.TimeSignature 4/4>\n{0.0} <music21.stream.Measure 2 offset=0.0>\n    {0.0} <music21.note.Note B>\n    {1.0} <music21.note.Note B>\n    {2.0} <music21.note.Note B>\n    {3.0} <music21.note.Note B>\n\n\nNote that the parts created have all the meta-information outside the measure\nunless this information appears in the measure itself at the beginning:\n>>> bachIn.measure(1).parts[0].show('text')\n{0.0} <music21.instrument.Instrument 'P1: Soprano: '>\n{0.0} <music21.stream.Measure 1 offset=0.0>\n    {0.0} <music21.clef.TrebleClef>\n    {0.0} <music21.key.Key of e minor>\n    {0.0} <music21.meter.TimeSignature 4/4>\n    {0.0} <music21.layout.SystemLayout>\n    {0.0} <music21.note.Note B>\n    {2.0} <music21.note.Note D>\n\n\nThis way the original measure objects can be returned without being altered.\nThe final measure slice of the piece can be obtained with index -1.  Example:\nquickly get the last chord of the piece, without needing to run .chordify()\non the whole piece:\n>>> excerpt = bachIn.measure(-1)\n>>> excerptChords = excerpt.chordify()\n>>> excerptChords.show('text')\n{0.0} <music21.instrument.Instrument 'P1: Soprano: '>\n{0.0} <music21.clef.TrebleClef>\n{0.0} <music21.key.Key of e minor>\n{0.0} <music21.meter.TimeSignature 4/4>\n{0.0} <music21.stream.Measure 9 offset=0.0>\n    {0.0} <music21.chord.Chord E2 G3 B3 E4>\n    {4.0} <music21.bar.Barline type=final>\n\n\n>>> lastChord = excerptChords[chord.Chord].last()\n>>> lastChord\n<music21.chord.Chord E2 G3 B3 E4>\n\n\nNote that we still do a .getElementsByClass(chord.Chord) since many pieces end\nwith nothing but a rest\u2026",
        "type": "ListItem"
    },
    {
        "text": "Score.",
        "type": "Title"
    },
    {
        "text": "measureOffsetMap",
        "type": "Title"
    },
    {
        "text": "classFilterList",
        "type": "Title"
    },
    {
        "text": "list",
        "type": "Title"
    },
    {
        "text": "Type",
        "type": "Title"
    },
    {
        "text": "list",
        "type": "Title"
    },
    {
        "text": "str",
        "type": "Title"
    },
    {
        "text": "tuple",
        "type": "Title"
    },
    {
        "text": "Type",
        "type": "Title"
    },
    {
        "text": "tuple",
        "type": "Title"
    },
    {
        "text": "str",
        "type": "Title"
    },
    {
        "text": "('Measure',)",
        "type": "Title"
    },
    {
        "text": "\u2192 OrderedDict[float | Fraction, list[music21.stream.base.Measure]]",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "This Score method overrides the\nmeasureOffsetMap() method of Stream.\nThis creates a map based on all contained Parts in this Score.\nMeasures found in multiple Parts with the same offset will be\nappended to the same list.\nIf no parts are found in the score, then the normal\nmeasureOffsetMap() routine is called.\nThis method is smart and does not assume that all Parts\nhave measures with identical offsets.",
        "type": "ListItem"
    },
    {
        "text": "Score.",
        "type": "Title"
    },
    {
        "text": "measures",
        "type": "Title"
    },
    {
        "text": "numberStart",
        "type": "Title"
    },
    {
        "text": "numberEnd",
        "type": "Title"
    },
    {
        "text": "collect",
        "type": "Title"
    },
    {
        "text": "('Clef', 'TimeSignature', 'Instrument', 'KeySignature')",
        "type": "Title"
    },
    {
        "text": "gatherSpanners",
        "type": "Title"
    },
    {
        "text": "GatherSpanners.ALL",
        "type": "Title"
    },
    {
        "text": "indicesNotNumbers",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "This method overrides the measures()\nmethod on Stream. This creates a new Score stream that has the same measure\nrange for all Parts.\nThe collect argument is a list of classes that will be collected; see\nStream.measures()\n>>> s = corpus.parse('bwv66.6')\n>>> post = s.measures(3, 5)  # range is inclusive, i.e., [3, 5]\n>>> len(post.parts)\n4\n>>> len(post.parts[0].getElementsByClass(stream.Measure))\n3\n>>> len(post.parts[1].getElementsByClass(stream.Measure))\n3",
        "type": "ListItem"
    },
    {
        "text": "Score.",
        "type": "Title"
    },
    {
        "text": "partsToVoices",
        "type": "Title"
    },
    {
        "text": "voiceAllocation",
        "type": "Title"
    },
    {
        "text": "int",
        "type": "Title"
    },
    {
        "text": "list",
        "type": "Title"
    },
    {
        "text": "list",
        "type": "Title"
    },
    {
        "text": "int",
        "type": "Title"
    },
    {
        "text": "permitOneVoicePerPart",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "setStems",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Given a multi-part Score,\nreturn a new Score that combines parts into voices.\nThe voiceAllocation parameter sets the maximum number\nof voices per Part.\nThe permitOneVoicePerPart parameter, if True, will encode a\nsingle voice inside a single Part, rather than leaving it as\na single Part alone, with no internal voices.\n>>> s = corpus.parse('bwv66.6')\n>>> len(s.flatten().notes)\n165\n>>> post = s.partsToVoices(voiceAllocation=4)\n>>> len(post.parts)\n1\n>>> len(post.parts.first().getElementsByClass(stream.Measure).first().voices)\n4\n>>> len(post.flatten().notes)\n165",
        "type": "ListItem"
    },
    {
        "text": "Score.",
        "type": "Title"
    },
    {
        "text": "sliceByGreatestDivisor",
        "type": "Title"
    },
    {
        "text": "addTies",
        "type": "Title"
    },
    {
        "text": "bool",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "inPlace",
        "type": "Title"
    },
    {
        "text": "Literal[True]",
        "type": "Title"
    },
    {
        "text": "\u2192 None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Score.",
        "type": "Title"
    },
    {
        "text": "sliceByGreatestDivisor",
        "type": "Title"
    },
    {
        "text": "addTies",
        "type": "Title"
    },
    {
        "text": "bool",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "inPlace",
        "type": "Title"
    },
    {
        "text": "Literal[False]",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "\u2192 Score",
        "type": "Title"
    },
    {
        "text": "Slice all duration of all part by the minimum duration\nthat can be summed to each concurrent duration.\nOverrides method defined on Stream.",
        "type": "ListItem"
    },
    {
        "text": "Methods inherited from Stream:",
        "type": "NarrativeText"
    },
    {
        "text": "__eq__() __getitem__() activateVariants() addGroupForElements() allPlayingWhileSounding() analyze() append() attachIntervalsBetweenStreams() attachMelodicIntervals() augmentOrDiminish() beatAndMeasureFromOffset() chordify() clear() cloneEmpty() containerInHierarchy() elementOffset() explode() extendDuration() extendTies() extractContext() findConsecutiveNotes() findGaps() first() flatten() flattenUnnecessaryVoices() getElementAfterElement() getElementAtOrBefore() getElementBeforeOffset() getElementById() getElementsByClass() getElementsByGroup() getElementsByOffset() getElementsNotOfClass() getInstrument() getInstruments() getOverlaps() getTimeSignatures() hasElement() hasElementOfClass() hasMeasures() hasPartLikeStreams() hasVoices() haveAccidentalsBeenMade() index() insert() insertAndShift() insertIntoNoteOrChord() invertDiatonic() isSequence() isTwelveTone() isWellFormedNotation() iter() last() lyrics() makeAccidentals() makeBeams() makeImmutable() makeMeasures() makeMutable() makeRests() makeTies() makeVoices() melodicIntervals() mergeAttributes() mergeElements() metronomeMarkBoundaries() offsetMap() playingWhenAttacked() plot() pop() quantize() recurse() recurseRepr() remove() removeByClass() removeByNotOfClass() repeatAppend() repeatInsert() replace() scaleDurations() scaleOffsets() setDerivationMethod() setElementOffset() shiftElements() show() showVariantAsOssialikePart() simultaneousAttacks() sliceAtOffsets() sliceByBeat() sliceByQuarterLengths() sort() sorted() splitAtDurations() splitAtQuarterLength() splitByClass() storeAtEnd() stripTies() template() toSoundingPitch() toWrittenPitch() transferOffsetToElements() transpose() voicesToParts() write()",
        "type": "Table"
    },
    {
        "text": "Methods inherited from StreamCore:",
        "type": "NarrativeText"
    },
    {
        "text": "asTimespans() asTree() coreAppend() coreCopyAsDerivation() coreElementsChanged() coreGatherMissingSpanners() coreGetElementByMemoryLocation() coreGuardBeforeAddElement() coreHasElementByMemoryLocation() coreInsert() coreSelfActiveSite() coreSetElementOffset() coreStoreAtEnd()",
        "type": "Table"
    },
    {
        "text": "Methods inherited from Music21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "clearCache() containerHierarchy() contextSites() getAllContextsByClass() getContextByClass() getOffsetBySite() getOffsetInHierarchy() getSpannerSites() informSites() next() previous() purgeLocations() purgeOrphans() setOffsetBySite() sortTuple() splitByQuarterLengths()",
        "type": "Table"
    },
    {
        "text": "Methods inherited from ProtoM21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "isClassOrSubclass()",
        "type": "Table"
    },
    {
        "text": "Score instance variables",
        "type": "Title"
    },
    {
        "text": "Instance variables inherited from Stream:",
        "type": "NarrativeText"
    },
    {
        "text": "autoSort definesExplicitPageBreaks definesExplicitSystemBreaks isFlat isSorted recursionType",
        "type": "Table"
    },
    {
        "text": "Instance variables inherited from Music21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "classSortOrder groups isStream sites",
        "type": "Table"
    },
    {
        "text": "Opus\u00c2\u00b6",
        "type": "Title"
    },
    {
        "text": "class",
        "type": "Title"
    },
    {
        "text": "music21.stream.base.",
        "type": "Title"
    },
    {
        "text": "Opus",
        "type": "Title"
    },
    {
        "text": "givenElements",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "Music21Object",
        "type": "Title"
    },
    {
        "text": "Sequence",
        "type": "Title"
    },
    {
        "text": "Music21Object",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "givenElementsBehavior",
        "type": "Title"
    },
    {
        "text": "GivenElementsBehavior",
        "type": "Title"
    },
    {
        "text": "GivenElementsBehavior.OFFSETS",
        "type": "Title"
    },
    {
        "text": "**",
        "type": "UncategorizedText"
    },
    {
        "text": "keywords",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "A Stream subclass for handling multi-work music encodings.\nMany ABC files, for example, define multiple works or parts within a single file.\nOpus objects can contain multiple Score objects, or even other Opus objects!",
        "type": "ListItem"
    },
    {
        "text": "Opus bases",
        "type": "Title"
    },
    {
        "text": "Stream",
        "type": "ListItem"
    },
    {
        "text": "StreamCore",
        "type": "ListItem"
    },
    {
        "text": "Music21Object",
        "type": "ListItem"
    },
    {
        "text": "ProtoM21Object",
        "type": "ListItem"
    },
    {
        "text": "Opus read-only properties",
        "type": "Title"
    },
    {
        "text": "Opus.",
        "type": "Title"
    },
    {
        "text": "scores",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Return all Score objects\nin an iterator",
        "type": "ListItem"
    },
    {
        "text": "Read-only properties inherited from Stream:",
        "type": "NarrativeText"
    },
    {
        "text": "beat beatDuration beatStr beatStrength flat highestOffset highestTime isGapless lowestOffset notes notesAndRests pitches secondsMap spanners voices",
        "type": "Table"
    },
    {
        "text": "Read-only properties inherited from StreamCore:",
        "type": "NarrativeText"
    },
    {
        "text": "spannerBundle",
        "type": "Table"
    },
    {
        "text": "Read-only properties inherited from Music21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "hasEditorialInformation hasStyleInformation measureNumber",
        "type": "Table"
    },
    {
        "text": "Read-only properties inherited from ProtoM21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "classSet classes",
        "type": "Table"
    },
    {
        "text": "Opus read/write properties",
        "type": "Title"
    },
    {
        "text": "Read/write properties inherited from Stream:",
        "type": "NarrativeText"
    },
    {
        "text": "atSoundingPitch clef duration elements finalBarline keySignature metadata seconds staffLines timeSignature",
        "type": "Table"
    },
    {
        "text": "Read/write properties inherited from Music21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "activeSite derivation editorial id offset priority quarterLength style",
        "type": "Table"
    },
    {
        "text": "Opus methods",
        "type": "Title"
    },
    {
        "text": "Opus.",
        "type": "Title"
    },
    {
        "text": "getNumbers",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Return a list of all numbers defined in this Opus.\n>>> o = corpus.parse('josquin/oVenusBant')\n>>> o.getNumbers()\n['1', '2', '3']",
        "type": "ListItem"
    },
    {
        "text": "Opus.",
        "type": "Title"
    },
    {
        "text": "getScoreByNumber",
        "type": "Title"
    },
    {
        "text": "opusMatch",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Get Score objects from this Stream by number.\nPerforms title search using the\nsearch() method,\nand returns the first result.\n>>> o = corpus.parse('josquin/oVenusBant')\n>>> o.getNumbers()\n['1', '2', '3']\n>>> s = o.getScoreByNumber(2)\n>>> s.metadata.title\n'O Venus bant'\n>>> s.metadata.alternativeTitle\n'Tenor'",
        "type": "ListItem"
    },
    {
        "text": "Opus.",
        "type": "Title"
    },
    {
        "text": "getScoreByTitle",
        "type": "Title"
    },
    {
        "text": "titleMatch",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Get Score objects from this Stream by a title.\nPerforms title search using the search() method,\nand returns the first result.\n>>> o = corpus.parse('essenFolksong/erk5')\n>>> s = o.getScoreByTitle('Vrienden, kommt alle gaere')\n>>> s.metadata.title\n'Vrienden, kommt alle gaere'\n\n\nRegular expressions work fine\n>>> s = o.getScoreByTitle('(.*)kommt(.*)')\n>>> s.metadata.title\n'Vrienden, kommt alle gaere'",
        "type": "ListItem"
    },
    {
        "text": "Opus.",
        "type": "Title"
    },
    {
        "text": "mergeScores",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Some Opus objects represent numerous scores\nthat are individual parts of the same work.\nThis method will treat each contained Score as a Part,\nmerging and returning a single Score with merged Metadata.\n>>> o = corpus.parse('josquin/milleRegrets')\n>>> s = o.mergeScores()\n>>> s.metadata.title\n'Mille regrets'\n>>> len(s.parts)\n4",
        "type": "ListItem"
    },
    {
        "text": "Opus.",
        "type": "Title"
    },
    {
        "text": "show",
        "type": "Title"
    },
    {
        "text": "fmt",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "app",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "**",
        "type": "UncategorizedText"
    },
    {
        "text": "keywords",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Show an Opus file.\nThis method overrides the behavior specified in\nMusic21Object for all\nformats besides explicit lily.x calls. or when running under Jupyter notebook.",
        "type": "ListItem"
    },
    {
        "text": "Opus.",
        "type": "Title"
    },
    {
        "text": "write",
        "type": "Title"
    },
    {
        "text": "fmt",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "fp",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "**",
        "type": "UncategorizedText"
    },
    {
        "text": "keywords",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Displays an object in a format provided by the fmt argument or, if not\nprovided, the format set in the user's Environment.\nThis method overrides the behavior specified in\nMusic21Object for all formats besides explicit\nlily.x calls.\nIndividual files are written for each score; returns the last file written.\n>>> sc1 = stream.Score()\n>>> sc2 = stream.Score()\n>>> o = stream.Opus()\n>>> o.append([sc1, sc2])\n\n\n#_DOCS_SHOW >>> o.write()\n#_DOCS_SHOW PosixPath(\u0098/some/temp/path-2.xml')",
        "type": "ListItem"
    },
    {
        "text": "Methods inherited from Stream:",
        "type": "NarrativeText"
    },
    {
        "text": "__eq__() __getitem__() activateVariants() addGroupForElements() allPlayingWhileSounding() analyze() append() attachIntervalsBetweenStreams() attachMelodicIntervals() augmentOrDiminish() beatAndMeasureFromOffset() chordify() clear() cloneEmpty() containerInHierarchy() elementOffset() expandRepeats() explode() extendDuration() extendTies() extractContext() findConsecutiveNotes() findGaps() first() flatten() flattenUnnecessaryVoices() getElementAfterElement() getElementAtOrBefore() getElementBeforeOffset() getElementById() getElementsByClass() getElementsByGroup() getElementsByOffset() getElementsNotOfClass() getInstrument() getInstruments() getOverlaps() getTimeSignatures() hasElement() hasElementOfClass() hasMeasures() hasPartLikeStreams() hasVoices() haveAccidentalsBeenMade() index() insert() insertAndShift() insertIntoNoteOrChord() invertDiatonic() isSequence() isTwelveTone() isWellFormedNotation() iter() last() lyrics() makeAccidentals() makeBeams() makeImmutable() makeMeasures() makeMutable() makeNotation() makeRests() makeTies() makeVoices() measure() measureOffsetMap() measures() melodicIntervals() mergeAttributes() mergeElements() metronomeMarkBoundaries() offsetMap() playingWhenAttacked() plot() pop() quantize() recurse() recurseRepr() remove() removeByClass() removeByNotOfClass() repeatAppend() repeatInsert() replace() scaleDurations() scaleOffsets() setDerivationMethod() setElementOffset() shiftElements() showVariantAsOssialikePart() simultaneousAttacks() sliceAtOffsets() sliceByBeat() sliceByGreatestDivisor() sliceByQuarterLengths() sort() sorted() splitAtDurations() splitAtQuarterLength() splitByClass() storeAtEnd() stripTies() template() toSoundingPitch() toWrittenPitch() transferOffsetToElements() transpose() voicesToParts()",
        "type": "Table"
    },
    {
        "text": "Methods inherited from StreamCore:",
        "type": "NarrativeText"
    },
    {
        "text": "asTimespans() asTree() coreAppend() coreCopyAsDerivation() coreElementsChanged() coreGatherMissingSpanners() coreGetElementByMemoryLocation() coreGuardBeforeAddElement() coreHasElementByMemoryLocation() coreInsert() coreSelfActiveSite() coreSetElementOffset() coreStoreAtEnd()",
        "type": "Table"
    },
    {
        "text": "Methods inherited from Music21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "clearCache() containerHierarchy() contextSites() getAllContextsByClass() getContextByClass() getOffsetBySite() getOffsetInHierarchy() getSpannerSites() informSites() next() previous() purgeLocations() purgeOrphans() setOffsetBySite() sortTuple() splitByQuarterLengths()",
        "type": "Table"
    },
    {
        "text": "Methods inherited from ProtoM21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "isClassOrSubclass()",
        "type": "Table"
    },
    {
        "text": "Opus instance variables",
        "type": "Title"
    },
    {
        "text": "Instance variables inherited from Stream:",
        "type": "NarrativeText"
    },
    {
        "text": "autoSort definesExplicitPageBreaks definesExplicitSystemBreaks isFlat isSorted recursionType",
        "type": "Table"
    },
    {
        "text": "Instance variables inherited from Music21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "classSortOrder groups isStream sites",
        "type": "Table"
    },
    {
        "text": "Voice\u00c2\u00b6",
        "type": "Title"
    },
    {
        "text": "class",
        "type": "Title"
    },
    {
        "text": "music21.stream.base.",
        "type": "Title"
    },
    {
        "text": "Voice",
        "type": "Title"
    },
    {
        "text": "givenElements",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "Music21Object",
        "type": "Title"
    },
    {
        "text": "Sequence",
        "type": "Title"
    },
    {
        "text": "Music21Object",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "givenElementsBehavior",
        "type": "Title"
    },
    {
        "text": "GivenElementsBehavior",
        "type": "Title"
    },
    {
        "text": "GivenElementsBehavior.OFFSETS",
        "type": "Title"
    },
    {
        "text": "**",
        "type": "UncategorizedText"
    },
    {
        "text": "keywords",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "A Stream subclass for declaring that all the music in the\nstream belongs to a certain \u009cvoice\u009d for analysis or display\npurposes.\nNote that both Finale's Layers and Voices as concepts are\nconsidered Voices here.\nVoices have a sort order of 1 greater than time signatures",
        "type": "ListItem"
    },
    {
        "text": "Voice bases",
        "type": "Title"
    },
    {
        "text": "Stream",
        "type": "ListItem"
    },
    {
        "text": "StreamCore",
        "type": "ListItem"
    },
    {
        "text": "Music21Object",
        "type": "ListItem"
    },
    {
        "text": "ProtoM21Object",
        "type": "ListItem"
    },
    {
        "text": "Voice read-only properties",
        "type": "Title"
    },
    {
        "text": "Read-only properties inherited from Stream:",
        "type": "NarrativeText"
    },
    {
        "text": "beat beatDuration beatStr beatStrength flat highestOffset highestTime isGapless lowestOffset notes notesAndRests pitches secondsMap spanners voices",
        "type": "Table"
    },
    {
        "text": "Read-only properties inherited from StreamCore:",
        "type": "NarrativeText"
    },
    {
        "text": "spannerBundle",
        "type": "Table"
    },
    {
        "text": "Read-only properties inherited from Music21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "hasEditorialInformation hasStyleInformation measureNumber",
        "type": "Table"
    },
    {
        "text": "Read-only properties inherited from ProtoM21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "classSet classes",
        "type": "Table"
    },
    {
        "text": "Voice read/write properties",
        "type": "Title"
    },
    {
        "text": "Read/write properties inherited from Stream:",
        "type": "NarrativeText"
    },
    {
        "text": "atSoundingPitch clef duration elements finalBarline keySignature metadata seconds staffLines timeSignature",
        "type": "Table"
    },
    {
        "text": "Read/write properties inherited from Music21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "activeSite derivation editorial id offset priority quarterLength style",
        "type": "Table"
    },
    {
        "text": "Voice methods",
        "type": "Title"
    },
    {
        "text": "Methods inherited from Stream:",
        "type": "NarrativeText"
    },
    {
        "text": "__eq__() __getitem__() activateVariants() addGroupForElements() allPlayingWhileSounding() analyze() append() attachIntervalsBetweenStreams() attachMelodicIntervals() augmentOrDiminish() beatAndMeasureFromOffset() chordify() clear() cloneEmpty() containerInHierarchy() elementOffset() expandRepeats() explode() extendDuration() extendTies() extractContext() findConsecutiveNotes() findGaps() first() flatten() flattenUnnecessaryVoices() getElementAfterElement() getElementAtOrBefore() getElementBeforeOffset() getElementById() getElementsByClass() getElementsByGroup() getElementsByOffset() getElementsNotOfClass() getInstrument() getInstruments() getOverlaps() getTimeSignatures() hasElement() hasElementOfClass() hasMeasures() hasPartLikeStreams() hasVoices() haveAccidentalsBeenMade() index() insert() insertAndShift() insertIntoNoteOrChord() invertDiatonic() isSequence() isTwelveTone() isWellFormedNotation() iter() last() lyrics() makeAccidentals() makeBeams() makeImmutable() makeMeasures() makeMutable() makeNotation() makeRests() makeTies() makeVoices() measure() measureOffsetMap() measures() melodicIntervals() mergeAttributes() mergeElements() metronomeMarkBoundaries() offsetMap() playingWhenAttacked() plot() pop() quantize() recurse() recurseRepr() remove() removeByClass() removeByNotOfClass() repeatAppend() repeatInsert() replace() scaleDurations() scaleOffsets() setDerivationMethod() setElementOffset() shiftElements() show() showVariantAsOssialikePart() simultaneousAttacks() sliceAtOffsets() sliceByBeat() sliceByGreatestDivisor() sliceByQuarterLengths() sort() sorted() splitAtDurations() splitAtQuarterLength() splitByClass() storeAtEnd() stripTies() template() toSoundingPitch() toWrittenPitch() transferOffsetToElements() transpose() voicesToParts() write()",
        "type": "Table"
    },
    {
        "text": "Methods inherited from StreamCore:",
        "type": "NarrativeText"
    },
    {
        "text": "asTimespans() asTree() coreAppend() coreCopyAsDerivation() coreElementsChanged() coreGatherMissingSpanners() coreGetElementByMemoryLocation() coreGuardBeforeAddElement() coreHasElementByMemoryLocation() coreInsert() coreSelfActiveSite() coreSetElementOffset() coreStoreAtEnd()",
        "type": "Table"
    },
    {
        "text": "Methods inherited from Music21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "clearCache() containerHierarchy() contextSites() getAllContextsByClass() getContextByClass() getOffsetBySite() getOffsetInHierarchy() getSpannerSites() informSites() next() previous() purgeLocations() purgeOrphans() setOffsetBySite() sortTuple() splitByQuarterLengths()",
        "type": "Table"
    },
    {
        "text": "Methods inherited from ProtoM21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "isClassOrSubclass()",
        "type": "Table"
    },
    {
        "text": "Voice instance variables",
        "type": "Title"
    },
    {
        "text": "Instance variables inherited from Stream:",
        "type": "NarrativeText"
    },
    {
        "text": "autoSort definesExplicitPageBreaks definesExplicitSystemBreaks isFlat isSorted recursionType",
        "type": "Table"
    },
    {
        "text": "Instance variables inherited from Music21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "classSortOrder groups isStream sites",
        "type": "Table"
    },
    {
        "text": "SpannerStorage\u00c2\u00b6",
        "type": "Title"
    },
    {
        "text": "class",
        "type": "Title"
    },
    {
        "text": "music21.stream.base.",
        "type": "Title"
    },
    {
        "text": "SpannerStorage",
        "type": "Title"
    },
    {
        "text": "givenElements",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "client",
        "type": "Title"
    },
    {
        "text": "spanner.Spanner | None",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "**",
        "type": "UncategorizedText"
    },
    {
        "text": "keywords",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "For advanced use. This Stream subclass is only used\ninside a Spanner object to provide object storage\nof connected elements (things the Spanner spans).\nThis subclass name can be used to search in an\nobject's .sites and find any and all\nlocations that are SpannerStorage objects.\nA client keyword argument must be provided by the Spanner in creation.\n>>> stream.SpannerStorage(client=spanner.Slur())\n<music21.stream.SpannerStorage for music21.spanner.Slur>\n\n\n\nChanged in v8: spannerParent is renamed client.",
        "type": "ListItem"
    },
    {
        "text": "SpannerStorage bases",
        "type": "Title"
    },
    {
        "text": "Stream",
        "type": "ListItem"
    },
    {
        "text": "StreamCore",
        "type": "ListItem"
    },
    {
        "text": "Music21Object",
        "type": "ListItem"
    },
    {
        "text": "ProtoM21Object",
        "type": "ListItem"
    },
    {
        "text": "SpannerStorage read-only properties",
        "type": "Title"
    },
    {
        "text": "Read-only properties inherited from Stream:",
        "type": "NarrativeText"
    },
    {
        "text": "beat beatDuration beatStr beatStrength flat highestOffset highestTime isGapless lowestOffset notes notesAndRests pitches secondsMap spanners voices",
        "type": "Table"
    },
    {
        "text": "Read-only properties inherited from StreamCore:",
        "type": "NarrativeText"
    },
    {
        "text": "spannerBundle",
        "type": "Table"
    },
    {
        "text": "Read-only properties inherited from Music21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "hasEditorialInformation hasStyleInformation measureNumber",
        "type": "Table"
    },
    {
        "text": "Read-only properties inherited from ProtoM21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "classSet classes",
        "type": "Table"
    },
    {
        "text": "SpannerStorage read/write properties",
        "type": "Title"
    },
    {
        "text": "Read/write properties inherited from Stream:",
        "type": "NarrativeText"
    },
    {
        "text": "atSoundingPitch clef duration elements finalBarline keySignature metadata seconds staffLines timeSignature",
        "type": "Table"
    },
    {
        "text": "Read/write properties inherited from Music21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "activeSite derivation editorial id offset priority quarterLength style",
        "type": "Table"
    },
    {
        "text": "SpannerStorage methods",
        "type": "Title"
    },
    {
        "text": "SpannerStorage.",
        "type": "Title"
    },
    {
        "text": "coreSelfActiveSite",
        "type": "Title"
    },
    {
        "text": "el",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Never set activeSite to spannerStorage",
        "type": "ListItem"
    },
    {
        "text": "SpannerStorage.",
        "type": "Title"
    },
    {
        "text": "coreStoreAtEnd",
        "type": "Title"
    },
    {
        "text": "element",
        "type": "Title"
    },
    {
        "text": "setActiveSite",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "NB \u2014 this is a \u009ccore\u009d method.  General users should use .storeAtEnd() instead.\nCore method for adding end elements.\nTo be called by other methods.",
        "type": "ListItem"
    },
    {
        "text": "SpannerStorage.",
        "type": "Title"
    },
    {
        "text": "replace",
        "type": "NarrativeText"
    },
    {
        "text": "target",
        "type": "Title"
    },
    {
        "text": "Music21Object",
        "type": "Title"
    },
    {
        "text": "replacement",
        "type": "Title"
    },
    {
        "text": "Music21Object",
        "type": "Title"
    },
    {
        "text": "recurse",
        "type": "Title"
    },
    {
        "text": "bool",
        "type": "Title"
    },
    {
        "text": "False",
        "type": "Title"
    },
    {
        "text": "allDerived",
        "type": "NarrativeText"
    },
    {
        "text": "bool",
        "type": "Title"
    },
    {
        "text": "True",
        "type": "Title"
    },
    {
        "text": "\u2192 None",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Overrides replace() in order to check first\nwhether replacement already exists in self. If so, delete target from\nself and return; otherwise call the superclass method.\n\nNew in v7.",
        "type": "ListItem"
    },
    {
        "text": "Methods inherited from Stream:",
        "type": "NarrativeText"
    },
    {
        "text": "__eq__() __getitem__() activateVariants() addGroupForElements() allPlayingWhileSounding() analyze() append() attachIntervalsBetweenStreams() attachMelodicIntervals() augmentOrDiminish() beatAndMeasureFromOffset() chordify() clear() cloneEmpty() containerInHierarchy() elementOffset() expandRepeats() explode() extendDuration() extendTies() extractContext() findConsecutiveNotes() findGaps() first() flatten() flattenUnnecessaryVoices() getElementAfterElement() getElementAtOrBefore() getElementBeforeOffset() getElementById() getElementsByClass() getElementsByGroup() getElementsByOffset() getElementsNotOfClass() getInstrument() getInstruments() getOverlaps() getTimeSignatures() hasElement() hasElementOfClass() hasMeasures() hasPartLikeStreams() hasVoices() haveAccidentalsBeenMade() index() insert() insertAndShift() insertIntoNoteOrChord() invertDiatonic() isSequence() isTwelveTone() isWellFormedNotation() iter() last() lyrics() makeAccidentals() makeBeams() makeImmutable() makeMeasures() makeMutable() makeNotation() makeRests() makeTies() makeVoices() measure() measureOffsetMap() measures() melodicIntervals() mergeAttributes() mergeElements() metronomeMarkBoundaries() offsetMap() playingWhenAttacked() plot() pop() quantize() recurse() recurseRepr() remove() removeByClass() removeByNotOfClass() repeatAppend() repeatInsert() scaleDurations() scaleOffsets() setDerivationMethod() setElementOffset() shiftElements() show() showVariantAsOssialikePart() simultaneousAttacks() sliceAtOffsets() sliceByBeat() sliceByGreatestDivisor() sliceByQuarterLengths() sort() sorted() splitAtDurations() splitAtQuarterLength() splitByClass() storeAtEnd() stripTies() template() toSoundingPitch() toWrittenPitch() transferOffsetToElements() transpose() voicesToParts() write()",
        "type": "Table"
    },
    {
        "text": "Methods inherited from StreamCore:",
        "type": "NarrativeText"
    },
    {
        "text": "asTimespans() asTree() coreAppend() coreCopyAsDerivation() coreElementsChanged() coreGatherMissingSpanners() coreGetElementByMemoryLocation() coreGuardBeforeAddElement() coreHasElementByMemoryLocation() coreInsert() coreSetElementOffset()",
        "type": "Table"
    },
    {
        "text": "Methods inherited from Music21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "clearCache() containerHierarchy() contextSites() getAllContextsByClass() getContextByClass() getOffsetBySite() getOffsetInHierarchy() getSpannerSites() informSites() next() previous() purgeLocations() purgeOrphans() setOffsetBySite() sortTuple() splitByQuarterLengths()",
        "type": "Table"
    },
    {
        "text": "Methods inherited from ProtoM21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "isClassOrSubclass()",
        "type": "Table"
    },
    {
        "text": "SpannerStorage instance variables",
        "type": "Title"
    },
    {
        "text": "Instance variables inherited from Stream:",
        "type": "NarrativeText"
    },
    {
        "text": "autoSort definesExplicitPageBreaks definesExplicitSystemBreaks isFlat isSorted recursionType",
        "type": "Table"
    },
    {
        "text": "Instance variables inherited from Music21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "classSortOrder groups isStream sites",
        "type": "Table"
    },
    {
        "text": "VariantStorage\u00c2\u00b6",
        "type": "Title"
    },
    {
        "text": "class",
        "type": "Title"
    },
    {
        "text": "music21.stream.base.",
        "type": "Title"
    },
    {
        "text": "VariantStorage",
        "type": "Title"
    },
    {
        "text": "givenElements",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "Music21Object",
        "type": "Title"
    },
    {
        "text": "Sequence",
        "type": "Title"
    },
    {
        "text": "Music21Object",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "givenElementsBehavior",
        "type": "Title"
    },
    {
        "text": "GivenElementsBehavior",
        "type": "Title"
    },
    {
        "text": "GivenElementsBehavior.OFFSETS",
        "type": "Title"
    },
    {
        "text": "**",
        "type": "UncategorizedText"
    },
    {
        "text": "keywords",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "For advanced use. This Stream subclass is only\nused inside a Variant object to provide object\nstorage of connected elements (things the Variant\ndefines).\nThis subclass name can be used to search in an\nobject's .sites and find any and all\nlocations that are VariantStorage objects.  It also\nensures that they are pickled properly as Streams on a non-Stream\nobject.\n\nChanged in v8: variantParent is removed.  Never used.",
        "type": "ListItem"
    },
    {
        "text": "VariantStorage bases",
        "type": "Title"
    },
    {
        "text": "Stream",
        "type": "ListItem"
    },
    {
        "text": "StreamCore",
        "type": "ListItem"
    },
    {
        "text": "Music21Object",
        "type": "ListItem"
    },
    {
        "text": "ProtoM21Object",
        "type": "ListItem"
    },
    {
        "text": "VariantStorage read-only properties",
        "type": "NarrativeText"
    },
    {
        "text": "Read-only properties inherited from Stream:",
        "type": "NarrativeText"
    },
    {
        "text": "beat beatDuration beatStr beatStrength flat highestOffset highestTime isGapless lowestOffset notes notesAndRests pitches secondsMap spanners voices",
        "type": "Table"
    },
    {
        "text": "Read-only properties inherited from StreamCore:",
        "type": "NarrativeText"
    },
    {
        "text": "spannerBundle",
        "type": "Table"
    },
    {
        "text": "Read-only properties inherited from Music21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "hasEditorialInformation hasStyleInformation measureNumber",
        "type": "Table"
    },
    {
        "text": "Read-only properties inherited from ProtoM21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "classSet classes",
        "type": "Table"
    },
    {
        "text": "VariantStorage read/write properties",
        "type": "Title"
    },
    {
        "text": "Read/write properties inherited from Stream:",
        "type": "NarrativeText"
    },
    {
        "text": "atSoundingPitch clef duration elements finalBarline keySignature metadata seconds staffLines timeSignature",
        "type": "Table"
    },
    {
        "text": "Read/write properties inherited from Music21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "activeSite derivation editorial id offset priority quarterLength style",
        "type": "Table"
    },
    {
        "text": "VariantStorage methods",
        "type": "Title"
    },
    {
        "text": "Methods inherited from Stream:",
        "type": "NarrativeText"
    },
    {
        "text": "__eq__() __getitem__() activateVariants() addGroupForElements() allPlayingWhileSounding() analyze() append() attachIntervalsBetweenStreams() attachMelodicIntervals() augmentOrDiminish() beatAndMeasureFromOffset() chordify() clear() cloneEmpty() containerInHierarchy() elementOffset() expandRepeats() explode() extendDuration() extendTies() extractContext() findConsecutiveNotes() findGaps() first() flatten() flattenUnnecessaryVoices() getElementAfterElement() getElementAtOrBefore() getElementBeforeOffset() getElementById() getElementsByClass() getElementsByGroup() getElementsByOffset() getElementsNotOfClass() getInstrument() getInstruments() getOverlaps() getTimeSignatures() hasElement() hasElementOfClass() hasMeasures() hasPartLikeStreams() hasVoices() haveAccidentalsBeenMade() index() insert() insertAndShift() insertIntoNoteOrChord() invertDiatonic() isSequence() isTwelveTone() isWellFormedNotation() iter() last() lyrics() makeAccidentals() makeBeams() makeImmutable() makeMeasures() makeMutable() makeNotation() makeRests() makeTies() makeVoices() measure() measureOffsetMap() measures() melodicIntervals() mergeAttributes() mergeElements() metronomeMarkBoundaries() offsetMap() playingWhenAttacked() plot() pop() quantize() recurse() recurseRepr() remove() removeByClass() removeByNotOfClass() repeatAppend() repeatInsert() replace() scaleDurations() scaleOffsets() setDerivationMethod() setElementOffset() shiftElements() show() showVariantAsOssialikePart() simultaneousAttacks() sliceAtOffsets() sliceByBeat() sliceByGreatestDivisor() sliceByQuarterLengths() sort() sorted() splitAtDurations() splitAtQuarterLength() splitByClass() storeAtEnd() stripTies() template() toSoundingPitch() toWrittenPitch() transferOffsetToElements() transpose() voicesToParts() write()",
        "type": "Table"
    },
    {
        "text": "Methods inherited from StreamCore:",
        "type": "NarrativeText"
    },
    {
        "text": "asTimespans() asTree() coreAppend() coreCopyAsDerivation() coreElementsChanged() coreGatherMissingSpanners() coreGetElementByMemoryLocation() coreGuardBeforeAddElement() coreHasElementByMemoryLocation() coreInsert() coreSelfActiveSite() coreSetElementOffset() coreStoreAtEnd()",
        "type": "Table"
    },
    {
        "text": "Methods inherited from Music21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "clearCache() containerHierarchy() contextSites() getAllContextsByClass() getContextByClass() getOffsetBySite() getOffsetInHierarchy() getSpannerSites() informSites() next() previous() purgeLocations() purgeOrphans() setOffsetBySite() sortTuple() splitByQuarterLengths()",
        "type": "Table"
    },
    {
        "text": "Methods inherited from ProtoM21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "isClassOrSubclass()",
        "type": "Table"
    },
    {
        "text": "VariantStorage instance variables",
        "type": "Title"
    },
    {
        "text": "Instance variables inherited from Stream:",
        "type": "NarrativeText"
    },
    {
        "text": "autoSort definesExplicitPageBreaks definesExplicitSystemBreaks isFlat isSorted recursionType",
        "type": "Table"
    },
    {
        "text": "Instance variables inherited from Music21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "classSortOrder groups isStream sites",
        "type": "Table"
    },
    {
        "text": "OffsetMap\u00c2\u00b6",
        "type": "Title"
    },
    {
        "text": "class",
        "type": "Title"
    },
    {
        "text": "music21.stream.base.",
        "type": "Title"
    },
    {
        "text": "OffsetMap",
        "type": "Title"
    },
    {
        "text": "element",
        "type": "Title"
    },
    {
        "text": "offset",
        "type": "Title"
    },
    {
        "text": "endTime",
        "type": "Title"
    },
    {
        "text": "voiceIndex",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "",
        "type": "ListItem"
    },
    {
        "text": "BestQuantizationMatch\u00c2\u00b6",
        "type": "Title"
    },
    {
        "text": "class",
        "type": "Title"
    },
    {
        "text": "music21.stream.base.",
        "type": "Title"
    },
    {
        "text": "BestQuantizationMatch",
        "type": "Title"
    },
    {
        "text": "remainingGap",
        "type": "Title"
    },
    {
        "text": "error",
        "type": "Title"
    },
    {
        "text": "tick",
        "type": "Title"
    },
    {
        "text": "match",
        "type": "Title"
    },
    {
        "text": "signedError",
        "type": "Title"
    },
    {
        "text": "divisor",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "",
        "type": "ListItem"
    },
    {
        "text": "PartStaff\u00c2\u00b6",
        "type": "Title"
    },
    {
        "text": "class",
        "type": "Title"
    },
    {
        "text": "music21.stream.base.",
        "type": "Title"
    },
    {
        "text": "PartStaff",
        "type": "Title"
    },
    {
        "text": "args",
        "type": "Title"
    },
    {
        "text": "**",
        "type": "UncategorizedText"
    },
    {
        "text": "keywords",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "A Part subclass for designating music that is\nrepresented on a single staff but may only be one\nof many staves for a single part.",
        "type": "ListItem"
    },
    {
        "text": "PartStaff bases",
        "type": "Title"
    },
    {
        "text": "Part",
        "type": "ListItem"
    },
    {
        "text": "Stream",
        "type": "ListItem"
    },
    {
        "text": "StreamCore",
        "type": "ListItem"
    },
    {
        "text": "Music21Object",
        "type": "ListItem"
    },
    {
        "text": "ProtoM21Object",
        "type": "ListItem"
    },
    {
        "text": "PartStaff read-only properties",
        "type": "Title"
    },
    {
        "text": "Read-only properties inherited from Stream:",
        "type": "NarrativeText"
    },
    {
        "text": "beat beatDuration beatStr beatStrength flat highestOffset highestTime isGapless lowestOffset notes notesAndRests pitches secondsMap spanners voices",
        "type": "Table"
    },
    {
        "text": "Read-only properties inherited from StreamCore:",
        "type": "NarrativeText"
    },
    {
        "text": "spannerBundle",
        "type": "Table"
    },
    {
        "text": "Read-only properties inherited from Music21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "hasEditorialInformation hasStyleInformation measureNumber",
        "type": "Table"
    },
    {
        "text": "Read-only properties inherited from ProtoM21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "classSet classes",
        "type": "Table"
    },
    {
        "text": "PartStaff read/write properties",
        "type": "Title"
    },
    {
        "text": "Read/write properties inherited from Part:",
        "type": "NarrativeText"
    },
    {
        "text": "partAbbreviation partName",
        "type": "Table"
    },
    {
        "text": "Read/write properties inherited from Stream:",
        "type": "NarrativeText"
    },
    {
        "text": "atSoundingPitch clef duration elements finalBarline keySignature metadata seconds staffLines timeSignature",
        "type": "Table"
    },
    {
        "text": "Read/write properties inherited from Music21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "activeSite derivation editorial id offset priority quarterLength style",
        "type": "Table"
    },
    {
        "text": "PartStaff methods",
        "type": "Title"
    },
    {
        "text": "Methods inherited from Part:",
        "type": "NarrativeText"
    },
    {
        "text": "makeAccidentals() mergeAttributes()",
        "type": "Table"
    },
    {
        "text": "Methods inherited from Stream:",
        "type": "NarrativeText"
    },
    {
        "text": "__eq__() __getitem__() activateVariants() addGroupForElements() allPlayingWhileSounding() analyze() append() attachIntervalsBetweenStreams() attachMelodicIntervals() augmentOrDiminish() beatAndMeasureFromOffset() chordify() clear() cloneEmpty() containerInHierarchy() elementOffset() expandRepeats() explode() extendDuration() extendTies() extractContext() findConsecutiveNotes() findGaps() first() flatten() flattenUnnecessaryVoices() getElementAfterElement() getElementAtOrBefore() getElementBeforeOffset() getElementById() getElementsByClass() getElementsByGroup() getElementsByOffset() getElementsNotOfClass() getInstrument() getInstruments() getOverlaps() getTimeSignatures() hasElement() hasElementOfClass() hasMeasures() hasPartLikeStreams() hasVoices() haveAccidentalsBeenMade() index() insert() insertAndShift() insertIntoNoteOrChord() invertDiatonic() isSequence() isTwelveTone() isWellFormedNotation() iter() last() lyrics() makeBeams() makeImmutable() makeMeasures() makeMutable() makeNotation() makeRests() makeTies() makeVoices() measure() measureOffsetMap() measures() melodicIntervals() mergeElements() metronomeMarkBoundaries() offsetMap() playingWhenAttacked() plot() pop() quantize() recurse() recurseRepr() remove() removeByClass() removeByNotOfClass() repeatAppend() repeatInsert() replace() scaleDurations() scaleOffsets() setDerivationMethod() setElementOffset() shiftElements() show() showVariantAsOssialikePart() simultaneousAttacks() sliceAtOffsets() sliceByBeat() sliceByGreatestDivisor() sliceByQuarterLengths() sort() sorted() splitAtDurations() splitAtQuarterLength() splitByClass() storeAtEnd() stripTies() template() toSoundingPitch() toWrittenPitch() transferOffsetToElements() transpose() voicesToParts() write()",
        "type": "Table"
    },
    {
        "text": "Methods inherited from StreamCore:",
        "type": "NarrativeText"
    },
    {
        "text": "asTimespans() asTree() coreAppend() coreCopyAsDerivation() coreElementsChanged() coreGatherMissingSpanners() coreGetElementByMemoryLocation() coreGuardBeforeAddElement() coreHasElementByMemoryLocation() coreInsert() coreSelfActiveSite() coreSetElementOffset() coreStoreAtEnd()",
        "type": "Table"
    },
    {
        "text": "Methods inherited from Music21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "clearCache() containerHierarchy() contextSites() getAllContextsByClass() getContextByClass() getOffsetBySite() getOffsetInHierarchy() getSpannerSites() informSites() next() previous() purgeLocations() purgeOrphans() setOffsetBySite() sortTuple() splitByQuarterLengths()",
        "type": "Table"
    },
    {
        "text": "Methods inherited from ProtoM21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "isClassOrSubclass()",
        "type": "Table"
    },
    {
        "text": "PartStaff instance variables",
        "type": "Title"
    },
    {
        "text": "Instance variables inherited from Stream:",
        "type": "NarrativeText"
    },
    {
        "text": "autoSort definesExplicitPageBreaks definesExplicitSystemBreaks isFlat isSorted recursionType",
        "type": "Table"
    },
    {
        "text": "Instance variables inherited from Music21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "classSortOrder groups isStream sites",
        "type": "Table"
    },
    {
        "text": "System\u00c2\u00b6",
        "type": "Title"
    },
    {
        "text": "class",
        "type": "Title"
    },
    {
        "text": "music21.stream.base.",
        "type": "Title"
    },
    {
        "text": "System",
        "type": "Title"
    },
    {
        "text": "givenElements",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "Music21Object",
        "type": "Title"
    },
    {
        "text": "Sequence",
        "type": "Title"
    },
    {
        "text": "Music21Object",
        "type": "Title"
    },
    {
        "text": "None",
        "type": "Title"
    },
    {
        "text": "givenElementsBehavior",
        "type": "Title"
    },
    {
        "text": "GivenElementsBehavior",
        "type": "Title"
    },
    {
        "text": "GivenElementsBehavior.OFFSETS",
        "type": "Title"
    },
    {
        "text": "**",
        "type": "UncategorizedText"
    },
    {
        "text": "keywords",
        "type": "Title"
    },
    {
        "text": "\u00c2\u00b6",
        "type": "UncategorizedText"
    },
    {
        "text": "Totally optional and used only in OMR and Capella: a designation that all the\nmusic in this Stream belongs in a single system.\nThe system object has two attributes, systemNumber (which number is it)\nand systemNumbering which says at what point the numbering of\nsystems resets.  It can be either \u009cScore\u009d (default), \u009cOpus\u009d, or \u009cPage\u009d.",
        "type": "ListItem"
    },
    {
        "text": "System bases",
        "type": "Title"
    },
    {
        "text": "Stream",
        "type": "ListItem"
    },
    {
        "text": "StreamCore",
        "type": "ListItem"
    },
    {
        "text": "Music21Object",
        "type": "ListItem"
    },
    {
        "text": "ProtoM21Object",
        "type": "ListItem"
    },
    {
        "text": "System read-only properties",
        "type": "Title"
    },
    {
        "text": "Read-only properties inherited from Stream:",
        "type": "NarrativeText"
    },
    {
        "text": "beat beatDuration beatStr beatStrength flat highestOffset highestTime isGapless lowestOffset notes notesAndRests pitches secondsMap spanners voices",
        "type": "Table"
    },
    {
        "text": "Read-only properties inherited from StreamCore:",
        "type": "NarrativeText"
    },
    {
        "text": "spannerBundle",
        "type": "Table"
    },
    {
        "text": "Read-only properties inherited from Music21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "hasEditorialInformation hasStyleInformation measureNumber",
        "type": "Table"
    },
    {
        "text": "Read-only properties inherited from ProtoM21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "classSet classes",
        "type": "Table"
    },
    {
        "text": "System read/write properties",
        "type": "Title"
    },
    {
        "text": "Read/write properties inherited from Stream:",
        "type": "NarrativeText"
    },
    {
        "text": "atSoundingPitch clef duration elements finalBarline keySignature metadata seconds staffLines timeSignature",
        "type": "Table"
    },
    {
        "text": "Read/write properties inherited from Music21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "activeSite derivation editorial id offset priority quarterLength style",
        "type": "Table"
    },
    {
        "text": "System methods",
        "type": "Title"
    },
    {
        "text": "Methods inherited from Stream:",
        "type": "NarrativeText"
    },
    {
        "text": "__eq__() __getitem__() activateVariants() addGroupForElements() allPlayingWhileSounding() analyze() append() attachIntervalsBetweenStreams() attachMelodicIntervals() augmentOrDiminish() beatAndMeasureFromOffset() chordify() clear() cloneEmpty() containerInHierarchy() elementOffset() expandRepeats() explode() extendDuration() extendTies() extractContext() findConsecutiveNotes() findGaps() first() flatten() flattenUnnecessaryVoices() getElementAfterElement() getElementAtOrBefore() getElementBeforeOffset() getElementById() getElementsByClass() getElementsByGroup() getElementsByOffset() getElementsNotOfClass() getInstrument() getInstruments() getOverlaps() getTimeSignatures() hasElement() hasElementOfClass() hasMeasures() hasPartLikeStreams() hasVoices() haveAccidentalsBeenMade() index() insert() insertAndShift() insertIntoNoteOrChord() invertDiatonic() isSequence() isTwelveTone() isWellFormedNotation() iter() last() lyrics() makeAccidentals() makeBeams() makeImmutable() makeMeasures() makeMutable() makeNotation() makeRests() makeTies() makeVoices() measure() measureOffsetMap() measures() melodicIntervals() mergeAttributes() mergeElements() metronomeMarkBoundaries() offsetMap() playingWhenAttacked() plot() pop() quantize() recurse() recurseRepr() remove() removeByClass() removeByNotOfClass() repeatAppend() repeatInsert() replace() scaleDurations() scaleOffsets() setDerivationMethod() setElementOffset() shiftElements() show() showVariantAsOssialikePart() simultaneousAttacks() sliceAtOffsets() sliceByBeat() sliceByGreatestDivisor() sliceByQuarterLengths() sort() sorted() splitAtDurations() splitAtQuarterLength() splitByClass() storeAtEnd() stripTies() template() toSoundingPitch() toWrittenPitch() transferOffsetToElements() transpose() voicesToParts() write()",
        "type": "Table"
    },
    {
        "text": "Methods inherited from StreamCore:",
        "type": "NarrativeText"
    },
    {
        "text": "asTimespans() asTree() coreAppend() coreCopyAsDerivation() coreElementsChanged() coreGatherMissingSpanners() coreGetElementByMemoryLocation() coreGuardBeforeAddElement() coreHasElementByMemoryLocation() coreInsert() coreSelfActiveSite() coreSetElementOffset() coreStoreAtEnd()",
        "type": "Table"
    },
    {
        "text": "Methods inherited from Music21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "clearCache() containerHierarchy() contextSites() getAllContextsByClass() getContextByClass() getOffsetBySite() getOffsetInHierarchy() getSpannerSites() informSites() next() previous() purgeLocations() purgeOrphans() setOffsetBySite() sortTuple() splitByQuarterLengths()",
        "type": "Table"
    },
    {
        "text": "Methods inherited from ProtoM21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "isClassOrSubclass()",
        "type": "Table"
    },
    {
        "text": "System instance variables",
        "type": "Title"
    },
    {
        "text": "Instance variables inherited from Stream:",
        "type": "NarrativeText"
    },
    {
        "text": "autoSort definesExplicitPageBreaks definesExplicitSystemBreaks isFlat isSorted recursionType",
        "type": "Table"
    },
    {
        "text": "Instance variables inherited from Music21Object:",
        "type": "NarrativeText"
    },
    {
        "text": "classSortOrder groups isStream sites",
        "type": "Table"
    },
    {
        "text": "Navigation",
        "type": "Title"
    },
    {
        "text": "index",
        "type": "ListItem"
    },
    {
        "text": "modules |",
        "type": "ListItem"
    },
    {
        "text": "next |",
        "type": "ListItem"
    },
    {
        "text": "previous |",
        "type": "ListItem"
    },
    {
        "text": "music21 \u00bb",
        "type": "ListItem"
    },
    {
        "text": "Module Reference \u00bb",
        "type": "ListItem"
    },
    {
        "text": "music21.stream.base",
        "type": "ListItem"
    },
    {
        "text": "\u00a9 Copyright 2006-2023 Michael Scott Asato Cuthbert.\n      Last updated on Jun 12, 2023.",
        "type": "NarrativeText"
    }
]